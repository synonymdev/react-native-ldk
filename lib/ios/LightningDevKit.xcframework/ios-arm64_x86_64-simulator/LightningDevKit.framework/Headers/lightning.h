#ifndef LDK_C_BINDINGS_H
#define LDK_C_BINDINGS_H

/* Generated with cbindgen:0.24.5 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include "ldk_rust_types.h"

/**
 * Errors that may occur when converting a [`RawBolt11Invoice`] to a [`Bolt11Invoice`]. They relate to
 * the requirements sections in BOLT #11
 */
typedef enum LDKBolt11SemanticError {
   /**
    * The invoice is missing the mandatory payment hash
    */
   LDKBolt11SemanticError_NoPaymentHash,
   /**
    * The invoice has multiple payment hashes which isn't allowed
    */
   LDKBolt11SemanticError_MultiplePaymentHashes,
   /**
    * No description or description hash are part of the invoice
    */
   LDKBolt11SemanticError_NoDescription,
   /**
    * The invoice contains multiple descriptions and/or description hashes which isn't allowed
    */
   LDKBolt11SemanticError_MultipleDescriptions,
   /**
    * The invoice is missing the mandatory payment secret, which all modern lightning nodes
    * should provide.
    */
   LDKBolt11SemanticError_NoPaymentSecret,
   /**
    * The invoice contains multiple payment secrets
    */
   LDKBolt11SemanticError_MultiplePaymentSecrets,
   /**
    * The invoice's features are invalid
    */
   LDKBolt11SemanticError_InvalidFeatures,
   /**
    * The recovery id doesn't fit the signature/pub key
    */
   LDKBolt11SemanticError_InvalidRecoveryId,
   /**
    * The invoice's signature is invalid
    */
   LDKBolt11SemanticError_InvalidSignature,
   /**
    * The invoice's amount was not a whole number of millisatoshis
    */
   LDKBolt11SemanticError_ImpreciseAmount,
   /**
    * Must be last for serialization purposes
    */
   LDKBolt11SemanticError_Sentinel,
} LDKBolt11SemanticError;

/**
 * Error when interpreting a TLV stream as a specific type.
 */
typedef enum LDKBolt12SemanticError {
   /**
    * The current [`std::time::SystemTime`] is past the offer or invoice's expiration.
    */
   LDKBolt12SemanticError_AlreadyExpired,
   /**
    * The provided chain hash does not correspond to a supported chain.
    */
   LDKBolt12SemanticError_UnsupportedChain,
   /**
    * A chain was provided but was not expected.
    */
   LDKBolt12SemanticError_UnexpectedChain,
   /**
    * An amount was expected but was missing.
    */
   LDKBolt12SemanticError_MissingAmount,
   /**
    * The amount exceeded the total bitcoin supply.
    */
   LDKBolt12SemanticError_InvalidAmount,
   /**
    * An amount was provided but was not sufficient in value.
    */
   LDKBolt12SemanticError_InsufficientAmount,
   /**
    * An amount was provided but was not expected.
    */
   LDKBolt12SemanticError_UnexpectedAmount,
   /**
    * A currency was provided that is not supported.
    */
   LDKBolt12SemanticError_UnsupportedCurrency,
   /**
    * A feature was required but is unknown.
    */
   LDKBolt12SemanticError_UnknownRequiredFeatures,
   /**
    * Features were provided but were not expected.
    */
   LDKBolt12SemanticError_UnexpectedFeatures,
   /**
    * A required description was not provided.
    */
   LDKBolt12SemanticError_MissingDescription,
   /**
    * A signing pubkey was not provided.
    */
   LDKBolt12SemanticError_MissingSigningPubkey,
   /**
    * A signing pubkey was provided but a different one was expected.
    */
   LDKBolt12SemanticError_InvalidSigningPubkey,
   /**
    * A signing pubkey was provided but was not expected.
    */
   LDKBolt12SemanticError_UnexpectedSigningPubkey,
   /**
    * A quantity was expected but was missing.
    */
   LDKBolt12SemanticError_MissingQuantity,
   /**
    * An unsupported quantity was provided.
    */
   LDKBolt12SemanticError_InvalidQuantity,
   /**
    * A quantity or quantity bounds was provided but was not expected.
    */
   LDKBolt12SemanticError_UnexpectedQuantity,
   /**
    * Metadata could not be used to verify the offers message.
    */
   LDKBolt12SemanticError_InvalidMetadata,
   /**
    * Metadata was provided but was not expected.
    */
   LDKBolt12SemanticError_UnexpectedMetadata,
   /**
    * Payer metadata was expected but was missing.
    */
   LDKBolt12SemanticError_MissingPayerMetadata,
   /**
    * A payer id was expected but was missing.
    */
   LDKBolt12SemanticError_MissingPayerId,
   /**
    * Blinded paths were expected but were missing.
    */
   LDKBolt12SemanticError_MissingPaths,
   /**
    * The blinded payinfo given does not match the number of blinded path hops.
    */
   LDKBolt12SemanticError_InvalidPayInfo,
   /**
    * An invoice creation time was expected but was missing.
    */
   LDKBolt12SemanticError_MissingCreationTime,
   /**
    * An invoice payment hash was expected but was missing.
    */
   LDKBolt12SemanticError_MissingPaymentHash,
   /**
    * A signature was expected but was missing.
    */
   LDKBolt12SemanticError_MissingSignature,
   /**
    * Must be last for serialization purposes
    */
   LDKBolt12SemanticError_Sentinel,
} LDKBolt12SemanticError;

/**
 * An enum which can either contain a  or not
 */
typedef enum LDKCOption_NoneZ {
   /**
    * When we're in this state, this COption_NoneZ contains a
    */
   LDKCOption_NoneZ_Some,
   /**
    * When we're in this state, this COption_NoneZ contains nothing
    */
   LDKCOption_NoneZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NoneZ_Sentinel,
} LDKCOption_NoneZ;

/**
 * An enum representing the status of a channel monitor update persistence.
 *
 * These are generally used as the return value for an implementation of [`Persist`] which is used
 * as the storage layer for a [`ChainMonitor`]. See the docs on [`Persist`] for a high-level
 * explanation of how to handle different cases.
 *
 * While `UnrecoverableError` is provided as a failure variant, it is not truly \"handled\" on the
 * calling side, and generally results in an immediate panic. For those who prefer to avoid
 * panics, `InProgress` can be used and you can retry the update operation in the background or
 * shut down cleanly.
 *
 * Note that channels should generally *not* be force-closed after a persistence failure.
 * Force-closing with the latest [`ChannelMonitorUpdate`] applied may result in a transaction
 * being broadcast which can only be spent by the latest [`ChannelMonitor`]! Thus, if the
 * latest [`ChannelMonitor`] is not durably persisted anywhere and exists only in memory, naively
 * calling [`ChannelManager::force_close_broadcasting_latest_txn`] *may result in loss of funds*!
 *
 * [`Persist`]: chainmonitor::Persist
 * [`ChainMonitor`]: chainmonitor::ChainMonitor
 * [`ChannelManager::force_close_broadcasting_latest_txn`]: crate::ln::channelmanager::ChannelManager::force_close_broadcasting_latest_txn
 */
typedef enum LDKChannelMonitorUpdateStatus {
   /**
    * The update has been durably persisted and all copies of the relevant [`ChannelMonitor`]
    * have been updated.
    *
    * This includes performing any `fsync()` calls required to ensure the update is guaranteed to
    * be available on restart even if the application crashes.
    */
   LDKChannelMonitorUpdateStatus_Completed,
   /**
    * Indicates that the update will happen asynchronously in the background or that a transient
    * failure occurred which is being retried in the background and will eventually complete.
    *
    * This will \"freeze\" a channel, preventing us from revoking old states or submitting a new
    * commitment transaction to the counterparty. Once the update(s) which are `InProgress` have
    * been completed, a [`MonitorEvent::Completed`] can be used to restore the channel to an
    * operational state.
    *
    * Even when a channel has been \"frozen\", updates to the [`ChannelMonitor`] can continue to
    * occur (e.g. if an inbound HTLC which we forwarded was claimed upstream, resulting in us
    * attempting to claim it on this channel) and those updates must still be persisted.
    *
    * No updates to the channel will be made which could invalidate other [`ChannelMonitor`]s
    * until a [`MonitorEvent::Completed`] is provided, even if you return no error on a later
    * monitor update for the same channel.
    *
    * For deployments where a copy of [`ChannelMonitor`]s and other local state are backed up in
    * a remote location (with local copies persisted immediately), it is anticipated that all
    * updates will return [`InProgress`] until the remote copies could be updated.
    *
    * Note that while fully asynchronous persistence of [`ChannelMonitor`] data is generally
    * reliable, this feature is considered beta, and a handful of edge-cases remain. Until the
    * remaining cases are fixed, in rare cases, *using this feature may lead to funds loss*.
    *
    * [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
    */
   LDKChannelMonitorUpdateStatus_InProgress,
   /**
    * Indicates that an update has failed and will not complete at any point in the future.
    *
    * Currently returning this variant will cause LDK to immediately panic to encourage immediate
    * shutdown. In the future this may be updated to disconnect peers and refuse to continue
    * normal operation without a panic.
    *
    * Applications which wish to perform an orderly shutdown after failure should consider
    * returning [`InProgress`] instead and simply shut down without ever marking the update
    * complete.
    *
    * [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
    */
   LDKChannelMonitorUpdateStatus_UnrecoverableError,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelMonitorUpdateStatus_Sentinel,
} LDKChannelMonitorUpdateStatus;

/**
 * Further information on the details of the channel shutdown.
 * Upon channels being forced closed (i.e. commitment transaction confirmation detected
 * by `ChainMonitor`), ChannelShutdownState will be set to `ShutdownComplete` or
 * the channel will be removed shortly.
 * Also note, that in normal operation, peers could disconnect at any of these states
 * and require peer re-connection before making progress onto other states
 */
typedef enum LDKChannelShutdownState {
   /**
    * Channel has not sent or received a shutdown message.
    */
   LDKChannelShutdownState_NotShuttingDown,
   /**
    * Local node has sent a shutdown message for this channel.
    */
   LDKChannelShutdownState_ShutdownInitiated,
   /**
    * Shutdown message exchanges have concluded and the channels are in the midst of
    * resolving all existing open HTLCs before closing can continue.
    */
   LDKChannelShutdownState_ResolvingHTLCs,
   /**
    * All HTLCs have been resolved, nodes are currently negotiating channel close onchain fee rates.
    */
   LDKChannelShutdownState_NegotiatingClosingFee,
   /**
    * We've successfully negotiated a closing_signed dance. At this point `ChannelManager` is about
    * to drop the channel.
    */
   LDKChannelShutdownState_ShutdownComplete,
   /**
    * Must be last for serialization purposes
    */
   LDKChannelShutdownState_Sentinel,
} LDKChannelShutdownState;

/**
 * An enum that represents the priority at which we want a transaction to confirm used for feerate
 * estimation.
 */
typedef enum LDKConfirmationTarget {
   /**
    * We'd like a transaction to confirm in the future, but don't want to commit most of the fees
    * required to do so yet. The remaining fees will come via a Child-Pays-For-Parent (CPFP) fee
    * bump of the transaction.
    *
    * The feerate returned should be the absolute minimum feerate required to enter most node
    * mempools across the network. Note that if you are not able to obtain this feerate estimate,
    * you should likely use the furthest-out estimate allowed by your fee estimator.
    */
   LDKConfirmationTarget_MempoolMinimum,
   /**
    * We are happy with a transaction confirming slowly, at least within a day or so worth of
    * blocks.
    */
   LDKConfirmationTarget_Background,
   /**
    * We'd like a transaction to confirm without major delayed, i.e., within the next 12-24 blocks.
    */
   LDKConfirmationTarget_Normal,
   /**
    * We'd like a transaction to confirm in the next few blocks.
    */
   LDKConfirmationTarget_HighPriority,
   /**
    * Must be last for serialization purposes
    */
   LDKConfirmationTarget_Sentinel,
} LDKConfirmationTarget;

/**
 * Errors that may occur when constructing a new [`RawBolt11Invoice`] or [`Bolt11Invoice`]
 */
typedef enum LDKCreationError {
   /**
    * The supplied description string was longer than 639 __bytes__ (see [`Description::new`])
    */
   LDKCreationError_DescriptionTooLong,
   /**
    * The specified route has too many hops and can't be encoded
    */
   LDKCreationError_RouteTooLong,
   /**
    * The Unix timestamp of the supplied date is less than zero or greater than 35-bits
    */
   LDKCreationError_TimestampOutOfBounds,
   /**
    * The supplied millisatoshi amount was greater than the total bitcoin supply.
    */
   LDKCreationError_InvalidAmount,
   /**
    * Route hints were required for this invoice and were missing. Applies to
    * [phantom invoices].
    *
    * [phantom invoices]: crate::utils::create_phantom_invoice
    */
   LDKCreationError_MissingRouteHints,
   /**
    * The provided `min_final_cltv_expiry_delta` was less than [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
    *
    * [`MIN_FINAL_CLTV_EXPIRY_DELTA`]: lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
    */
   LDKCreationError_MinFinalCltvExpiryDeltaTooShort,
   /**
    * Must be last for serialization purposes
    */
   LDKCreationError_Sentinel,
} LDKCreationError;

/**
 * Enum representing the crypto currencies (or networks) supported by this library
 */
typedef enum LDKCurrency {
   /**
    * Bitcoin mainnet
    */
   LDKCurrency_Bitcoin,
   /**
    * Bitcoin testnet
    */
   LDKCurrency_BitcoinTestnet,
   /**
    * Bitcoin regtest
    */
   LDKCurrency_Regtest,
   /**
    * Bitcoin simnet
    */
   LDKCurrency_Simnet,
   /**
    * Bitcoin signet
    */
   LDKCurrency_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKCurrency_Sentinel,
} LDKCurrency;

/**
 * Describes the type of HTLC claim as determined by analyzing the witness.
 */
typedef enum LDKHTLCClaim {
   /**
    * Claims an offered output on a commitment transaction through the timeout path.
    */
   LDKHTLCClaim_OfferedTimeout,
   /**
    * Claims an offered output on a commitment transaction through the success path.
    */
   LDKHTLCClaim_OfferedPreimage,
   /**
    * Claims an accepted output on a commitment transaction through the timeout path.
    */
   LDKHTLCClaim_AcceptedTimeout,
   /**
    * Claims an accepted output on a commitment transaction through the success path.
    */
   LDKHTLCClaim_AcceptedPreimage,
   /**
    * Claims an offered/accepted output on a commitment transaction through the revocation path.
    */
   LDKHTLCClaim_Revocation,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCClaim_Sentinel,
} LDKHTLCClaim;

/**
 * Represents an IO Error. Note that some information is lost in the conversion from Rust.
 */
typedef enum LDKIOError {
   LDKIOError_NotFound,
   LDKIOError_PermissionDenied,
   LDKIOError_ConnectionRefused,
   LDKIOError_ConnectionReset,
   LDKIOError_ConnectionAborted,
   LDKIOError_NotConnected,
   LDKIOError_AddrInUse,
   LDKIOError_AddrNotAvailable,
   LDKIOError_BrokenPipe,
   LDKIOError_AlreadyExists,
   LDKIOError_WouldBlock,
   LDKIOError_InvalidInput,
   LDKIOError_InvalidData,
   LDKIOError_TimedOut,
   LDKIOError_WriteZero,
   LDKIOError_Interrupted,
   LDKIOError_Other,
   LDKIOError_UnexpectedEof,
   /**
    * Must be last for serialization purposes
    */
   LDKIOError_Sentinel,
} LDKIOError;

/**
 * An enum representing the available verbosity levels of the logger.
 */
typedef enum LDKLevel {
   /**
    * Designates extremely verbose information, including gossip-induced messages
    */
   LDKLevel_Gossip,
   /**
    * Designates very low priority, often extremely verbose, information
    */
   LDKLevel_Trace,
   /**
    * Designates lower priority information
    */
   LDKLevel_Debug,
   /**
    * Designates useful information
    */
   LDKLevel_Info,
   /**
    * Designates hazardous situations
    */
   LDKLevel_Warn,
   /**
    * Designates very serious errors
    */
   LDKLevel_Error,
   /**
    * Must be last for serialization purposes
    */
   LDKLevel_Sentinel,
} LDKLevel;

/**
 * An enum representing the possible Bitcoin or test networks which we can run on
 */
typedef enum LDKNetwork {
   /**
    * The main Bitcoin blockchain.
    */
   LDKNetwork_Bitcoin,
   /**
    * The testnet3 blockchain.
    */
   LDKNetwork_Testnet,
   /**
    * A local test blockchain.
    */
   LDKNetwork_Regtest,
   /**
    * A blockchain on which blocks are signed instead of mined.
    */
   LDKNetwork_Signet,
   /**
    * Must be last for serialization purposes
    */
   LDKNetwork_Sentinel,
} LDKNetwork;

/**
 * The reason the payment failed. Used in [`Event::PaymentFailed`].
 */
typedef enum LDKPaymentFailureReason {
   /**
    * The intended recipient rejected our payment.
    */
   LDKPaymentFailureReason_RecipientRejected,
   /**
    * The user chose to abandon this payment by calling [`ChannelManager::abandon_payment`].
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   LDKPaymentFailureReason_UserAbandoned,
   /**
    * We exhausted all of our retry attempts while trying to send the payment, or we
    * exhausted the [`Retry::Timeout`] if the user set one. If at any point a retry
    * attempt failed while being forwarded along the path, an [`Event::PaymentPathFailed`] will
    * have come before this.
    *
    * [`Retry::Timeout`]: crate::ln::channelmanager::Retry::Timeout
    */
   LDKPaymentFailureReason_RetriesExhausted,
   /**
    * The payment expired while retrying, based on the provided
    * [`PaymentParameters::expiry_time`].
    *
    * [`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
    */
   LDKPaymentFailureReason_PaymentExpired,
   /**
    * We failed to find a route while retrying the payment.
    */
   LDKPaymentFailureReason_RouteNotFound,
   /**
    * This error should generally never happen. This likely means that there is a problem with
    * your router.
    */
   LDKPaymentFailureReason_UnexpectedError,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentFailureReason_Sentinel,
} LDKPaymentFailureReason;

/**
 * Specifies the recipient of an invoice.
 *
 * This indicates to [`NodeSigner::sign_invoice`] what node secret key should be used to sign
 * the invoice.
 */
typedef enum LDKRecipient {
   /**
    * The invoice should be signed with the local node secret key.
    */
   LDKRecipient_Node,
   /**
    * The invoice should be signed with the phantom node secret key. This secret key must be the
    * same for all nodes participating in the [phantom node payment].
    *
    * [phantom node payment]: PhantomKeysManager
    */
   LDKRecipient_PhantomNode,
   /**
    * Must be last for serialization purposes
    */
   LDKRecipient_Sentinel,
} LDKRecipient;

/**
 * Indicates an immediate error on [`ChannelManager::send_payment`]. Further errors may be
 * surfaced later via [`Event::PaymentPathFailed`] and [`Event::PaymentFailed`].
 *
 * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
 * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
 */
typedef enum LDKRetryableSendFailure {
   /**
    * The provided [`PaymentParameters::expiry_time`] indicated that the payment has expired. Note
    * that this error is *not* caused by [`Retry::Timeout`].
    *
    * [`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
    */
   LDKRetryableSendFailure_PaymentExpired,
   /**
    * We were unable to find a route to the destination.
    */
   LDKRetryableSendFailure_RouteNotFound,
   /**
    * Indicates that a payment for the provided [`PaymentId`] is already in-flight and has not
    * yet completed (i.e. generated an [`Event::PaymentSent`] or [`Event::PaymentFailed`]).
    *
    * [`PaymentId`]: crate::ln::channelmanager::PaymentId
    * [`Event::PaymentSent`]: crate::events::Event::PaymentSent
    * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
    */
   LDKRetryableSendFailure_DuplicatePayment,
   /**
    * Must be last for serialization purposes
    */
   LDKRetryableSendFailure_Sentinel,
} LDKRetryableSendFailure;

/**
 * Represents an error returned from libsecp256k1 during validation of some secp256k1 data
 */
typedef enum LDKSecp256k1Error {
   /**
    * Signature failed verification
    */
   LDKSecp256k1Error_IncorrectSignature,
   /**
    * Badly sized message ("messages" are actually fixed-sized digests; see the MESSAGE_SIZE constant)
    */
   LDKSecp256k1Error_InvalidMessage,
   /**
    * Bad public key
    */
   LDKSecp256k1Error_InvalidPublicKey,
   /**
    * Bad signature
    */
   LDKSecp256k1Error_InvalidSignature,
   /**
    * Bad secret key
    */
   LDKSecp256k1Error_InvalidSecretKey,
   /**
    * Bad shared secret.
    */
   LDKSecp256k1Error_InvalidSharedSecret,
   /**
    * Bad recovery id
    */
   LDKSecp256k1Error_InvalidRecoveryId,
   /**
    * Invalid tweak for add_assign or mul_assign
    */
   LDKSecp256k1Error_InvalidTweak,
   /**
    * Didn't pass enough memory to context creation with preallocated memory
    */
   LDKSecp256k1Error_NotEnoughMemory,
   /**
    * Bad set of public keys.
    */
   LDKSecp256k1Error_InvalidPublicKeySum,
   /**
    * The only valid parity values are 0 or 1.
    */
   LDKSecp256k1Error_InvalidParityValue,
   /**
    * Must be last for serialization purposes
    */
   LDKSecp256k1Error_Sentinel,
} LDKSecp256k1Error;

/**
 * SI prefixes for the human readable part
 */
typedef enum LDKSiPrefix {
   /**
    * 10^-3
    */
   LDKSiPrefix_Milli,
   /**
    * 10^-6
    */
   LDKSiPrefix_Micro,
   /**
    * 10^-9
    */
   LDKSiPrefix_Nano,
   /**
    * 10^-12
    */
   LDKSiPrefix_Pico,
   /**
    * Must be last for serialization purposes
    */
   LDKSiPrefix_Sentinel,
} LDKSiPrefix;

/**
 * [`SocketAddress`] error variants
 */
typedef enum LDKSocketAddressParseError {
   /**
    * Socket address (IPv4/IPv6) parsing error
    */
   LDKSocketAddressParseError_SocketAddrParse,
   /**
    * Invalid input format
    */
   LDKSocketAddressParseError_InvalidInput,
   /**
    * Invalid port
    */
   LDKSocketAddressParseError_InvalidPort,
   /**
    * Invalid onion v3 address
    */
   LDKSocketAddressParseError_InvalidOnionV3,
   /**
    * Must be last for serialization purposes
    */
   LDKSocketAddressParseError_Sentinel,
} LDKSocketAddressParseError;

/**
 * An error when accessing the chain via [`UtxoLookup`].
 */
typedef enum LDKUtxoLookupError {
   /**
    * The requested chain is unknown.
    */
   LDKUtxoLookupError_UnknownChain,
   /**
    * The requested transaction doesn't exist or hasn't confirmed.
    */
   LDKUtxoLookupError_UnknownTx,
   /**
    * Must be last for serialization purposes
    */
   LDKUtxoLookupError_Sentinel,
} LDKUtxoLookupError;

/**
 * A Rust str object, ie a reference to a UTF8-valid string.
 * This is *not* null-terminated so cannot be used directly as a C string!
 */
typedef struct LDKStr {
   /**
    * A pointer to the string's bytes, in UTF8 encoding
    */
   const uint8_t *chars;
   /**
    * The number of bytes (not characters!) pointed to by `chars`
    */
   uintptr_t len;
   /**
    * Whether the data pointed to by `chars` should be freed or not.
    */
   bool chars_is_owned;
} LDKStr;

/**
 * A 16-byte byte array.
 */
typedef struct LDKSixteenBytes {
   /**
    * The sixteen bytes
    */
   uint8_t data[16];
} LDKSixteenBytes;

/**
 * Unsigned, 128-bit integer.
 *
 * Because LLVM implements an incorrect ABI for 128-bit integers, a wrapper type is defined here.
 * See https://github.com/rust-lang/rust/issues/54341 for more details.
 */
typedef struct LDKU128 {
   /**
    * The 128-bit integer, as 16 little-endian bytes
    */
   uint8_t le_bytes[16];
} LDKU128;

/**
 * Represents a scalar value between zero and the secp256k1 curve order, in big endian.
 */
typedef struct LDKBigEndianScalar {
   /**
    * The bytes of the scalar value.
    */
   uint8_t big_endian_bytes[32];
} LDKBigEndianScalar;

/**
 * Arbitrary 32 bytes, which could represent one of a few different things. You probably want to
 * look up the corresponding function in rust-lightning's docs.
 */
typedef struct LDKThirtyTwoBytes {
   /**
    * The thirty-two bytes
    */
   uint8_t data[32];
} LDKThirtyTwoBytes;

/**
 * Represents an error returned from the bech32 library during validation of some bech32 data
 */
typedef enum LDKBech32Error_Tag {
   /**
    * String does not contain the separator character
    */
   LDKBech32Error_MissingSeparator,
   /**
    * The checksum does not match the rest of the data
    */
   LDKBech32Error_InvalidChecksum,
   /**
    * The data or human-readable part is too long or too short
    */
   LDKBech32Error_InvalidLength,
   /**
    * Some part of the string contains an invalid character
    */
   LDKBech32Error_InvalidChar,
   /**
    * Some part of the data has an invalid value
    */
   LDKBech32Error_InvalidData,
   /**
    * The bit conversion failed due to a padding issue
    */
   LDKBech32Error_InvalidPadding,
   /**
    * The whole string must be of one case
    */
   LDKBech32Error_MixedCase,
   /**
    * Must be last for serialization purposes
    */
   LDKBech32Error_Sentinel,
} LDKBech32Error_Tag;

typedef struct LDKBech32Error {
   LDKBech32Error_Tag tag;
   union {
      struct {
         uint32_t invalid_char;
      };
      struct {
         uint8_t invalid_data;
      };
   };
} LDKBech32Error;

/**
 * A serialized transaction, in (pointer, length) form.
 *
 * This type optionally owns its own memory, and thus the semantics around access change based on
 * the `data_is_owned` flag. If `data_is_owned` is set, you must call `Transaction_free` to free
 * the underlying buffer before the object goes out of scope. If `data_is_owned` is not set, any
 * access to the buffer after the scope in which the object was provided to you is invalid. eg,
 * access after you return from the call in which a `!data_is_owned` `Transaction` is provided to
 * you would be invalid.
 *
 * Note that, while it may change in the future, because transactions on the Rust side are stored
 * in a deserialized form, all `Transaction`s generated on the Rust side will have `data_is_owned`
 * set. Similarly, while it may change in the future, all `Transaction`s you pass to Rust may have
 * `data_is_owned` either set or unset at your discretion.
 */
typedef struct LDKTransaction {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKTransaction;

/**
 * A serialized witness.
 */
typedef struct LDKWitness {
   /**
    * The serialized transaction data.
    *
    * This is non-const for your convenience, an object passed to Rust is never written to.
    */
   uint8_t *data;
   /**
    * The length of the serialized transaction
    */
   uintptr_t datalen;
   /**
    * Whether the data pointed to by `data` should be freed or not.
    */
   bool data_is_owned;
} LDKWitness;

/**
 * A dynamically-allocated array of u8s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u8Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint8_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u8Z;

/**
 * An input to a transaction.
 *
 * This contains the witness, the scriptSig and the previous outpoint and represents a single
 * input to a transaction
 */
typedef struct LDKTxIn {
   /**
    * The witness which includes any signatures required to spend a segwit output.
    */
   struct LDKWitness witness;
   /**
    * The script_sig which includes signatures requires to spend a pre-segwit output (or a
    * P2SH-wrapped segwit output).
    */
   struct LDKCVec_u8Z script_sig;
   /**
    * The sequence number of the transaction input
    */
   uint32_t sequence;
   /**
    * The txid of the transaction being spent.
    */
   struct LDKThirtyTwoBytes previous_txid;
   /**
    * The output index of the transaction being spent.
    */
   uint32_t previous_vout;
} LDKTxIn;

/**
 * A transaction output including a scriptPubKey and value.
 * This type *does* own its own memory, so must be free'd appropriately.
 */
typedef struct LDKTxOut {
   /**
    * The script_pubkey in this output
    */
   struct LDKCVec_u8Z script_pubkey;
   /**
    * The value, in satoshis, of this output
    */
   uint64_t value;
} LDKTxOut;

/**
 * An enum which can either contain a u64 or not
 */
typedef enum LDKCOption_u64Z_Tag {
   /**
    * When we're in this state, this COption_u64Z contains a u64
    */
   LDKCOption_u64Z_Some,
   /**
    * When we're in this state, this COption_u64Z contains nothing
    */
   LDKCOption_u64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u64Z_Sentinel,
} LDKCOption_u64Z_Tag;

typedef struct LDKCOption_u64Z {
   LDKCOption_u64Z_Tag tag;
   union {
      struct {
         uint64_t some;
      };
   };
} LDKCOption_u64Z;



/**
 * Onion messages and payments can be sent and received to blinded paths, which serve to hide the
 * identity of the recipient.
 */
typedef struct MUST_USE_STRUCT LDKBlindedPath {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedPath *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedPath;

/**
 * A dynamically-allocated array of crate::lightning::blinded_path::BlindedPaths of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_BlindedPathZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKBlindedPath *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_BlindedPathZ;



/**
 * A `Refund` is a request to send an [`Bolt12Invoice`] without a preceding [`Offer`].
 *
 * Typically, after an invoice is paid, the recipient may publish a refund allowing the sender to
 * recoup their funds. A refund may be used more generally as an \"offer for money\", such as with a
 * bitcoin ATM.
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 * [`Offer`]: crate::offers::offer::Offer
 */
typedef struct MUST_USE_STRUCT LDKRefund {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRefund *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRefund;



/**
 * Error when parsing a bech32 encoded message using [`str::parse`].
 */
typedef struct MUST_USE_STRUCT LDKBolt12ParseError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt12ParseError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt12ParseError;

/**
 * The contents of CResult_RefundBolt12ParseErrorZ
 */
typedef union LDKCResult_RefundBolt12ParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRefund *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKBolt12ParseError *err;
} LDKCResult_RefundBolt12ParseErrorZPtr;

/**
 * A CResult_RefundBolt12ParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::offers::refund::Refund on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RefundBolt12ParseErrorZ {
   /**
    * The contents of this CResult_RefundBolt12ParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RefundBolt12ParseErrorZPtr contents;
   /**
    * Whether this CResult_RefundBolt12ParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RefundBolt12ParseErrorZ;

/**
 * Strategies available to retry payment path failures.
 */
typedef enum LDKRetry_Tag {
   /**
    * Max number of attempts to retry payment.
    *
    * Each attempt may be multiple HTLCs along multiple paths if the router decides to split up a
    * retry, and may retry multiple failed HTLCs at once if they failed around the same time and
    * were retried along a route from a single call to [`Router::find_route_with_id`].
    */
   LDKRetry_Attempts,
   /**
    * Time elapsed before abandoning retries for a payment. At least one attempt at payment is made;
    * see [`PaymentParameters::expiry_time`] to avoid any attempt at payment after a specific time.
    *
    * [`PaymentParameters::expiry_time`]: crate::routing::router::PaymentParameters::expiry_time
    */
   LDKRetry_Timeout,
   /**
    * Must be last for serialization purposes
    */
   LDKRetry_Sentinel,
} LDKRetry_Tag;

typedef struct MUST_USE_STRUCT LDKRetry {
   LDKRetry_Tag tag;
   union {
      struct {
         uint32_t attempts;
      };
      struct {
         uint64_t timeout;
      };
   };
} LDKRetry;

/**
 * An error in decoding a message or struct.
 */
typedef enum LDKDecodeError_Tag {
   /**
    * A version byte specified something we don't know how to handle.
    *
    * Includes unknown realm byte in an onion hop data packet.
    */
   LDKDecodeError_UnknownVersion,
   /**
    * Unknown feature mandating we fail to parse message (e.g., TLV with an even, unknown type)
    */
   LDKDecodeError_UnknownRequiredFeature,
   /**
    * Value was invalid.
    *
    * For example, a byte which was supposed to be a bool was something other than a 0
    * or 1, a public key/private key/signature was invalid, text wasn't UTF-8, TLV was
    * syntactically incorrect, etc.
    */
   LDKDecodeError_InvalidValue,
   /**
    * The buffer to be read was too short.
    */
   LDKDecodeError_ShortRead,
   /**
    * A length descriptor in the packet didn't describe the later data correctly.
    */
   LDKDecodeError_BadLengthDescriptor,
   /**
    * Error from [`std::io`].
    */
   LDKDecodeError_Io,
   /**
    * The message included zlib-compressed values, which we don't support.
    */
   LDKDecodeError_UnsupportedCompression,
   /**
    * Must be last for serialization purposes
    */
   LDKDecodeError_Sentinel,
} LDKDecodeError_Tag;

typedef struct MUST_USE_STRUCT LDKDecodeError {
   LDKDecodeError_Tag tag;
   union {
      struct {
         enum LDKIOError io;
      };
   };
} LDKDecodeError;

/**
 * The contents of CResult_RetryDecodeErrorZ
 */
typedef union LDKCResult_RetryDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRetry *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RetryDecodeErrorZPtr;

/**
 * A CResult_RetryDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::outbound_payment::Retry on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RetryDecodeErrorZ {
   /**
    * The contents of this CResult_RetryDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RetryDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RetryDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RetryDecodeErrorZ;



/**
 * A script pubkey for shutting down a channel as defined by [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
typedef struct MUST_USE_STRUCT LDKShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdownScript;

/**
 * Indicates an error on the client's part (usually some variant of attempting to use too-low or
 * too-high values)
 */
typedef enum LDKAPIError_Tag {
   /**
    * Indicates the API was wholly misused (see err for more). Cases where these can be returned
    * are documented, but generally indicates some precondition of a function was violated.
    */
   LDKAPIError_APIMisuseError,
   /**
    * Due to a high feerate, we were unable to complete the request.
    * For example, this may be returned if the feerate implies we cannot open a channel at the
    * requested value, but opening a larger channel would succeed.
    */
   LDKAPIError_FeeRateTooHigh,
   /**
    * A malformed Route was provided (eg overflowed value, node id mismatch, overly-looped route,
    * too-many-hops, etc).
    */
   LDKAPIError_InvalidRoute,
   /**
    * We were unable to complete the request as the Channel required to do so is unable to
    * complete the request (or was not found). This can take many forms, including disconnected
    * peer, channel at capacity, channel shutting down, etc.
    */
   LDKAPIError_ChannelUnavailable,
   /**
    * An attempt to call [`chain::Watch::watch_channel`]/[`chain::Watch::update_channel`]
    * returned a [`ChannelMonitorUpdateStatus::InProgress`] indicating the persistence of a
    * monitor update is awaiting async resolution. Once it resolves the attempted action should
    * complete automatically.
    *
    * [`chain::Watch::watch_channel`]: crate::chain::Watch::watch_channel
    * [`chain::Watch::update_channel`]: crate::chain::Watch::update_channel
    * [`ChannelMonitorUpdateStatus::InProgress`]: crate::chain::ChannelMonitorUpdateStatus::InProgress
    */
   LDKAPIError_MonitorUpdateInProgress,
   /**
    * [`SignerProvider::get_shutdown_scriptpubkey`] returned a shutdown scriptpubkey incompatible
    * with the channel counterparty as negotiated in [`InitFeatures`].
    *
    * Using a SegWit v0 script should resolve this issue. If you cannot, you won't be able to open
    * a channel or cooperatively close one with this peer (and will have to force-close instead).
    *
    * [`SignerProvider::get_shutdown_scriptpubkey`]: crate::sign::SignerProvider::get_shutdown_scriptpubkey
    * [`InitFeatures`]: crate::ln::features::InitFeatures
    */
   LDKAPIError_IncompatibleShutdownScript,
   /**
    * Must be last for serialization purposes
    */
   LDKAPIError_Sentinel,
} LDKAPIError_Tag;

typedef struct LDKAPIError_LDKAPIMisuseError_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKAPIMisuseError_Body;

typedef struct LDKAPIError_LDKFeeRateTooHigh_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
   /**
    * The feerate which was too high.
    */
   uint32_t feerate;
} LDKAPIError_LDKFeeRateTooHigh_Body;

typedef struct LDKAPIError_LDKInvalidRoute_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKInvalidRoute_Body;

typedef struct LDKAPIError_LDKChannelUnavailable_Body {
   /**
    * A human-readable error message
    */
   struct LDKStr err;
} LDKAPIError_LDKChannelUnavailable_Body;

typedef struct LDKAPIError_LDKIncompatibleShutdownScript_Body {
   /**
    * The incompatible shutdown script.
    */
   struct LDKShutdownScript script;
} LDKAPIError_LDKIncompatibleShutdownScript_Body;

typedef struct MUST_USE_STRUCT LDKAPIError {
   LDKAPIError_Tag tag;
   union {
      LDKAPIError_LDKAPIMisuseError_Body api_misuse_error;
      LDKAPIError_LDKFeeRateTooHigh_Body fee_rate_too_high;
      LDKAPIError_LDKInvalidRoute_Body invalid_route;
      LDKAPIError_LDKChannelUnavailable_Body channel_unavailable;
      LDKAPIError_LDKIncompatibleShutdownScript_Body incompatible_shutdown_script;
   };
} LDKAPIError;

/**
 * The contents of CResult_NoneAPIErrorZ
 */
typedef union LDKCResult_NoneAPIErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_NoneAPIErrorZPtr;

/**
 * A CResult_NoneAPIErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneAPIErrorZ {
   /**
    * The contents of this CResult_NoneAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneAPIErrorZPtr contents;
   /**
    * Whether this CResult_NoneAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneAPIErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CResult_NoneAPIErrorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CResult_NoneAPIErrorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCResult_NoneAPIErrorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CResult_NoneAPIErrorZZ;

/**
 * A dynamically-allocated array of crate::lightning::util::errors::APIErrors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_APIErrorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKAPIError *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_APIErrorZ;

/**
 * An enum which can either contain a crate::c_types::ThirtyTwoBytes or not
 */
typedef enum LDKCOption_ThirtyTwoBytesZ_Tag {
   /**
    * When we're in this state, this COption_ThirtyTwoBytesZ contains a crate::c_types::ThirtyTwoBytes
    */
   LDKCOption_ThirtyTwoBytesZ_Some,
   /**
    * When we're in this state, this COption_ThirtyTwoBytesZ contains nothing
    */
   LDKCOption_ThirtyTwoBytesZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ThirtyTwoBytesZ_Sentinel,
} LDKCOption_ThirtyTwoBytesZ_Tag;

typedef struct LDKCOption_ThirtyTwoBytesZ {
   LDKCOption_ThirtyTwoBytesZ_Tag tag;
   union {
      struct {
         struct LDKThirtyTwoBytes some;
      };
   };
} LDKCOption_ThirtyTwoBytesZ;

/**
 * An enum which can either contain a crate::c_types::derived::CVec_u8Z or not
 */
typedef enum LDKCOption_CVec_u8ZZ_Tag {
   /**
    * When we're in this state, this COption_CVec_u8ZZ contains a crate::c_types::derived::CVec_u8Z
    */
   LDKCOption_CVec_u8ZZ_Some,
   /**
    * When we're in this state, this COption_CVec_u8ZZ contains nothing
    */
   LDKCOption_CVec_u8ZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CVec_u8ZZ_Sentinel,
} LDKCOption_CVec_u8ZZ_Tag;

typedef struct LDKCOption_CVec_u8ZZ {
   LDKCOption_CVec_u8ZZ_Tag tag;
   union {
      struct {
         struct LDKCVec_u8Z some;
      };
   };
} LDKCOption_CVec_u8ZZ;



/**
 * Information which is provided, encrypted, to the payment recipient when sending HTLCs.
 *
 * This should generally be constructed with data communicated to us from the recipient (via a
 * BOLT11 or BOLT12 invoice).
 */
typedef struct MUST_USE_STRUCT LDKRecipientOnionFields {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRecipientOnionFields *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRecipientOnionFields;

/**
 * The contents of CResult_RecipientOnionFieldsDecodeErrorZ
 */
typedef union LDKCResult_RecipientOnionFieldsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecipientOnionFields *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RecipientOnionFieldsDecodeErrorZPtr;

/**
 * A CResult_RecipientOnionFieldsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecipientOnionFieldsDecodeErrorZ {
   /**
    * The contents of this CResult_RecipientOnionFieldsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecipientOnionFieldsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RecipientOnionFieldsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecipientOnionFieldsDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u64CVec_u8ZZ {
   /**
    * The element at position 0
    */
   uint64_t a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u64CVec_u8ZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u64CVec_u8ZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u64CVec_u8ZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u64CVec_u8ZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u64CVec_u8ZZZ;

/**
 * The contents of CResult_RecipientOnionFieldsNoneZ
 */
typedef union LDKCResult_RecipientOnionFieldsNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecipientOnionFields *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_RecipientOnionFieldsNoneZPtr;

/**
 * A CResult_RecipientOnionFieldsNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::outbound_payment::RecipientOnionFields on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecipientOnionFieldsNoneZ {
   /**
    * The contents of this CResult_RecipientOnionFieldsNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecipientOnionFieldsNoneZPtr contents;
   /**
    * Whether this CResult_RecipientOnionFieldsNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecipientOnionFieldsNoneZ;

/**
 * A dynamically-allocated array of crate::c_types::ThirtyTwoBytess of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ThirtyTwoBytesZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKThirtyTwoBytes *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ThirtyTwoBytesZ;

/**
 * An enum which can either contain a crate::c_types::derived::CVec_ThirtyTwoBytesZ or not
 */
typedef enum LDKCOption_CVec_ThirtyTwoBytesZZ_Tag {
   /**
    * When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains a crate::c_types::derived::CVec_ThirtyTwoBytesZ
    */
   LDKCOption_CVec_ThirtyTwoBytesZZ_Some,
   /**
    * When we're in this state, this COption_CVec_ThirtyTwoBytesZZ contains nothing
    */
   LDKCOption_CVec_ThirtyTwoBytesZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CVec_ThirtyTwoBytesZZ_Sentinel,
} LDKCOption_CVec_ThirtyTwoBytesZZ_Tag;

typedef struct LDKCOption_CVec_ThirtyTwoBytesZZ {
   LDKCOption_CVec_ThirtyTwoBytesZZ_Tag tag;
   union {
      struct {
         struct LDKCVec_ThirtyTwoBytesZ some;
      };
   };
} LDKCOption_CVec_ThirtyTwoBytesZZ;

/**
 * The contents of CResult_ThirtyTwoBytesNoneZ
 */
typedef union LDKCResult_ThirtyTwoBytesNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_ThirtyTwoBytesNoneZPtr;

/**
 * A CResult_ThirtyTwoBytesNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ThirtyTwoBytesNoneZ {
   /**
    * The contents of this CResult_ThirtyTwoBytesNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ThirtyTwoBytesNoneZPtr contents;
   /**
    * Whether this CResult_ThirtyTwoBytesNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ThirtyTwoBytesNoneZ;



/**
 * Information needed to route a payment across a [`BlindedPath`].
 */
typedef struct MUST_USE_STRUCT LDKBlindedPayInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedPayInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedPayInfo;

/**
 * The contents of CResult_BlindedPayInfoDecodeErrorZ
 */
typedef union LDKCResult_BlindedPayInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedPayInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedPayInfoDecodeErrorZPtr;

/**
 * A CResult_BlindedPayInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::offers::invoice::BlindedPayInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedPayInfoDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedPayInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedPayInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedPayInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedPayInfoDecodeErrorZ;



/**
 * Information about a spendable output to a P2WSH script.
 *
 * See [`SpendableOutputDescriptor::DelayedPaymentOutput`] for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKDelayedPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDelayedPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDelayedPaymentOutputDescriptor;

/**
 * The contents of CResult_DelayedPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDelayedPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::sign::DelayedPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_DelayedPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ;



/**
 * Information about a spendable output to our \"payment key\".
 *
 * See [`SpendableOutputDescriptor::StaticPaymentOutput`] for more details on how to spend this.
 */
typedef struct MUST_USE_STRUCT LDKStaticPaymentOutputDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeStaticPaymentOutputDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKStaticPaymentOutputDescriptor;

/**
 * The contents of CResult_StaticPaymentOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStaticPaymentOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::sign::StaticPaymentOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_StaticPaymentOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_StaticPaymentOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ;



/**
 * A reference to a transaction output.
 *
 * Differs from bitcoin::blockdata::transaction::OutPoint as the index is a u16 instead of u32
 * due to LN's restrictions on index values. Should reduce (possibly) unsafe conversions this way.
 */
typedef struct MUST_USE_STRUCT LDKOutPoint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOutPoint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOutPoint;

/**
 * Describes the necessary information to spend a spendable output.
 *
 * When on-chain outputs are created by LDK (which our counterparty is not able to claim at any
 * point in the future) a [`SpendableOutputs`] event is generated which you must track and be able
 * to spend on-chain. The information needed to do this is provided in this enum, including the
 * outpoint describing which `txid` and output `index` is available, the full output which exists
 * at that `txid`/`index`, and any keys or other information required to sign.
 *
 * [`SpendableOutputs`]: crate::events::Event::SpendableOutputs
 */
typedef enum LDKSpendableOutputDescriptor_Tag {
   /**
    * An output to a script which was provided via [`SignerProvider`] directly, either from
    * [`get_destination_script`] or [`get_shutdown_scriptpubkey`], thus you should already
    * know how to spend it. No secret keys are provided as LDK was never given any key.
    * These may include outputs from a transaction punishing our counterparty or claiming an HTLC
    * on-chain using the payment preimage or after it has timed out.
    *
    * [`get_shutdown_scriptpubkey`]: SignerProvider::get_shutdown_scriptpubkey
    * [`get_destination_script`]: SignerProvider::get_shutdown_scriptpubkey
    */
   LDKSpendableOutputDescriptor_StaticOutput,
   /**
    * An output to a P2WSH script which can be spent with a single signature after an `OP_CSV`
    * delay.
    *
    * The witness in the spending input should be:
    * ```bitcoin
    * <BIP 143 signature> <empty vector> (MINIMALIF standard rule) <provided witnessScript>
    * ```
    *
    * Note that the `nSequence` field in the spending input must be set to
    * [`DelayedPaymentOutputDescriptor::to_self_delay`] (which means the transaction is not
    * broadcastable until at least [`DelayedPaymentOutputDescriptor::to_self_delay`] blocks after
    * the outpoint confirms, see [BIP
    * 68](https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki)). Also note that LDK
    * won't generate a [`SpendableOutputDescriptor`] until the corresponding block height
    * is reached.
    *
    * These are generally the result of a \"revocable\" output to us, spendable only by us unless
    * it is an output from an old state which we broadcast (which should never happen).
    *
    * To derive the delayed payment key which is used to sign this input, you must pass the
    * holder [`InMemorySigner::delayed_payment_base_key`] (i.e., the private key which corresponds to the
    * [`ChannelPublicKeys::delayed_payment_basepoint`] in [`ChannelSigner::pubkeys`]) and the provided
    * [`DelayedPaymentOutputDescriptor::per_commitment_point`] to [`chan_utils::derive_private_key`]. The public key can be
    * generated without the secret key using [`chan_utils::derive_public_key`] and only the
    * [`ChannelPublicKeys::delayed_payment_basepoint`] which appears in [`ChannelSigner::pubkeys`].
    *
    * To derive the [`DelayedPaymentOutputDescriptor::revocation_pubkey`] provided here (which is
    * used in the witness script generation), you must pass the counterparty
    * [`ChannelPublicKeys::revocation_basepoint`] (which appears in the call to
    * [`ChannelSigner::provide_channel_parameters`]) and the provided
    * [`DelayedPaymentOutputDescriptor::per_commitment_point`] to
    * [`chan_utils::derive_public_revocation_key`].
    *
    * The witness script which is hashed and included in the output `script_pubkey` may be
    * regenerated by passing the [`DelayedPaymentOutputDescriptor::revocation_pubkey`] (derived
    * as explained above), our delayed payment pubkey (derived as explained above), and the
    * [`DelayedPaymentOutputDescriptor::to_self_delay`] contained here to
    * [`chan_utils::get_revokeable_redeemscript`].
    */
   LDKSpendableOutputDescriptor_DelayedPaymentOutput,
   /**
    * An output spendable exclusively by our payment key (i.e., the private key that corresponds
    * to the `payment_point` in [`ChannelSigner::pubkeys`]). The output type depends on the
    * channel type negotiated.
    *
    * On an anchor outputs channel, the witness in the spending input is:
    * ```bitcoin
    * <BIP 143 signature> <witness script>
    * ```
    *
    * Otherwise, it is:
    * ```bitcoin
    * <BIP 143 signature> <payment key>
    * ```
    *
    * These are generally the result of our counterparty having broadcast the current state,
    * allowing us to claim the non-HTLC-encumbered outputs immediately, or after one confirmation
    * in the case of anchor outputs channels.
    */
   LDKSpendableOutputDescriptor_StaticPaymentOutput,
   /**
    * Must be last for serialization purposes
    */
   LDKSpendableOutputDescriptor_Sentinel,
} LDKSpendableOutputDescriptor_Tag;

typedef struct LDKSpendableOutputDescriptor_LDKStaticOutput_Body {
   /**
    * The outpoint which is spendable.
    */
   struct LDKOutPoint outpoint;
   /**
    * The output which is referenced by the given outpoint.
    */
   struct LDKTxOut output;
} LDKSpendableOutputDescriptor_LDKStaticOutput_Body;

typedef struct MUST_USE_STRUCT LDKSpendableOutputDescriptor {
   LDKSpendableOutputDescriptor_Tag tag;
   union {
      LDKSpendableOutputDescriptor_LDKStaticOutput_Body static_output;
      struct {
         struct LDKDelayedPaymentOutputDescriptor delayed_payment_output;
      };
      struct {
         struct LDKStaticPaymentOutputDescriptor static_payment_output;
      };
   };
} LDKSpendableOutputDescriptor;

/**
 * The contents of CResult_SpendableOutputDescriptorDecodeErrorZ
 */
typedef union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSpendableOutputDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr;

/**
 * A CResult_SpendableOutputDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::sign::SpendableOutputDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_SpendableOutputDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SpendableOutputDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SpendableOutputDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SpendableOutputDescriptorDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::sign::SpendableOutputDescriptors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SpendableOutputDescriptorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSpendableOutputDescriptor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SpendableOutputDescriptorZ;

/**
 * A dynamically-allocated array of crate::c_types::TxOuts of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TxOutZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTxOut *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TxOutZ;

/**
 * An enum which can either contain a u32 or not
 */
typedef enum LDKCOption_u32Z_Tag {
   /**
    * When we're in this state, this COption_u32Z contains a u32
    */
   LDKCOption_u32Z_Some,
   /**
    * When we're in this state, this COption_u32Z contains nothing
    */
   LDKCOption_u32Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u32Z_Sentinel,
} LDKCOption_u32Z_Tag;

typedef struct LDKCOption_u32Z {
   LDKCOption_u32Z_Tag tag;
   union {
      struct {
         uint32_t some;
      };
   };
} LDKCOption_u32Z;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_CVec_u8ZusizeZ {
   /**
    * The element at position 0
    */
   struct LDKCVec_u8Z a;
   /**
    * The element at position 1
    */
   uintptr_t b;
} LDKC2Tuple_CVec_u8ZusizeZ;

/**
 * The contents of CResult_C2Tuple_CVec_u8ZusizeZNoneZ
 */
typedef union LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_CVec_u8ZusizeZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZPtr;

/**
 * A CResult_C2Tuple_CVec_u8ZusizeZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_CVec_u8ZusizeZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_CVec_u8ZusizeZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_CVec_u8ZusizeZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ;

/**
 * The contents of CResult_NoneNoneZ
 */
typedef union LDKCResult_NoneNoneZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_NoneNoneZPtr;

/**
 * A CResult_NoneNoneZ represents the result of a fallible operation,
 * containing a () on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneNoneZ {
   /**
    * The contents of this CResult_NoneNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneNoneZPtr contents;
   /**
    * Whether this CResult_NoneNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneNoneZ;

/**
 * Represents a secp256k1 ECDSA signature serialized as two 32-byte numbers
 */
typedef struct LDKECDSASignature {
   /**
    * The bytes of the signature in "compact" form
    */
   uint8_t compact_form[64];
} LDKECDSASignature;

/**
 * A dynamically-allocated array of crate::c_types::ECDSASignatures of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ECDSASignatureZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKECDSASignature *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ECDSASignatureZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ {
   /**
    * The element at position 0
    */
   struct LDKECDSASignature a;
   /**
    * The element at position 1
    */
   struct LDKCVec_ECDSASignatureZ b;
} LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ;

/**
 * The contents of CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ
 */
typedef union LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr;

/**
 * A CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ;

/**
 * The contents of CResult_ECDSASignatureNoneZ
 */
typedef union LDKCResult_ECDSASignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKECDSASignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_ECDSASignatureNoneZPtr;

/**
 * A CResult_ECDSASignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::ECDSASignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ECDSASignatureNoneZ {
   /**
    * The contents of this CResult_ECDSASignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ECDSASignatureNoneZPtr contents;
   /**
    * Whether this CResult_ECDSASignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ECDSASignatureNoneZ;

/**
 * Represents a valid secp256k1 public key serialized in "compressed form" as a 33 byte array.
 */
typedef struct LDKPublicKey {
   /**
    * The bytes of the public key
    */
   uint8_t compressed_form[33];
} LDKPublicKey;

/**
 * The contents of CResult_PublicKeyNoneZ
 */
typedef union LDKCResult_PublicKeyNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_PublicKeyNoneZPtr;

/**
 * A CResult_PublicKeyNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeyNoneZ {
   /**
    * The contents of this CResult_PublicKeyNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeyNoneZPtr contents;
   /**
    * Whether this CResult_PublicKeyNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeyNoneZ;

/**
 * An enum which can either contain a crate::c_types::BigEndianScalar or not
 */
typedef enum LDKCOption_BigEndianScalarZ_Tag {
   /**
    * When we're in this state, this COption_BigEndianScalarZ contains a crate::c_types::BigEndianScalar
    */
   LDKCOption_BigEndianScalarZ_Some,
   /**
    * When we're in this state, this COption_BigEndianScalarZ contains nothing
    */
   LDKCOption_BigEndianScalarZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_BigEndianScalarZ_Sentinel,
} LDKCOption_BigEndianScalarZ_Tag;

typedef struct LDKCOption_BigEndianScalarZ {
   LDKCOption_BigEndianScalarZ_Tag tag;
   union {
      struct {
         struct LDKBigEndianScalar some;
      };
   };
} LDKCOption_BigEndianScalarZ;

/**
 * Integer in the range `0..32`
 */
typedef struct LDKU5 {
   uint8_t _0;
} LDKU5;

/**
 * A dynamically-allocated array of crate::c_types::U5s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_U5Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKU5 *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_U5Z;

/**
 * Represents a secp256k1 signature serialized as two 32-byte numbers as well as a tag which
 * allows recovering the exact public key which created the signature given the message.
 */
typedef struct LDKRecoverableSignature {
   /**
    * The bytes of the signature in "compact" form plus a "Recovery ID" which allows for
    * recovery.
    */
   uint8_t serialized_form[68];
} LDKRecoverableSignature;

/**
 * The contents of CResult_RecoverableSignatureNoneZ
 */
typedef union LDKCResult_RecoverableSignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRecoverableSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_RecoverableSignatureNoneZPtr;

/**
 * A CResult_RecoverableSignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::RecoverableSignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RecoverableSignatureNoneZ {
   /**
    * The contents of this CResult_RecoverableSignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RecoverableSignatureNoneZPtr contents;
   /**
    * Whether this CResult_RecoverableSignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RecoverableSignatureNoneZ;

/**
 * Represents a secp256k1 Schnorr signature serialized as two 32-byte numbers
 */
typedef struct LDKSchnorrSignature {
   /**
    * The bytes of the signature as two 32-byte numbers
    */
   uint8_t compact_form[64];
} LDKSchnorrSignature;

/**
 * The contents of CResult_SchnorrSignatureNoneZ
 */
typedef union LDKCResult_SchnorrSignatureNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSchnorrSignature *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_SchnorrSignatureNoneZPtr;

/**
 * A CResult_SchnorrSignatureNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::SchnorrSignature on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SchnorrSignatureNoneZ {
   /**
    * The contents of this CResult_SchnorrSignatureNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SchnorrSignatureNoneZPtr contents;
   /**
    * Whether this CResult_SchnorrSignatureNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SchnorrSignatureNoneZ;



/**
 * This class tracks the per-transaction information needed to build a commitment transaction and will
 * actually build it and sign.  It is used for holder transactions that we sign only when needed
 * and for transactions we sign for the counterparty.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentTransaction;



/**
 * Information needed to build and sign a holder's commitment transaction.
 *
 * The transaction is only signed once we are ready to broadcast.
 */
typedef struct MUST_USE_STRUCT LDKHolderCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHolderCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHolderCommitmentTransaction;



/**
 * Information about an HTLC as it appears in a commitment transaction
 */
typedef struct MUST_USE_STRUCT LDKHTLCOutputInCommitment {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCOutputInCommitment *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCOutputInCommitment;



/**
 * A descriptor used to sign for a commitment transaction's HTLC output.
 */
typedef struct MUST_USE_STRUCT LDKHTLCDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCDescriptor;



/**
 * This class tracks the per-transaction information needed to build a closing transaction and will
 * actually build it and sign.
 *
 * This class can be used inside a signer implementation to generate a signature given the relevant
 * secret key.
 */
typedef struct MUST_USE_STRUCT LDKClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingTransaction;



/**
 * The unsigned part of a [`channel_announcement`] message.
 *
 * [`channel_announcement`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_announcement-message
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelAnnouncement;



/**
 * One counterparty's public keys which do not change over the life of a channel.
 */
typedef struct MUST_USE_STRUCT LDKChannelPublicKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelPublicKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelPublicKeys;



/**
 * Per-channel data used to build transactions in conjunction with the per-commitment data (CommitmentTransaction).
 * The fields are organized by holder/counterparty.
 *
 * Normally, this is converted to the broadcaster/countersignatory-organized DirectedChannelTransactionParameters
 * before use, via the as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTransactionParameters;

/**
 * A trait to handle Lightning channel key material without concretizing the channel type or
 * the signature mechanism.
 */
typedef struct LDKChannelSigner {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the per-commitment point for a specific commitment number
    *
    * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
    */
   struct LDKPublicKey (*get_per_commitment_point)(const void *this_arg, uint64_t idx);
   /**
    * Gets the commitment secret for a specific commitment number as part of the revocation process
    *
    * An external signer implementation should error here if the commitment was already signed
    * and should refuse to sign it in the future.
    *
    * May be called more than once for the same index.
    *
    * Note that the commitment number starts at `(1 << 48) - 1` and counts backwards.
    */
   struct LDKThirtyTwoBytes (*release_commitment_secret)(const void *this_arg, uint64_t idx);
   /**
    * Validate the counterparty's signatures on the holder commitment transaction and HTLCs.
    *
    * This is required in order for the signer to make sure that releasing a commitment
    * secret won't leave us without a broadcastable holder transaction.
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * Note that all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_NoneNoneZ (*validate_holder_commitment)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR holder_tx, struct LDKCVec_ThirtyTwoBytesZ preimages);
   /**
    * Returns the holder's channel public keys and basepoints.
    */
   struct LDKChannelPublicKeys pubkeys;
   /**
    * Fill in the pubkeys field as a reference to it will be given to Rust after this returns
    * Note that this takes a pointer to this object, not the this_ptr like other methods do
    * This function pointer may be NULL if pubkeys is filled in when this object is created and never needs updating.
    */
   void (*set_pubkeys)(const struct LDKChannelSigner*NONNULL_PTR );
   /**
    * Returns an arbitrary identifier describing the set of keys which are provided back to you in
    * some [`SpendableOutputDescriptor`] types. This should be sufficient to identify this
    * [`EcdsaChannelSigner`] object uniquely and lookup or re-derive its keys.
    */
   struct LDKThirtyTwoBytes (*channel_keys_id)(const void *this_arg);
   /**
    * Set the counterparty static channel data, including basepoints,
    * `counterparty_selected`/`holder_selected_contest_delay` and funding outpoint.
    *
    * This data is static, and will never change for a channel once set. For a given [`ChannelSigner`]
    * instance, LDK will call this method exactly once - either immediately after construction
    * (not including if done via [`SignerProvider::read_chan_signer`]) or when the funding
    * information has been generated.
    *
    * channel_parameters.is_populated() MUST be true.
    */
   void (*provide_channel_parameters)(void *this_arg, const struct LDKChannelTransactionParameters *NONNULL_PTR channel_parameters);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelSigner;

/**
 * A trait to sign Lightning channel transactions as described in
 * [BOLT 3](https://github.com/lightning/bolts/blob/master/03-transactions.md).
 *
 * Signing services could be implemented on a hardware wallet and should implement signing
 * policies in order to be secure. Please refer to the [VLS Policy
 * Controls](https://gitlab.com/lightning-signer/validating-lightning-signer/-/blob/main/docs/policy-controls.md)
 * for an example of such policies.
 */
typedef struct LDKEcdsaChannelSigner {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Create a signature for a counterparty's commitment transaction and associated HTLC transactions.
    *
    * Note that if signing fails or is rejected, the channel will be force-closed.
    *
    * Policy checks should be implemented in this function, including checking the amount
    * sent to us and checking the HTLCs.
    *
    * The preimages of outgoing HTLCs that were fulfilled since the last commitment are provided.
    * A validating signer should ensure that an HTLC output is removed only when the matching
    * preimage is provided, or when the value to holder is restored.
    *
    * Note that all the relevant preimages will be provided, but there may also be additional
    * irrelevant or duplicate preimages.
    */
   struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ (*sign_counterparty_commitment)(const void *this_arg, const struct LDKCommitmentTransaction *NONNULL_PTR commitment_tx, struct LDKCVec_ThirtyTwoBytesZ preimages);
   /**
    * Validate the counterparty's revocation.
    *
    * This is required in order for the signer to make sure that the state has moved
    * forward and it is safe to sign the next counterparty commitment.
    */
   struct LDKCResult_NoneNoneZ (*validate_counterparty_revocation)(const void *this_arg, uint64_t idx, const uint8_t (*secret)[32]);
   /**
    * Creates a signature for a holder's commitment transaction and its claiming HTLC transactions.
    *
    * This will be called
    * - with a non-revoked `commitment_tx`.
    * - with the latest `commitment_tx` when we initiate a force-close.
    * - with the previous `commitment_tx`, just to get claiming HTLC
    *   signatures, if we are reacting to a [`ChannelMonitor`]
    *   [replica](https://github.com/lightningdevkit/rust-lightning/blob/main/GLOSSARY.md#monitor-replicas)
    *   that decided to broadcast before it had been updated to the latest `commitment_tx`.
    *
    * This may be called multiple times for the same transaction.
    *
    * An external signer implementation should check that the commitment has not been revoked.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    */
   struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ (*sign_holder_commitment_and_htlcs)(const void *this_arg, const struct LDKHolderCommitmentTransaction *NONNULL_PTR commitment_tx);
   /**
    * Create a signature for the given input in a transaction spending an HTLC transaction output
    * or a commitment transaction `to_local` output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * Amount is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * `per_commitment_key` is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder `revocation_secret` to do
    * so).
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_justice_revoked_output)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32]);
   /**
    * Create a signature for the given input in a transaction spending a commitment transaction
    * HTLC output when our counterparty broadcasts an old state.
    *
    * A justice transaction may claim multiple outputs at the same time if timelocks are
    * similar, but only a signature for the input at index `input` should be signed for here.
    * It may be called multiple times for same output(s) if a fee-bump is needed with regards
    * to an upcoming timelock expiration.
    *
    * `amount` is the value of the output spent by this input, committed to in the BIP 143
    * signature.
    *
    * `per_commitment_key` is revocation secret which was provided by our counterparty when they
    * revoked the state which they eventually broadcast. It's not a _holder_ secret key and does
    * not allow the spending of any funds by itself (you need our holder revocation_secret to do
    * so).
    *
    * `htlc` holds HTLC elements (hash, timelock), thus changing the format of the witness script
    * (which is committed to in the BIP 143 signatures).
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_justice_revoked_htlc)(const void *this_arg, struct LDKTransaction justice_tx, uintptr_t input, uint64_t amount, const uint8_t (*per_commitment_key)[32], const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Computes the signature for a commitment transaction's HTLC output used as an input within
    * `htlc_tx`, which spends the commitment transaction at index `input`. The signature returned
    * must be be computed using [`EcdsaSighashType::All`]. Note that this should only be used to
    * sign HTLC transactions from channels supporting anchor outputs after all additional
    * inputs/outputs have been added to the transaction.
    *
    * [`EcdsaSighashType::All`]: bitcoin::blockdata::transaction::EcdsaSighashType::All
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_holder_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, const struct LDKHTLCDescriptor *NONNULL_PTR htlc_descriptor);
   /**
    * Create a signature for a claiming transaction for a HTLC output on a counterparty's commitment
    * transaction, either offered or received.
    *
    * Such a transaction may claim multiples offered outputs at same time if we know the
    * preimage for each when we create it, but only the input at index `input` should be
    * signed for here. It may be called multiple times for same output(s) if a fee-bump is
    * needed with regards to an upcoming timelock expiration.
    *
    * `witness_script` is either an offered or received script as defined in BOLT3 for HTLC
    * outputs.
    *
    * `amount` is value of the output spent by this input, committed to in the BIP 143 signature.
    *
    * `per_commitment_point` is the dynamic point corresponding to the channel state
    * detected onchain. It has been generated by our counterparty and is used to derive
    * channel state keys, which are then included in the witness script and committed to in the
    * BIP 143 signature.
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_counterparty_htlc_transaction)(const void *this_arg, struct LDKTransaction htlc_tx, uintptr_t input, uint64_t amount, struct LDKPublicKey per_commitment_point, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc);
   /**
    * Create a signature for a (proposed) closing transaction.
    *
    * Note that, due to rounding, there may be one \"missing\" satoshi, and either party may have
    * chosen to forgo their output as dust.
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_closing_transaction)(const void *this_arg, const struct LDKClosingTransaction *NONNULL_PTR closing_tx);
   /**
    * Computes the signature for a commitment transaction's anchor output used as an
    * input within `anchor_tx`, which spends the commitment transaction, at index `input`.
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_holder_anchor_input)(const void *this_arg, struct LDKTransaction anchor_tx, uintptr_t input);
   /**
    * Signs a channel announcement message with our funding key proving it comes from one of the
    * channel participants.
    *
    * Channel announcements also require a signature from each node's network key. Our node
    * signature is computed through [`NodeSigner::sign_gossip_message`].
    *
    * Note that if this fails or is rejected, the channel will not be publicly announced and
    * our counterparty may (though likely will not) close the channel on us for violating the
    * protocol.
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_channel_announcement_with_funding_key)(const void *this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Implementation of ChannelSigner for this object.
    */
   struct LDKChannelSigner ChannelSigner;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEcdsaChannelSigner;

/**
 * A writeable signer.
 *
 * There will always be two instances of a signer per channel, one occupied by the
 * [`ChannelManager`] and another by the channel's [`ChannelMonitor`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
 */
typedef struct LDKWriteableEcdsaChannelSigner {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of EcdsaChannelSigner for this object.
    */
   struct LDKEcdsaChannelSigner EcdsaChannelSigner;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this WriteableEcdsaChannelSigner has been cloned into a duplicate object.
    * The new WriteableEcdsaChannelSigner is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKWriteableEcdsaChannelSigner *NONNULL_PTR new_WriteableEcdsaChannelSigner);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWriteableEcdsaChannelSigner;

/**
 * The contents of CResult_WriteableEcdsaChannelSignerDecodeErrorZ
 */
typedef union LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKWriteableEcdsaChannelSigner *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZPtr;

/**
 * A CResult_WriteableEcdsaChannelSignerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::sign::WriteableEcdsaChannelSigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ {
   /**
    * The contents of this CResult_WriteableEcdsaChannelSignerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_WriteableEcdsaChannelSignerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ;

/**
 * The contents of CResult_CVec_u8ZNoneZ
 */
typedef union LDKCResult_CVec_u8ZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_u8ZNoneZPtr;

/**
 * A CResult_CVec_u8ZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZNoneZ {
   /**
    * The contents of this CResult_CVec_u8ZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZNoneZ;

/**
 * The contents of CResult_ShutdownScriptNoneZ
 */
typedef union LDKCResult_ShutdownScriptNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_ShutdownScriptNoneZPtr;

/**
 * A CResult_ShutdownScriptNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptNoneZ {
   /**
    * The contents of this CResult_ShutdownScriptNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptNoneZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptNoneZ;

/**
 * An enum which can either contain a u16 or not
 */
typedef enum LDKCOption_u16Z_Tag {
   /**
    * When we're in this state, this COption_u16Z contains a u16
    */
   LDKCOption_u16Z_Some,
   /**
    * When we're in this state, this COption_u16Z contains nothing
    */
   LDKCOption_u16Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_u16Z_Sentinel,
} LDKCOption_u16Z_Tag;

typedef struct LDKCOption_u16Z {
   LDKCOption_u16Z_Tag tag;
   union {
      struct {
         uint16_t some;
      };
   };
} LDKCOption_u16Z;

/**
 * An enum which can either contain a bool or not
 */
typedef enum LDKCOption_boolZ_Tag {
   /**
    * When we're in this state, this COption_boolZ contains a bool
    */
   LDKCOption_boolZ_Some,
   /**
    * When we're in this state, this COption_boolZ contains nothing
    */
   LDKCOption_boolZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_boolZ_Sentinel,
} LDKCOption_boolZ_Tag;

typedef struct LDKCOption_boolZ {
   LDKCOption_boolZ_Tag tag;
   union {
      struct {
         bool some;
      };
   };
} LDKCOption_boolZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::CVec_u8Zs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CVec_u8ZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCVec_u8Z *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CVec_u8ZZ;

/**
 * The contents of CResult_CVec_CVec_u8ZZNoneZ
 */
typedef union LDKCResult_CVec_CVec_u8ZZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_CVec_u8ZZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_CVec_u8ZZNoneZPtr;

/**
 * A CResult_CVec_CVec_u8ZZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_CVec_u8ZZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_CVec_u8ZZNoneZ {
   /**
    * The contents of this CResult_CVec_CVec_u8ZZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_CVec_u8ZZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_CVec_u8ZZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_CVec_u8ZZNoneZ;



/**
 * A simple implementation of [`WriteableEcdsaChannelSigner`] that just keeps the private keys in memory.
 *
 * This implementation performs no policy checks and is insufficient by itself as
 * a secure external signer.
 */
typedef struct MUST_USE_STRUCT LDKInMemorySigner {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInMemorySigner *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInMemorySigner;

/**
 * The contents of CResult_InMemorySignerDecodeErrorZ
 */
typedef union LDKCResult_InMemorySignerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInMemorySigner *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InMemorySignerDecodeErrorZPtr;

/**
 * A CResult_InMemorySignerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::sign::InMemorySigner on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InMemorySignerDecodeErrorZ {
   /**
    * The contents of this CResult_InMemorySignerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InMemorySignerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InMemorySignerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InMemorySignerDecodeErrorZ;

/**
 * The contents of CResult_TransactionNoneZ
 */
typedef union LDKCResult_TransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionNoneZPtr;

/**
 * A CResult_TransactionNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::Transaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionNoneZ {
   /**
    * The contents of this CResult_TransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionNoneZPtr contents;
   /**
    * Whether this CResult_TransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionNoneZ;



/**
 * Represents the compressed public key of a node
 */
typedef struct MUST_USE_STRUCT LDKNodeId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeId;



/**
 * Proposed use of a channel passed as a parameter to [`ScoreLookUp::channel_penalty_msat`].
 */
typedef struct MUST_USE_STRUCT LDKChannelUsage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUsage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUsage;



/**
 * Parameters for configuring [`ProbabilisticScorer`].
 *
 * Used to configure base, liquidity, and amount penalties, the sum of which comprises the channel
 * penalty (i.e., the amount in msats willing to be paid to avoid routing through the channel).
 *
 * The penalty applied to any channel by the [`ProbabilisticScorer`] is the sum of each of the
 * parameters here.
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScoringFeeParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScoringFeeParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScoringFeeParameters;

/**
 * An interface used to score payment channels for path finding.
 *
 * `ScoreLookUp` is used to determine the penalty for a given channel.
 *
 * Scoring is in terms of fees willing to be paid in order to avoid routing through a channel.
 */
typedef struct LDKScoreLookUp {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the fee in msats willing to be paid to avoid routing `send_amt_msat` through the
    * given channel in the direction from `source` to `target`.
    *
    * The channel's capacity (less any other MPP parts that are also being considered for use in
    * the same payment) is given by `capacity_msat`. It may be determined from various sources
    * such as a chain data, network gossip, or invoice hints. For invoice hints, a capacity near
    * [`u64::max_value`] is given to indicate sufficient capacity for the invoice's full amount.
    * Thus, implementations should be overflow-safe.
    */
   uint64_t (*channel_penalty_msat)(const void *this_arg, uint64_t short_channel_id, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, struct LDKChannelUsage usage, const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR score_params);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKScoreLookUp;



/**
 * A path in a [`Route`] to the payment recipient. Must always be at least length one.
 * If no [`Path::blinded_tail`] is present, then [`Path::hops`] length may be up to 19.
 */
typedef struct MUST_USE_STRUCT LDKPath {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePath *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPath;

/**
 * `ScoreUpdate` is used to update the scorer's internal state after a payment attempt.
 */
typedef struct LDKScoreUpdate {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles updating channel penalties after failing to route through a channel.
    */
   void (*payment_path_failed)(void *this_arg, const struct LDKPath *NONNULL_PTR path, uint64_t short_channel_id);
   /**
    * Handles updating channel penalties after successfully routing along a path.
    */
   void (*payment_path_successful)(void *this_arg, const struct LDKPath *NONNULL_PTR path);
   /**
    * Handles updating channel penalties after a probe over the given path failed.
    */
   void (*probe_failed)(void *this_arg, const struct LDKPath *NONNULL_PTR path, uint64_t short_channel_id);
   /**
    * Handles updating channel penalties after a probe over the given path succeeded.
    */
   void (*probe_successful)(void *this_arg, const struct LDKPath *NONNULL_PTR path);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKScoreUpdate;

/**
 * A scorer that is accessed under a lock.
 *
 * Needed so that calls to [`ScoreLookUp::channel_penalty_msat`] in [`find_route`] can be made while
 * having shared ownership of a scorer but without requiring internal locking in [`ScoreUpdate`]
 * implementations. Internal locking would be detrimental to route finding performance and could
 * result in [`ScoreLookUp::channel_penalty_msat`] returning a different value for the same channel.
 *
 * [`find_route`]: crate::routing::router::find_route
 */
typedef struct LDKLockableScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns read locked scorer.
    */
   struct LDKScoreLookUp (*read_lock)(const void *this_arg);
   /**
    * Returns write locked scorer.
    */
   struct LDKScoreUpdate (*write_lock)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLockableScore;

/**
 * Refers to a scorer that is accessible under lock and also writeable to disk
 *
 * We need this trait to be able to pass in a scorer to `lightning-background-processor` that will enable us to
 * use the Persister to persist it.
 */
typedef struct LDKWriteableScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of LockableScore for this object.
    */
   struct LDKLockableScore LockableScore;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWriteableScore;

/**
 * An enum which can either contain a crate::lightning::routing::scoring::WriteableScore or not
 */
typedef enum LDKCOption_WriteableScoreZ_Tag {
   /**
    * When we're in this state, this COption_WriteableScoreZ contains a crate::lightning::routing::scoring::WriteableScore
    */
   LDKCOption_WriteableScoreZ_Some,
   /**
    * When we're in this state, this COption_WriteableScoreZ contains nothing
    */
   LDKCOption_WriteableScoreZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_WriteableScoreZ_Sentinel,
} LDKCOption_WriteableScoreZ_Tag;

typedef struct LDKCOption_WriteableScoreZ {
   LDKCOption_WriteableScoreZ_Tag tag;
   union {
      struct {
         struct LDKWriteableScore some;
      };
   };
} LDKCOption_WriteableScoreZ;

/**
 * The contents of CResult_NoneIOErrorZ
 */
typedef union LDKCResult_NoneIOErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_NoneIOErrorZPtr;

/**
 * A CResult_NoneIOErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneIOErrorZ {
   /**
    * The contents of this CResult_NoneIOErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneIOErrorZPtr contents;
   /**
    * Whether this CResult_NoneIOErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneIOErrorZ;



/**
 * Details of a channel, as returned by [`ChannelManager::list_channels`] and [`ChannelManager::list_usable_channels`]
 */
typedef struct MUST_USE_STRUCT LDKChannelDetails {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDetails *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDetails;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::ChannelDetailss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelDetailsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelDetails *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelDetailsZ;



/**
 * A route directs a payment from the sender (us) to the recipient. If the recipient supports MPP,
 * it can take multiple paths. Each path is composed of one or more hops through the network.
 */
typedef struct MUST_USE_STRUCT LDKRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoute;



/**
 * An Err type for failure to process messages.
 */
typedef struct MUST_USE_STRUCT LDKLightningError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLightningError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLightningError;

/**
 * The contents of CResult_RouteLightningErrorZ
 */
typedef union LDKCResult_RouteLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_RouteLightningErrorZPtr;

/**
 * A CResult_RouteLightningErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteLightningErrorZ {
   /**
    * The contents of this CResult_RouteLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteLightningErrorZPtr contents;
   /**
    * Whether this CResult_RouteLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteLightningErrorZ;



/**
 * A data structure for tracking in-flight HTLCs. May be used during pathfinding to account for
 * in-use channel liquidity.
 */
typedef struct MUST_USE_STRUCT LDKInFlightHtlcs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInFlightHtlcs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInFlightHtlcs;

/**
 * The contents of CResult_InFlightHtlcsDecodeErrorZ
 */
typedef union LDKCResult_InFlightHtlcsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInFlightHtlcs *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InFlightHtlcsDecodeErrorZPtr;

/**
 * A CResult_InFlightHtlcsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::InFlightHtlcs on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InFlightHtlcsDecodeErrorZ {
   /**
    * The contents of this CResult_InFlightHtlcsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InFlightHtlcsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InFlightHtlcsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InFlightHtlcsDecodeErrorZ;



/**
 * A hop in a route, and additional metadata about it. \"Hop\" is defined as a node and the channel
 * that leads to it.
 */
typedef struct MUST_USE_STRUCT LDKRouteHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHop;

/**
 * The contents of CResult_RouteHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHopDecodeErrorZPtr;

/**
 * A CResult_RouteHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHopDecodeErrorZ;



/**
 * An encrypted payload and node id corresponding to a hop in a payment or onion message path, to
 * be encoded in the sender's onion packet. These hops cannot be identified by outside observers
 * and thus can be used to hide the identity of the recipient.
 */
typedef struct MUST_USE_STRUCT LDKBlindedHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedHop;

/**
 * A dynamically-allocated array of crate::lightning::blinded_path::BlindedHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_BlindedHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKBlindedHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_BlindedHopZ;



/**
 * The blinded portion of a [`Path`], if we're routing to a recipient who provided blinded paths in
 * their [`Bolt12Invoice`].
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 */
typedef struct MUST_USE_STRUCT LDKBlindedTail {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedTail *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedTail;

/**
 * The contents of CResult_BlindedTailDecodeErrorZ
 */
typedef union LDKCResult_BlindedTailDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedTail *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedTailDecodeErrorZPtr;

/**
 * A CResult_BlindedTailDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::BlindedTail on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedTailDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedTailDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedTailDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedTailDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedTailDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHopZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::Paths of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PathZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPath *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PathZ;

/**
 * The contents of CResult_RouteDecodeErrorZ
 */
typedef union LDKCResult_RouteDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteDecodeErrorZPtr;

/**
 * A CResult_RouteDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::Route on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteDecodeErrorZ {
   /**
    * The contents of this CResult_RouteDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteDecodeErrorZ;



/**
 * Parameters needed to find a [`Route`].
 *
 * Passed to [`find_route`] and [`build_route_from_hops`].
 */
typedef struct MUST_USE_STRUCT LDKRouteParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteParameters;

/**
 * The contents of CResult_RouteParametersDecodeErrorZ
 */
typedef union LDKCResult_RouteParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteParametersDecodeErrorZPtr;

/**
 * A CResult_RouteParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteParametersDecodeErrorZ {
   /**
    * The contents of this CResult_RouteParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteParametersDecodeErrorZ;

/**
 * A dynamically-allocated array of u64s of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_u64Z {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   uint64_t *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_u64Z;



/**
 * Information used to route a payment.
 */
typedef struct MUST_USE_STRUCT LDKPaymentParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePaymentParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPaymentParameters;

/**
 * The contents of CResult_PaymentParametersDecodeErrorZ
 */
typedef union LDKCResult_PaymentParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentParametersDecodeErrorZPtr;

/**
 * A CResult_PaymentParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::PaymentParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentParametersDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentParametersDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_BlindedPayInfoBlindedPathZ {
   /**
    * The element at position 0
    */
   struct LDKBlindedPayInfo a;
   /**
    * The element at position 1
    */
   struct LDKBlindedPath b;
} LDKC2Tuple_BlindedPayInfoBlindedPathZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_BlindedPayInfoBlindedPathZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ;



/**
 * A list of hops along a payment path terminating with a channel to the recipient.
 */
typedef struct MUST_USE_STRUCT LDKRouteHint {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHint *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHint;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintZ;



/**
 * A channel descriptor for a hop along a payment path.
 */
typedef struct MUST_USE_STRUCT LDKRouteHintHop {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRouteHintHop *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRouteHintHop;

/**
 * A dynamically-allocated array of crate::lightning::routing::router::RouteHintHops of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RouteHintHopZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRouteHintHop *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RouteHintHopZ;

/**
 * The contents of CResult_RouteHintDecodeErrorZ
 */
typedef union LDKCResult_RouteHintDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintDecodeErrorZPtr;

/**
 * A CResult_RouteHintDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintDecodeErrorZ;

/**
 * The contents of CResult_RouteHintHopDecodeErrorZ
 */
typedef union LDKCResult_RouteHintHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRouteHintHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RouteHintHopDecodeErrorZPtr;

/**
 * A CResult_RouteHintHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::router::RouteHintHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RouteHintHopDecodeErrorZ {
   /**
    * The contents of this CResult_RouteHintHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RouteHintHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RouteHintHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RouteHintHopDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::PublicKeys of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PublicKeyZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPublicKey *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PublicKeyZ;



/**
 * [`ScoreLookUp`] implementation that uses a fixed penalty.
 */
typedef struct MUST_USE_STRUCT LDKFixedPenaltyScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFixedPenaltyScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFixedPenaltyScorer;

/**
 * The contents of CResult_FixedPenaltyScorerDecodeErrorZ
 */
typedef union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFixedPenaltyScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FixedPenaltyScorerDecodeErrorZPtr;

/**
 * A CResult_FixedPenaltyScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::FixedPenaltyScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FixedPenaltyScorerDecodeErrorZ {
   /**
    * The contents of this CResult_FixedPenaltyScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FixedPenaltyScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FixedPenaltyScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FixedPenaltyScorerDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::routing::gossip::NodeIds of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_NodeIdZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKNodeId *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_NodeIdZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u64u64Z {
   /**
    * The element at position 0
    */
   uint64_t a;
   /**
    * The element at position 1
    */
   uint64_t b;
} LDKC2Tuple_u64u64Z;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_u64u64Z or not
 */
typedef enum LDKCOption_C2Tuple_u64u64ZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_u64u64ZZ contains a crate::c_types::derived::C2Tuple_u64u64Z
    */
   LDKCOption_C2Tuple_u64u64ZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_u64u64ZZ contains nothing
    */
   LDKCOption_C2Tuple_u64u64ZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_u64u64ZZ_Sentinel,
} LDKCOption_C2Tuple_u64u64ZZ_Tag;

typedef struct LDKCOption_C2Tuple_u64u64ZZ {
   LDKCOption_C2Tuple_u64u64ZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple_u64u64Z some;
      };
   };
} LDKCOption_C2Tuple_u64u64ZZ;

/**
 * 32 u16s
 */
typedef struct LDKThirtyTwoU16s {
   /**
    * The thirty-two 16-bit integers
    */
   uint16_t data[32];
} LDKThirtyTwoU16s;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_Z {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoU16s a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoU16s b;
} LDKC2Tuple_Z;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple__u1632_u1632Z {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoU16s a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoU16s b;
} LDKC2Tuple__u1632_u1632Z;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple__u1632_u1632Z or not
 */
typedef enum LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains a crate::c_types::derived::C2Tuple__u1632_u1632Z
    */
   LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ contains nothing
    */
   LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_Sentinel,
} LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_Tag;

typedef struct LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ {
   LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple__u1632_u1632Z some;
      };
   };
} LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ;

/**
 * An enum which can either contain a f64 or not
 */
typedef enum LDKCOption_f64Z_Tag {
   /**
    * When we're in this state, this COption_f64Z contains a f64
    */
   LDKCOption_f64Z_Some,
   /**
    * When we're in this state, this COption_f64Z contains nothing
    */
   LDKCOption_f64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_f64Z_Sentinel,
} LDKCOption_f64Z_Tag;

typedef struct LDKCOption_f64Z {
   LDKCOption_f64Z_Tag tag;
   union {
      struct {
         double some;
      };
   };
} LDKCOption_f64Z;



/**
 * A Record, unit of logging output with Metadata to enable filtering
 * Module_path, file, line to inform on log's source
 */
typedef struct MUST_USE_STRUCT LDKRecord {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRecord *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRecord;

/**
 * A trait encapsulating the operations required of a logger
 */
typedef struct LDKLogger {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Logs the `Record`
    */
   void (*log)(const void *this_arg, const struct LDKRecord *NONNULL_PTR record);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKLogger;



/**
 * Represents the network as nodes and channels between them
 */
typedef struct MUST_USE_STRUCT LDKNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNetworkGraph;



/**
 * [`ScoreLookUp`] implementation using channel success probability distributions.
 *
 * Channels are tracked with upper and lower liquidity bounds - when an HTLC fails at a channel,
 * we learn that the upper-bound on the available liquidity is lower than the amount of the HTLC.
 * When a payment is forwarded through a channel (but fails later in the route), we learn the
 * lower-bound on the channel's available liquidity must be at least the value of the HTLC.
 *
 * These bounds are then used to determine a success probability using the formula from
 * *Optimally Reliable & Cheap Payment Flows on the Lightning Network* by Rene Pickhardt
 * and Stefan Richter [[1]] (i.e. `(upper_bound - payment_amount) / (upper_bound - lower_bound)`).
 *6762, 1070
 * This probability is combined with the [`liquidity_penalty_multiplier_msat`] and
 * [`liquidity_penalty_amount_multiplier_msat`] parameters to calculate a concrete penalty in
 * milli-satoshis. The penalties, when added across all hops, have the property of being linear in
 * terms of the entire path's success probability. This allows the router to directly compare
 * penalties for different paths. See the documentation of those parameters for the exact formulas.
 *
 * The liquidity bounds are decayed by halving them every [`liquidity_offset_half_life`].
 *
 * Further, we track the history of our upper and lower liquidity bounds for each channel,
 * allowing us to assign a second penalty (using [`historical_liquidity_penalty_multiplier_msat`]
 * and [`historical_liquidity_penalty_amount_multiplier_msat`]) based on the same probability
 * formula, but using the history of a channel rather than our latest estimates for the liquidity
 * bounds.
 *
 * # Note
 *
 * Mixing the `no-std` feature between serialization and deserialization results in undefined
 * behavior.
 *
 * [1]: https://arxiv.org/abs/2107.05322
 * [`liquidity_penalty_multiplier_msat`]: ProbabilisticScoringFeeParameters::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: ProbabilisticScoringFeeParameters::liquidity_penalty_amount_multiplier_msat
 * [`liquidity_offset_half_life`]: ProbabilisticScoringDecayParameters::liquidity_offset_half_life
 * [`historical_liquidity_penalty_multiplier_msat`]: ProbabilisticScoringFeeParameters::historical_liquidity_penalty_multiplier_msat
 * [`historical_liquidity_penalty_amount_multiplier_msat`]: ProbabilisticScoringFeeParameters::historical_liquidity_penalty_amount_multiplier_msat
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScorer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScorer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScorer;

/**
 * The contents of CResult_ProbabilisticScorerDecodeErrorZ
 */
typedef union LDKCResult_ProbabilisticScorerDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKProbabilisticScorer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ProbabilisticScorerDecodeErrorZPtr;

/**
 * A CResult_ProbabilisticScorerDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::scoring::ProbabilisticScorer on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ProbabilisticScorerDecodeErrorZ {
   /**
    * The contents of this CResult_ProbabilisticScorerDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ProbabilisticScorerDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ProbabilisticScorerDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ProbabilisticScorerDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_usizeTransactionZ {
   /**
    * The element at position 0
    */
   uintptr_t a;
   /**
    * The element at position 1
    */
   struct LDKTransaction b;
} LDKC2Tuple_usizeTransactionZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_usizeTransactionZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_usizeTransactionZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_usizeTransactionZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_usizeTransactionZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCOption_ThirtyTwoBytesZ b;
} LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ;

/**
 * The contents of CResult_ChannelMonitorUpdateStatusNoneZ
 */
typedef union LDKCResult_ChannelMonitorUpdateStatusNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKChannelMonitorUpdateStatus *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_ChannelMonitorUpdateStatusNoneZPtr;

/**
 * A CResult_ChannelMonitorUpdateStatusNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::ChannelMonitorUpdateStatus on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelMonitorUpdateStatusNoneZ {
   /**
    * The contents of this CResult_ChannelMonitorUpdateStatusNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelMonitorUpdateStatusNoneZPtr contents;
   /**
    * Whether this CResult_ChannelMonitorUpdateStatusNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateStatusNoneZ;



/**
 * Simple structure sent back by `chain::Watch` when an HTLC from a forward channel is detected on
 * chain. Used to update the corresponding HTLC in the backward channel. Failing to pass the
 * preimage claim backward will lead to loss of funds.
 */
typedef struct MUST_USE_STRUCT LDKHTLCUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHTLCUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHTLCUpdate;

/**
 * An event to be processed by the ChannelManager.
 */
typedef enum LDKMonitorEvent_Tag {
   /**
    * A monitor event containing an HTLCUpdate.
    */
   LDKMonitorEvent_HTLCEvent,
   /**
    * A monitor event that the Channel's commitment transaction was confirmed.
    */
   LDKMonitorEvent_HolderForceClosed,
   /**
    * Indicates a [`ChannelMonitor`] update has completed. See
    * [`ChannelMonitorUpdateStatus::InProgress`] for more information on how this is used.
    *
    * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
    */
   LDKMonitorEvent_Completed,
   /**
    * Must be last for serialization purposes
    */
   LDKMonitorEvent_Sentinel,
} LDKMonitorEvent_Tag;

typedef struct LDKMonitorEvent_LDKCompleted_Body {
   /**
    * The funding outpoint of the [`ChannelMonitor`] that was updated
    */
   struct LDKOutPoint funding_txo;
   /**
    * The Update ID from [`ChannelMonitorUpdate::update_id`] which was applied or
    * [`ChannelMonitor::get_latest_update_id`].
    *
    * Note that this should only be set to a given update's ID if all previous updates for the
    * same [`ChannelMonitor`] have been applied and persisted.
    */
   uint64_t monitor_update_id;
} LDKMonitorEvent_LDKCompleted_Body;

typedef struct MUST_USE_STRUCT LDKMonitorEvent {
   LDKMonitorEvent_Tag tag;
   union {
      struct {
         struct LDKHTLCUpdate htlc_event;
      };
      struct {
         struct LDKOutPoint holder_force_closed;
      };
      LDKMonitorEvent_LDKCompleted_Body completed;
   };
} LDKMonitorEvent;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::MonitorEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorEventZ;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_MonitorEventZ b;
   /**
    * The element at position 2
    */
   struct LDKPublicKey c;
} LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C3Tuple_OutPointCVec_MonitorEventZPublicKeyZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ;



/**
 * Features used within an `init` message.
 */
typedef struct MUST_USE_STRUCT LDKInitFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInitFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInitFeatures;

/**
 * The contents of CResult_InitFeaturesDecodeErrorZ
 */
typedef union LDKCResult_InitFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInitFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitFeaturesDecodeErrorZPtr;

/**
 * A CResult_InitFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::InitFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_InitFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitFeaturesDecodeErrorZ;



/**
 * Features used within a `channel_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKChannelFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelFeatures;

/**
 * The contents of CResult_ChannelFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelFeaturesDecodeErrorZ;



/**
 * Features used within a `node_announcement` message.
 */
typedef struct MUST_USE_STRUCT LDKNodeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeFeatures;

/**
 * The contents of CResult_NodeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_NodeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeFeaturesDecodeErrorZPtr;

/**
 * A CResult_NodeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::NodeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_NodeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeFeaturesDecodeErrorZ;



/**
 * Features used within an invoice.
 */
typedef struct MUST_USE_STRUCT LDKBolt11InvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt11InvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt11InvoiceFeatures;

/**
 * The contents of CResult_Bolt11InvoiceFeaturesDecodeErrorZ
 */
typedef union LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBolt11InvoiceFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZPtr;

/**
 * A CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::Bolt11InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_Bolt11InvoiceFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_Bolt11InvoiceFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ;



/**
 * Features used within an `invoice`.
 */
typedef struct MUST_USE_STRUCT LDKBolt12InvoiceFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt12InvoiceFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt12InvoiceFeatures;

/**
 * The contents of CResult_Bolt12InvoiceFeaturesDecodeErrorZ
 */
typedef union LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBolt12InvoiceFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZPtr;

/**
 * A CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::Bolt12InvoiceFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_Bolt12InvoiceFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_Bolt12InvoiceFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ;



/**
 * Features used within BOLT 4 encrypted_data_tlv and BOLT 12 blinded_payinfo
 */
typedef struct MUST_USE_STRUCT LDKBlindedHopFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBlindedHopFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBlindedHopFeatures;

/**
 * The contents of CResult_BlindedHopFeaturesDecodeErrorZ
 */
typedef union LDKCResult_BlindedHopFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedHopFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedHopFeaturesDecodeErrorZPtr;

/**
 * A CResult_BlindedHopFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::BlindedHopFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedHopFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedHopFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedHopFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedHopFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedHopFeaturesDecodeErrorZ;



/**
 * Features used within the channel_type field in an OpenChannel message.
 *
 * A channel is always of some known \"type\", describing the transaction formats used and the exact
 * semantics of our interaction with our peer.
 *
 * Note that because a channel is a specific type which is proposed by the opener and accepted by
 * the counterparty, only required features are allowed here.
 *
 * This is serialized differently from other feature types - it is not prefixed by a length, and
 * thus must only appear inside a TLV where its length is known in advance.
 */
typedef struct MUST_USE_STRUCT LDKChannelTypeFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelTypeFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelTypeFeatures;

/**
 * The contents of CResult_ChannelTypeFeaturesDecodeErrorZ
 */
typedef union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTypeFeatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr;

/**
 * A CResult_ChannelTypeFeaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::features::ChannelTypeFeatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTypeFeaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTypeFeaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTypeFeaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTypeFeaturesDecodeErrorZ;



/**
 * An `Offer` is a potentially long-lived proposal for payment of a good or service.
 *
 * An offer is a precursor to an [`InvoiceRequest`]. A merchant publishes an offer from which a
 * customer may request an [`Bolt12Invoice`] for a specific quantity and using an amount sufficient
 * to cover that quantity (i.e., at least `quantity * amount`). See [`Offer::amount`].
 *
 * Offers may be denominated in currency other than bitcoin but are ultimately paid using the
 * latter.
 *
 * Through the use of [`BlindedPath`]s, offers provide recipient privacy.
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 */
typedef struct MUST_USE_STRUCT LDKOffer {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOffer *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOffer;

/**
 * The contents of CResult_OfferBolt12ParseErrorZ
 */
typedef union LDKCResult_OfferBolt12ParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOffer *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKBolt12ParseError *err;
} LDKCResult_OfferBolt12ParseErrorZPtr;

/**
 * A CResult_OfferBolt12ParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::offers::offer::Offer on success and a crate::lightning::offers::parse::Bolt12ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OfferBolt12ParseErrorZ {
   /**
    * The contents of this CResult_OfferBolt12ParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OfferBolt12ParseErrorZPtr contents;
   /**
    * Whether this CResult_OfferBolt12ParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OfferBolt12ParseErrorZ;

/**
 * The contents of CResult_PublicKeySecp256k1ErrorZ
 */
typedef union LDKCResult_PublicKeySecp256k1ErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPublicKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PublicKeySecp256k1ErrorZPtr;

/**
 * A CResult_PublicKeySecp256k1ErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::PublicKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PublicKeySecp256k1ErrorZ {
   /**
    * The contents of this CResult_PublicKeySecp256k1ErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PublicKeySecp256k1ErrorZPtr contents;
   /**
    * Whether this CResult_PublicKeySecp256k1ErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PublicKeySecp256k1ErrorZ;

/**
 * The contents of CResult_NodeIdDecodeErrorZ
 */
typedef union LDKCResult_NodeIdDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeId *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeIdDecodeErrorZPtr;

/**
 * A CResult_NodeIdDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeId on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeIdDecodeErrorZ {
   /**
    * The contents of this CResult_NodeIdDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeIdDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeIdDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeIdDecodeErrorZ;



/**
 * A [`channel_update`] message to be sent to or received from a peer.
 *
 * [`channel_update`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdate;

/**
 * Update to the [`NetworkGraph`] based on payment failure information conveyed via the Onion
 * return packet by a node along the route. See [BOLT #4] for details.
 *
 * [BOLT #4]: https://github.com/lightning/bolts/blob/master/04-onion-routing.md
 */
typedef enum LDKNetworkUpdate_Tag {
   /**
    * An error indicating a `channel_update` messages should be applied via
    * [`NetworkGraph::update_channel`].
    */
   LDKNetworkUpdate_ChannelUpdateMessage,
   /**
    * An error indicating that a channel failed to route a payment, which should be applied via
    * [`NetworkGraph::channel_failed_permanent`] if permanent.
    */
   LDKNetworkUpdate_ChannelFailure,
   /**
    * An error indicating that a node failed to route a payment, which should be applied via
    * [`NetworkGraph::node_failed_permanent`] if permanent.
    */
   LDKNetworkUpdate_NodeFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKNetworkUpdate_Sentinel,
} LDKNetworkUpdate_Tag;

typedef struct LDKNetworkUpdate_LDKChannelUpdateMessage_Body {
   /**
    * The update to apply via [`NetworkGraph::update_channel`].
    */
   struct LDKChannelUpdate msg;
} LDKNetworkUpdate_LDKChannelUpdateMessage_Body;

typedef struct LDKNetworkUpdate_LDKChannelFailure_Body {
   /**
    * The short channel id of the closed channel.
    */
   uint64_t short_channel_id;
   /**
    * Whether the channel should be permanently removed or temporarily disabled until a new
    * `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKChannelFailure_Body;

typedef struct LDKNetworkUpdate_LDKNodeFailure_Body {
   /**
    * The node id of the failed node.
    */
   struct LDKPublicKey node_id;
   /**
    * Whether the node should be permanently removed from consideration or can be restored
    * when a new `channel_update` message is received.
    */
   bool is_permanent;
} LDKNetworkUpdate_LDKNodeFailure_Body;

typedef struct MUST_USE_STRUCT LDKNetworkUpdate {
   LDKNetworkUpdate_Tag tag;
   union {
      LDKNetworkUpdate_LDKChannelUpdateMessage_Body channel_update_message;
      LDKNetworkUpdate_LDKChannelFailure_Body channel_failure;
      LDKNetworkUpdate_LDKNodeFailure_Body node_failure;
   };
} LDKNetworkUpdate;

/**
 * An enum which can either contain a crate::lightning::routing::gossip::NetworkUpdate or not
 */
typedef enum LDKCOption_NetworkUpdateZ_Tag {
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains a crate::lightning::routing::gossip::NetworkUpdate
    */
   LDKCOption_NetworkUpdateZ_Some,
   /**
    * When we're in this state, this COption_NetworkUpdateZ contains nothing
    */
   LDKCOption_NetworkUpdateZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_NetworkUpdateZ_Sentinel,
} LDKCOption_NetworkUpdateZ_Tag;

typedef struct LDKCOption_NetworkUpdateZ {
   LDKCOption_NetworkUpdateZ_Tag tag;
   union {
      struct {
         struct LDKNetworkUpdate some;
      };
   };
} LDKCOption_NetworkUpdateZ;

/**
 * The contents of CResult_COption_NetworkUpdateZDecodeErrorZ
 */
typedef union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_NetworkUpdateZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr;

/**
 * A CResult_COption_NetworkUpdateZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_NetworkUpdateZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_NetworkUpdateZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_NetworkUpdateZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_NetworkUpdateZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_NetworkUpdateZDecodeErrorZ;

/**
 * The contents of CResult_TxOutUtxoLookupErrorZ
 */
typedef union LDKCResult_TxOutUtxoLookupErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxOut *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKUtxoLookupError *err;
} LDKCResult_TxOutUtxoLookupErrorZPtr;

/**
 * A CResult_TxOutUtxoLookupErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::TxOut on success and a crate::lightning::routing::utxo::UtxoLookupError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxOutUtxoLookupErrorZ {
   /**
    * The contents of this CResult_TxOutUtxoLookupErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxOutUtxoLookupErrorZPtr contents;
   /**
    * Whether this CResult_TxOutUtxoLookupErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxOutUtxoLookupErrorZ;



/**
 * Represents a future resolution of a [`UtxoLookup::get_utxo`] query resolving async.
 *
 * See [`UtxoResult::Async`] and [`UtxoFuture::resolve`] for more info.
 */
typedef struct MUST_USE_STRUCT LDKUtxoFuture {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUtxoFuture *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUtxoFuture;

/**
 * The result of a [`UtxoLookup::get_utxo`] call. A call may resolve either synchronously,
 * returning the `Sync` variant, or asynchronously, returning an [`UtxoFuture`] in the `Async`
 * variant.
 */
typedef enum LDKUtxoResult_Tag {
   /**
    * A result which was resolved synchronously. It either includes a [`TxOut`] for the output
    * requested or a [`UtxoLookupError`].
    */
   LDKUtxoResult_Sync,
   /**
    * A result which will be resolved asynchronously. It includes a [`UtxoFuture`], a `clone` of
    * which you must keep locally and call [`UtxoFuture::resolve`] on once the lookup completes.
    *
    * Note that in order to avoid runaway memory usage, the number of parallel checks is limited,
    * but only fairly loosely. Because a pending checks block all message processing, leaving
    * checks pending for an extended time may cause DoS of other functions. It is recommended you
    * keep a tight timeout on lookups, on the order of a few seconds.
    */
   LDKUtxoResult_Async,
   /**
    * Must be last for serialization purposes
    */
   LDKUtxoResult_Sentinel,
} LDKUtxoResult_Tag;

typedef struct MUST_USE_STRUCT LDKUtxoResult {
   LDKUtxoResult_Tag tag;
   union {
      struct {
         struct LDKCResult_TxOutUtxoLookupErrorZ sync;
      };
      struct {
         struct LDKUtxoFuture async;
      };
   };
} LDKUtxoResult;

/**
 * The `UtxoLookup` trait defines behavior for accessing on-chain UTXOs.
 */
typedef struct LDKUtxoLookup {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the transaction output of a funding transaction encoded by [`short_channel_id`].
    * Returns an error if `genesis_hash` is for a different chain or if such a transaction output
    * is unknown.
    *
    * [`short_channel_id`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#definition-of-short_channel_id
    */
   struct LDKUtxoResult (*get_utxo)(const void *this_arg, const uint8_t (*genesis_hash)[32], uint64_t short_channel_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKUtxoLookup;

/**
 * An enum which can either contain a crate::lightning::routing::utxo::UtxoLookup or not
 */
typedef enum LDKCOption_UtxoLookupZ_Tag {
   /**
    * When we're in this state, this COption_UtxoLookupZ contains a crate::lightning::routing::utxo::UtxoLookup
    */
   LDKCOption_UtxoLookupZ_Some,
   /**
    * When we're in this state, this COption_UtxoLookupZ contains nothing
    */
   LDKCOption_UtxoLookupZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_UtxoLookupZ_Sentinel,
} LDKCOption_UtxoLookupZ_Tag;

typedef struct LDKCOption_UtxoLookupZ {
   LDKCOption_UtxoLookupZ_Tag tag;
   union {
      struct {
         struct LDKUtxoLookup some;
      };
   };
} LDKCOption_UtxoLookupZ;

/**
 * The contents of CResult_NoneLightningErrorZ
 */
typedef union LDKCResult_NoneLightningErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_NoneLightningErrorZPtr;

/**
 * A CResult_NoneLightningErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneLightningErrorZ {
   /**
    * The contents of this CResult_NoneLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneLightningErrorZPtr contents;
   /**
    * Whether this CResult_NoneLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneLightningErrorZ;

/**
 * The contents of CResult_boolLightningErrorZ
 */
typedef union LDKCResult_boolLightningErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKLightningError *err;
} LDKCResult_boolLightningErrorZPtr;

/**
 * A CResult_boolLightningErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::msgs::LightningError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolLightningErrorZ {
   /**
    * The contents of this CResult_boolLightningErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolLightningErrorZPtr contents;
   /**
    * Whether this CResult_boolLightningErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolLightningErrorZ;



/**
 * A [`channel_announcement`] message to be sent to or received from a peer.
 *
 * [`channel_announcement`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_announcement-message
 */
typedef struct MUST_USE_STRUCT LDKChannelAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelAnnouncement;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ {
   /**
    * The element at position 0
    */
   struct LDKChannelAnnouncement a;
   /**
    * The element at position 1
    */
   struct LDKChannelUpdate b;
   /**
    * The element at position 2
    */
   struct LDKChannelUpdate c;
} LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ;

/**
 * An enum which can either contain a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ or not
 */
typedef enum LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag {
   /**
    * When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Some,
   /**
    * When we're in this state, this COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ contains nothing
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Sentinel,
} LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag;

typedef struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ {
   LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_Tag tag;
   union {
      struct {
         struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ some;
      };
   };
} LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ;



/**
 * An [`accept_channel`] message to be sent to or received from a peer.
 *
 * Used in V1 channel establishment
 *
 * [`accept_channel`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-accept_channel-message
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannel;



/**
 * An accept_channel2 message to be sent by or received from the channel accepter.
 *
 * Used in V2 channel establishment
 *
 */
typedef struct MUST_USE_STRUCT LDKAcceptChannelV2 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAcceptChannelV2 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAcceptChannelV2;



/**
 * An [`open_channel`] message to be sent to or received from a peer.
 *
 * Used in V1 channel establishment
 *
 * [`open_channel`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-open_channel-message
 */
typedef struct MUST_USE_STRUCT LDKOpenChannel {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannel *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannel;



/**
 * An open_channel2 message to be sent by or received from the channel initiator.
 *
 * Used in V2 channel establishment
 *
 */
typedef struct MUST_USE_STRUCT LDKOpenChannelV2 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOpenChannelV2 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOpenChannelV2;



/**
 * A [`funding_created`] message to be sent to or received from a peer.
 *
 * Used in V1 channel establishment
 *
 * [`funding_created`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-funding_created-message
 */
typedef struct MUST_USE_STRUCT LDKFundingCreated {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingCreated *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingCreated;



/**
 * A [`funding_signed`] message to be sent to or received from a peer.
 *
 * Used in V1 channel establishment
 *
 * [`funding_signed`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-funding_signed-message
 */
typedef struct MUST_USE_STRUCT LDKFundingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFundingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFundingSigned;



/**
 * A tx_add_input message for adding an input during interactive transaction construction
 *
 */
typedef struct MUST_USE_STRUCT LDKTxAddInput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxAddInput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxAddInput;



/**
 * A tx_add_output message for adding an output during interactive transaction construction.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxAddOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxAddOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxAddOutput;



/**
 * A tx_remove_input message for removing an input during interactive transaction construction.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxRemoveInput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxRemoveInput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxRemoveInput;



/**
 * A tx_remove_output message for removing an output during interactive transaction construction.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxRemoveOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxRemoveOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxRemoveOutput;



/**
 * A tx_complete message signalling the conclusion of a peer's transaction contributions during
 * interactive transaction construction.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxComplete {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxComplete *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxComplete;



/**
 * A tx_signatures message containing the sender's signatures for a transaction constructed with
 * interactive transaction construction.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxSignatures;



/**
 * A tx_init_rbf message which initiates a replacement of the transaction after it's been
 * completed.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxInitRbf {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxInitRbf *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxInitRbf;



/**
 * A tx_ack_rbf message which acknowledges replacement of the transaction after it's been
 * completed.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxAckRbf {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxAckRbf *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxAckRbf;



/**
 * A tx_abort message which signals the cancellation of an in-progress transaction negotiation.
 *
 */
typedef struct MUST_USE_STRUCT LDKTxAbort {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxAbort *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxAbort;



/**
 * A [`channel_ready`] message to be sent to or received from a peer.
 *
 * [`channel_ready`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#the-channel_ready-message
 */
typedef struct MUST_USE_STRUCT LDKChannelReady {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReady *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReady;



/**
 * An [`announcement_signatures`] message to be sent to or received from a peer.
 *
 * [`announcement_signatures`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-announcement_signatures-message
 */
typedef struct MUST_USE_STRUCT LDKAnnouncementSignatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnnouncementSignatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnnouncementSignatures;



/**
 * Struct used to return values from [`RevokeAndACK`] messages, containing a bunch of commitment
 * transaction updates if they were pending.
 */
typedef struct MUST_USE_STRUCT LDKCommitmentUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentUpdate;



/**
 * A [`revoke_and_ack`] message to be sent to or received from a peer.
 *
 * [`revoke_and_ack`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#completing-the-transition-to-the-updated-state-revoke_and_ack
 */
typedef struct MUST_USE_STRUCT LDKRevokeAndACK {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRevokeAndACK *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRevokeAndACK;



/**
 * A [`closing_signed`] message to be sent to or received from a peer.
 *
 * [`closing_signed`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#closing-negotiation-closing_signed
 */
typedef struct MUST_USE_STRUCT LDKClosingSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSigned;



/**
 * A [`shutdown`] message to be sent to or received from a peer.
 *
 * [`shutdown`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#closing-initiation-shutdown
 */
typedef struct MUST_USE_STRUCT LDKShutdown {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeShutdown *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKShutdown;



/**
 * A [`channel_reestablish`] message to be sent to or received from a peer.
 *
 * [`channel_reestablish`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#message-retransmission
 */
typedef struct MUST_USE_STRUCT LDKChannelReestablish {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelReestablish *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelReestablish;



/**
 * A [`node_announcement`] message to be sent to or received from a peer.
 *
 * [`node_announcement`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-node_announcement-message
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncement;



/**
 * An [`error`] message to be sent to or received from a peer.
 *
 * [`error`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-error-and-warning-messages
 */
typedef struct MUST_USE_STRUCT LDKErrorMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErrorMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErrorMessage;



/**
 * A [`warning`] message to be sent to or received from a peer.
 *
 * [`warning`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-error-and-warning-messages
 */
typedef struct MUST_USE_STRUCT LDKWarningMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWarningMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWarningMessage;

/**
 * Used to put an error message in a [`LightningError`].
 */
typedef enum LDKErrorAction_Tag {
   /**
    * The peer took some action which made us think they were useless. Disconnect them.
    */
   LDKErrorAction_DisconnectPeer,
   /**
    * The peer did something incorrect. Tell them without closing any channels and disconnect them.
    */
   LDKErrorAction_DisconnectPeerWithWarning,
   /**
    * The peer did something harmless that we weren't able to process, just log and ignore
    */
   LDKErrorAction_IgnoreError,
   /**
    * The peer did something harmless that we weren't able to meaningfully process.
    * If the error is logged, log it at the given level.
    */
   LDKErrorAction_IgnoreAndLog,
   /**
    * The peer provided us with a gossip message which we'd already seen. In most cases this
    * should be ignored, but it may result in the message being forwarded if it is a duplicate of
    * our own channel announcements.
    */
   LDKErrorAction_IgnoreDuplicateGossip,
   /**
    * The peer did something incorrect. Tell them.
    */
   LDKErrorAction_SendErrorMessage,
   /**
    * The peer did something incorrect. Tell them without closing any channels.
    */
   LDKErrorAction_SendWarningMessage,
   /**
    * Must be last for serialization purposes
    */
   LDKErrorAction_Sentinel,
} LDKErrorAction_Tag;

typedef struct LDKErrorAction_LDKDisconnectPeer_Body {
   /**
    * An error message which we should make an effort to send before we disconnect.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKDisconnectPeer_Body;

typedef struct LDKErrorAction_LDKDisconnectPeerWithWarning_Body {
   /**
    * A warning message which we should make an effort to send before we disconnect.
    */
   struct LDKWarningMessage msg;
} LDKErrorAction_LDKDisconnectPeerWithWarning_Body;

typedef struct LDKErrorAction_LDKSendErrorMessage_Body {
   /**
    * The message to send.
    */
   struct LDKErrorMessage msg;
} LDKErrorAction_LDKSendErrorMessage_Body;

typedef struct LDKErrorAction_LDKSendWarningMessage_Body {
   /**
    * The message to send.
    */
   struct LDKWarningMessage msg;
   /**
    * The peer may have done something harmless that we weren't able to meaningfully process,
    * though we should still tell them about it.
    * If this event is logged, log it at the given level.
    */
   enum LDKLevel log_level;
} LDKErrorAction_LDKSendWarningMessage_Body;

typedef struct MUST_USE_STRUCT LDKErrorAction {
   LDKErrorAction_Tag tag;
   union {
      LDKErrorAction_LDKDisconnectPeer_Body disconnect_peer;
      LDKErrorAction_LDKDisconnectPeerWithWarning_Body disconnect_peer_with_warning;
      struct {
         enum LDKLevel ignore_and_log;
      };
      LDKErrorAction_LDKSendErrorMessage_Body send_error_message;
      LDKErrorAction_LDKSendWarningMessage_Body send_warning_message;
   };
} LDKErrorAction;



/**
 * A [`query_channel_range`] message is used to query a peer for channel
 * UTXOs in a range of blocks. The recipient of a query makes a best
 * effort to reply to the query using one or more [`ReplyChannelRange`]
 * messages.
 *
 * [`query_channel_range`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-query_channel_range-and-reply_channel_range-messages
 */
typedef struct MUST_USE_STRUCT LDKQueryChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryChannelRange;



/**
 * A [`query_short_channel_ids`] message is used to query a peer for
 * routing gossip messages related to one or more `short_channel_id`s.
 *
 * The query recipient will reply with the latest, if available,
 * [`ChannelAnnouncement`], [`ChannelUpdate`] and [`NodeAnnouncement`] messages
 * it maintains for the requested `short_channel_id`s followed by a
 * [`ReplyShortChannelIdsEnd`] message. The `short_channel_id`s sent in
 * this query are encoded. We only support `encoding_type=0` uncompressed
 * serialization and do not support `encoding_type=1` zlib serialization.
 *
 * [`query_short_channel_ids`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-query_short_channel_idsreply_short_channel_ids_end-messages
 */
typedef struct MUST_USE_STRUCT LDKQueryShortChannelIds {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQueryShortChannelIds *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQueryShortChannelIds;



/**
 * A [`reply_channel_range`] message is a reply to a [`QueryChannelRange`]
 * message.
 *
 * Multiple `reply_channel_range` messages can be sent in reply
 * to a single [`QueryChannelRange`] message. The query recipient makes a
 * best effort to respond based on their local network view which may
 * not be a perfect view of the network. The `short_channel_id`s in the
 * reply are encoded. We only support `encoding_type=0` uncompressed
 * serialization and do not support `encoding_type=1` zlib serialization.
 *
 * [`reply_channel_range`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-query_channel_range-and-reply_channel_range-messages
 */
typedef struct MUST_USE_STRUCT LDKReplyChannelRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyChannelRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyChannelRange;



/**
 * A [`gossip_timestamp_filter`] message is used by a node to request
 * gossip relay for messages in the requested time range when the
 * `gossip_queries` feature has been negotiated.
 *
 * [`gossip_timestamp_filter`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-gossip_timestamp_filter-message
 */
typedef struct MUST_USE_STRUCT LDKGossipTimestampFilter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeGossipTimestampFilter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKGossipTimestampFilter;

/**
 * An event generated by ChannelManager which indicates a message should be sent to a peer (or
 * broadcast to most peers).
 * These events are handled by PeerManager::process_events if you are using a PeerManager.
 */
typedef enum LDKMessageSendEvent_Tag {
   /**
    * Used to indicate that we've accepted a channel open and should send the accept_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannel,
   /**
    * Used to indicate that we've accepted a V2 channel open and should send the accept_channel2
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendAcceptChannelV2,
   /**
    * Used to indicate that we've initiated a channel open and should send the open_channel
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannel,
   /**
    * Used to indicate that we've initiated a V2 channel open and should send the open_channel2
    * message provided to the given peer.
    */
   LDKMessageSendEvent_SendOpenChannelV2,
   /**
    * Used to indicate that a funding_created message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingCreated,
   /**
    * Used to indicate that a funding_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendFundingSigned,
   /**
    * Used to indicate that a tx_add_input message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxAddInput,
   /**
    * Used to indicate that a tx_add_output message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxAddOutput,
   /**
    * Used to indicate that a tx_remove_input message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxRemoveInput,
   /**
    * Used to indicate that a tx_remove_output message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxRemoveOutput,
   /**
    * Used to indicate that a tx_complete message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxComplete,
   /**
    * Used to indicate that a tx_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxSignatures,
   /**
    * Used to indicate that a tx_init_rbf message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxInitRbf,
   /**
    * Used to indicate that a tx_ack_rbf message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxAckRbf,
   /**
    * Used to indicate that a tx_abort message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendTxAbort,
   /**
    * Used to indicate that a channel_ready message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReady,
   /**
    * Used to indicate that an announcement_signatures message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendAnnouncementSignatures,
   /**
    * Used to indicate that a series of HTLC update messages, as well as a commitment_signed
    * message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_UpdateHTLCs,
   /**
    * Used to indicate that a revoke_and_ack message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendRevokeAndACK,
   /**
    * Used to indicate that a closing_signed message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendClosingSigned,
   /**
    * Used to indicate that a shutdown message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendShutdown,
   /**
    * Used to indicate that a channel_reestablish message should be sent to the peer with the given node_id.
    */
   LDKMessageSendEvent_SendChannelReestablish,
   /**
    * Used to send a channel_announcement and channel_update to a specific peer, likely on
    * initial connection to ensure our peers know about our channels.
    */
   LDKMessageSendEvent_SendChannelAnnouncement,
   /**
    * Used to indicate that a channel_announcement and channel_update should be broadcast to all
    * peers (except the peer with node_id either msg.contents.node_id_1 or msg.contents.node_id_2).
    *
    * Note that after doing so, you very likely (unless you did so very recently) want to
    * broadcast a node_announcement (e.g. via [`PeerManager::broadcast_node_announcement`]). This
    * ensures that any nodes which see our channel_announcement also have a relevant
    * node_announcement, including relevant feature flags which may be important for routing
    * through or to us.
    *
    * [`PeerManager::broadcast_node_announcement`]: crate::ln::peer_handler::PeerManager::broadcast_node_announcement
    */
   LDKMessageSendEvent_BroadcastChannelAnnouncement,
   /**
    * Used to indicate that a channel_update should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastChannelUpdate,
   /**
    * Used to indicate that a node_announcement should be broadcast to all peers.
    */
   LDKMessageSendEvent_BroadcastNodeAnnouncement,
   /**
    * Used to indicate that a channel_update should be sent to a single peer.
    * In contrast to [`Self::BroadcastChannelUpdate`], this is used when the channel is a
    * private channel and we shouldn't be informing all of our peers of channel parameters.
    */
   LDKMessageSendEvent_SendChannelUpdate,
   /**
    * Broadcast an error downstream to be handled
    */
   LDKMessageSendEvent_HandleError,
   /**
    * Query a peer for channels with funding transaction UTXOs in a block range.
    */
   LDKMessageSendEvent_SendChannelRangeQuery,
   /**
    * Request routing gossip messages from a peer for a list of channels identified by
    * their short_channel_ids.
    */
   LDKMessageSendEvent_SendShortIdsQuery,
   /**
    * Sends a reply to a channel range query. This may be one of several SendReplyChannelRange events
    * emitted during processing of the query.
    */
   LDKMessageSendEvent_SendReplyChannelRange,
   /**
    * Sends a timestamp filter for inbound gossip. This should be sent on each new connection to
    * enable receiving gossip messages from the peer.
    */
   LDKMessageSendEvent_SendGossipTimestampFilter,
   /**
    * Must be last for serialization purposes
    */
   LDKMessageSendEvent_Sentinel,
} LDKMessageSendEvent_Tag;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannel msg;
} LDKMessageSendEvent_LDKSendAcceptChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendAcceptChannelV2_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKAcceptChannelV2 msg;
} LDKMessageSendEvent_LDKSendAcceptChannelV2_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannel_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannel msg;
} LDKMessageSendEvent_LDKSendOpenChannel_Body;

typedef struct LDKMessageSendEvent_LDKSendOpenChannelV2_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKOpenChannelV2 msg;
} LDKMessageSendEvent_LDKSendOpenChannelV2_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingCreated_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingCreated msg;
} LDKMessageSendEvent_LDKSendFundingCreated_Body;

typedef struct LDKMessageSendEvent_LDKSendFundingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKFundingSigned msg;
} LDKMessageSendEvent_LDKSendFundingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendTxAddInput_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxAddInput msg;
} LDKMessageSendEvent_LDKSendTxAddInput_Body;

typedef struct LDKMessageSendEvent_LDKSendTxAddOutput_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxAddOutput msg;
} LDKMessageSendEvent_LDKSendTxAddOutput_Body;

typedef struct LDKMessageSendEvent_LDKSendTxRemoveInput_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxRemoveInput msg;
} LDKMessageSendEvent_LDKSendTxRemoveInput_Body;

typedef struct LDKMessageSendEvent_LDKSendTxRemoveOutput_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxRemoveOutput msg;
} LDKMessageSendEvent_LDKSendTxRemoveOutput_Body;

typedef struct LDKMessageSendEvent_LDKSendTxComplete_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxComplete msg;
} LDKMessageSendEvent_LDKSendTxComplete_Body;

typedef struct LDKMessageSendEvent_LDKSendTxSignatures_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxSignatures msg;
} LDKMessageSendEvent_LDKSendTxSignatures_Body;

typedef struct LDKMessageSendEvent_LDKSendTxInitRbf_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxInitRbf msg;
} LDKMessageSendEvent_LDKSendTxInitRbf_Body;

typedef struct LDKMessageSendEvent_LDKSendTxAckRbf_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxAckRbf msg;
} LDKMessageSendEvent_LDKSendTxAckRbf_Body;

typedef struct LDKMessageSendEvent_LDKSendTxAbort_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKTxAbort msg;
} LDKMessageSendEvent_LDKSendTxAbort_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReady_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_ready message which should be sent.
    */
   struct LDKChannelReady msg;
} LDKMessageSendEvent_LDKSendChannelReady_Body;

typedef struct LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The announcement_signatures message which should be sent.
    */
   struct LDKAnnouncementSignatures msg;
} LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body;

typedef struct LDKMessageSendEvent_LDKUpdateHTLCs_Body {
   /**
    * The node_id of the node which should receive these message(s)
    */
   struct LDKPublicKey node_id;
   /**
    * The update messages which should be sent. ALL messages in the struct should be sent!
    */
   struct LDKCommitmentUpdate updates;
} LDKMessageSendEvent_LDKUpdateHTLCs_Body;

typedef struct LDKMessageSendEvent_LDKSendRevokeAndACK_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKRevokeAndACK msg;
} LDKMessageSendEvent_LDKSendRevokeAndACK_Body;

typedef struct LDKMessageSendEvent_LDKSendClosingSigned_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKClosingSigned msg;
} LDKMessageSendEvent_LDKSendClosingSigned_Body;

typedef struct LDKMessageSendEvent_LDKSendShutdown_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKShutdown msg;
} LDKMessageSendEvent_LDKSendShutdown_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelReestablish_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The message which should be sent.
    */
   struct LDKChannelReestablish msg;
} LDKMessageSendEvent_LDKSendChannelReestablish_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelAnnouncement_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKSendChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body {
   /**
    * The channel_announcement which should be sent.
    */
   struct LDKChannelAnnouncement msg;
   /**
    * The followup channel_update which should be sent.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKChannelUpdate update_msg;
} LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body {
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body {
   /**
    * The node_announcement which should be sent.
    */
   struct LDKNodeAnnouncement msg;
} LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelUpdate_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The channel_update which should be sent.
    */
   struct LDKChannelUpdate msg;
} LDKMessageSendEvent_LDKSendChannelUpdate_Body;

typedef struct LDKMessageSendEvent_LDKHandleError_Body {
   /**
    * The node_id of the node which should receive this message
    */
   struct LDKPublicKey node_id;
   /**
    * The action which should be taken.
    */
   struct LDKErrorAction action;
} LDKMessageSendEvent_LDKHandleError_Body;

typedef struct LDKMessageSendEvent_LDKSendChannelRangeQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_channel_range which should be sent.
    */
   struct LDKQueryChannelRange msg;
} LDKMessageSendEvent_LDKSendChannelRangeQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendShortIdsQuery_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The query_short_channel_ids which should be sent.
    */
   struct LDKQueryShortChannelIds msg;
} LDKMessageSendEvent_LDKSendShortIdsQuery_Body;

typedef struct LDKMessageSendEvent_LDKSendReplyChannelRange_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The reply_channel_range which should be sent.
    */
   struct LDKReplyChannelRange msg;
} LDKMessageSendEvent_LDKSendReplyChannelRange_Body;

typedef struct LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body {
   /**
    * The node_id of this message recipient
    */
   struct LDKPublicKey node_id;
   /**
    * The gossip_timestamp_filter which should be sent.
    */
   struct LDKGossipTimestampFilter msg;
} LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body;

typedef struct MUST_USE_STRUCT LDKMessageSendEvent {
   LDKMessageSendEvent_Tag tag;
   union {
      LDKMessageSendEvent_LDKSendAcceptChannel_Body send_accept_channel;
      LDKMessageSendEvent_LDKSendAcceptChannelV2_Body send_accept_channel_v2;
      LDKMessageSendEvent_LDKSendOpenChannel_Body send_open_channel;
      LDKMessageSendEvent_LDKSendOpenChannelV2_Body send_open_channel_v2;
      LDKMessageSendEvent_LDKSendFundingCreated_Body send_funding_created;
      LDKMessageSendEvent_LDKSendFundingSigned_Body send_funding_signed;
      LDKMessageSendEvent_LDKSendTxAddInput_Body send_tx_add_input;
      LDKMessageSendEvent_LDKSendTxAddOutput_Body send_tx_add_output;
      LDKMessageSendEvent_LDKSendTxRemoveInput_Body send_tx_remove_input;
      LDKMessageSendEvent_LDKSendTxRemoveOutput_Body send_tx_remove_output;
      LDKMessageSendEvent_LDKSendTxComplete_Body send_tx_complete;
      LDKMessageSendEvent_LDKSendTxSignatures_Body send_tx_signatures;
      LDKMessageSendEvent_LDKSendTxInitRbf_Body send_tx_init_rbf;
      LDKMessageSendEvent_LDKSendTxAckRbf_Body send_tx_ack_rbf;
      LDKMessageSendEvent_LDKSendTxAbort_Body send_tx_abort;
      LDKMessageSendEvent_LDKSendChannelReady_Body send_channel_ready;
      LDKMessageSendEvent_LDKSendAnnouncementSignatures_Body send_announcement_signatures;
      LDKMessageSendEvent_LDKUpdateHTLCs_Body update_htl_cs;
      LDKMessageSendEvent_LDKSendRevokeAndACK_Body send_revoke_and_ack;
      LDKMessageSendEvent_LDKSendClosingSigned_Body send_closing_signed;
      LDKMessageSendEvent_LDKSendShutdown_Body send_shutdown;
      LDKMessageSendEvent_LDKSendChannelReestablish_Body send_channel_reestablish;
      LDKMessageSendEvent_LDKSendChannelAnnouncement_Body send_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelAnnouncement_Body broadcast_channel_announcement;
      LDKMessageSendEvent_LDKBroadcastChannelUpdate_Body broadcast_channel_update;
      LDKMessageSendEvent_LDKBroadcastNodeAnnouncement_Body broadcast_node_announcement;
      LDKMessageSendEvent_LDKSendChannelUpdate_Body send_channel_update;
      LDKMessageSendEvent_LDKHandleError_Body handle_error;
      LDKMessageSendEvent_LDKSendChannelRangeQuery_Body send_channel_range_query;
      LDKMessageSendEvent_LDKSendShortIdsQuery_Body send_short_ids_query;
      LDKMessageSendEvent_LDKSendReplyChannelRange_Body send_reply_channel_range;
      LDKMessageSendEvent_LDKSendGossipTimestampFilter_Body send_gossip_timestamp_filter;
   };
} LDKMessageSendEvent;

/**
 * A dynamically-allocated array of crate::lightning::events::MessageSendEvents of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MessageSendEventZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMessageSendEvent *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MessageSendEventZ;



/**
 * Details about one direction of a channel as received within a [`ChannelUpdate`].
 */
typedef struct MUST_USE_STRUCT LDKChannelUpdateInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelUpdateInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelUpdateInfo;

/**
 * The contents of CResult_ChannelUpdateInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdateInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::ChannelUpdateInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateInfoDecodeErrorZ;



/**
 * Details about a channel (both directions).
 * Received within a channel announcement.
 */
typedef struct MUST_USE_STRUCT LDKChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelInfo;

/**
 * The contents of CResult_ChannelInfoDecodeErrorZ
 */
typedef union LDKCResult_ChannelInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelInfoDecodeErrorZPtr;

/**
 * A CResult_ChannelInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::ChannelInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelInfoDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelInfoDecodeErrorZ;



/**
 * Fees for routing via a given channel or a node
 */
typedef struct MUST_USE_STRUCT LDKRoutingFees {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRoutingFees *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRoutingFees;

/**
 * The contents of CResult_RoutingFeesDecodeErrorZ
 */
typedef union LDKCResult_RoutingFeesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRoutingFees *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RoutingFeesDecodeErrorZPtr;

/**
 * A CResult_RoutingFeesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::RoutingFees on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RoutingFeesDecodeErrorZ {
   /**
    * The contents of this CResult_RoutingFeesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RoutingFeesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RoutingFeesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RoutingFeesDecodeErrorZ;

/**
 * A 4-byte byte array.
 */
typedef struct LDKFourBytes {
   /**
    * The four bytes
    */
   uint8_t data[4];
} LDKFourBytes;

/**
 * A 12-byte byte array.
 */
typedef struct LDKTwelveBytes {
   /**
    * The twelve bytes
    */
   uint8_t data[12];
} LDKTwelveBytes;



/**
 * Represents a hostname for serialization purposes.
 * Only the character set and length will be validated.
 * The character set consists of ASCII alphanumeric characters, hyphens, and periods.
 * Its length is guaranteed to be representable by a single byte.
 * This serialization is used by [`BOLT 7`] hostnames.
 *
 * [`BOLT 7`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md
 */
typedef struct MUST_USE_STRUCT LDKHostname {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeHostname *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKHostname;

/**
 * An address which can be used to connect to a remote peer.
 */
typedef enum LDKSocketAddress_Tag {
   /**
    * An IPv4 address and port on which the peer is listening.
    */
   LDKSocketAddress_TcpIpV4,
   /**
    * An IPv6 address and port on which the peer is listening.
    */
   LDKSocketAddress_TcpIpV6,
   /**
    * An old-style Tor onion address/port on which the peer is listening.
    *
    * This field is deprecated and the Tor network generally no longer supports V2 Onion
    * addresses. Thus, the details are not parsed here.
    */
   LDKSocketAddress_OnionV2,
   /**
    * A new-style Tor onion address/port on which the peer is listening.
    *
    * To create the human-readable \"hostname\", concatenate the ED25519 pubkey, checksum, and version,
    * wrap as base32 and append \".onion\".
    */
   LDKSocketAddress_OnionV3,
   /**
    * A hostname/port on which the peer is listening.
    */
   LDKSocketAddress_Hostname,
   /**
    * Must be last for serialization purposes
    */
   LDKSocketAddress_Sentinel,
} LDKSocketAddress_Tag;

typedef struct LDKSocketAddress_LDKTcpIpV4_Body {
   /**
    * The 4-byte IPv4 address
    */
   struct LDKFourBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKSocketAddress_LDKTcpIpV4_Body;

typedef struct LDKSocketAddress_LDKTcpIpV6_Body {
   /**
    * The 16-byte IPv6 address
    */
   struct LDKSixteenBytes addr;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKSocketAddress_LDKTcpIpV6_Body;

typedef struct LDKSocketAddress_LDKOnionV3_Body {
   /**
    * The ed25519 long-term public key of the peer
    */
   struct LDKThirtyTwoBytes ed25519_pubkey;
   /**
    * The checksum of the pubkey and version, as included in the onion address
    */
   uint16_t checksum;
   /**
    * The version byte, as defined by the Tor Onion v3 spec.
    */
   uint8_t version;
   /**
    * The port on which the node is listening
    */
   uint16_t port;
} LDKSocketAddress_LDKOnionV3_Body;

typedef struct LDKSocketAddress_LDKHostname_Body {
   /**
    * The hostname on which the node is listening.
    */
   struct LDKHostname hostname;
   /**
    * The port on which the node is listening.
    */
   uint16_t port;
} LDKSocketAddress_LDKHostname_Body;

typedef struct MUST_USE_STRUCT LDKSocketAddress {
   LDKSocketAddress_Tag tag;
   union {
      LDKSocketAddress_LDKTcpIpV4_Body tcp_ip_v4;
      LDKSocketAddress_LDKTcpIpV6_Body tcp_ip_v6;
      struct {
         struct LDKTwelveBytes onion_v2;
      };
      LDKSocketAddress_LDKOnionV3_Body onion_v3;
      LDKSocketAddress_LDKHostname_Body hostname;
   };
} LDKSocketAddress;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::SocketAddresss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_SocketAddressZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKSocketAddress *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_SocketAddressZ;



/**
 * Information received in the latest node_announcement from this node.
 */
typedef struct MUST_USE_STRUCT LDKNodeAnnouncementInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAnnouncementInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAnnouncementInfo;

/**
 * The contents of CResult_NodeAnnouncementInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncementInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeAnnouncementInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementInfoDecodeErrorZ;



/**
 * A user-defined name for a node, which may be used when displaying the node in a graph.
 *
 * Since node aliases are provided by third parties, they are a potential avenue for injection
 * attacks. Care must be taken when processing.
 */
typedef struct MUST_USE_STRUCT LDKNodeAlias {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeAlias *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeAlias;

/**
 * The contents of CResult_NodeAliasDecodeErrorZ
 */
typedef union LDKCResult_NodeAliasDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAlias *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAliasDecodeErrorZPtr;

/**
 * A CResult_NodeAliasDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeAlias on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAliasDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAliasDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAliasDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAliasDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAliasDecodeErrorZ;



/**
 * Details about a node in the network, known from the network announcement.
 */
typedef struct MUST_USE_STRUCT LDKNodeInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeNodeInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKNodeInfo;

/**
 * The contents of CResult_NodeInfoDecodeErrorZ
 */
typedef union LDKCResult_NodeInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeInfoDecodeErrorZPtr;

/**
 * A CResult_NodeInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NodeInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeInfoDecodeErrorZ {
   /**
    * The contents of this CResult_NodeInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeInfoDecodeErrorZ;

/**
 * The contents of CResult_NetworkGraphDecodeErrorZ
 */
typedef union LDKCResult_NetworkGraphDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNetworkGraph *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NetworkGraphDecodeErrorZPtr;

/**
 * A CResult_NetworkGraphDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::routing::gossip::NetworkGraph on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NetworkGraphDecodeErrorZ {
   /**
    * The contents of this CResult_NetworkGraphDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NetworkGraphDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NetworkGraphDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NetworkGraphDecodeErrorZ;

/**
 * An enum which can either contain a crate::c_types::derived::CVec_SocketAddressZ or not
 */
typedef enum LDKCOption_CVec_SocketAddressZZ_Tag {
   /**
    * When we're in this state, this COption_CVec_SocketAddressZZ contains a crate::c_types::derived::CVec_SocketAddressZ
    */
   LDKCOption_CVec_SocketAddressZZ_Some,
   /**
    * When we're in this state, this COption_CVec_SocketAddressZZ contains nothing
    */
   LDKCOption_CVec_SocketAddressZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CVec_SocketAddressZZ_Sentinel,
} LDKCOption_CVec_SocketAddressZZ_Tag;

typedef struct LDKCOption_CVec_SocketAddressZZ {
   LDKCOption_CVec_SocketAddressZZ_Tag tag;
   union {
      struct {
         struct LDKCVec_SocketAddressZ some;
      };
   };
} LDKCOption_CVec_SocketAddressZZ;



/**
 * The parameters required to derive a channel signer via [`SignerProvider`].
 */
typedef struct MUST_USE_STRUCT LDKChannelDerivationParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelDerivationParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelDerivationParameters;

/**
 * The contents of CResult_ChannelDerivationParametersDecodeErrorZ
 */
typedef union LDKCResult_ChannelDerivationParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelDerivationParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelDerivationParametersDecodeErrorZPtr;

/**
 * A CResult_ChannelDerivationParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::events::bump_transaction::ChannelDerivationParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelDerivationParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelDerivationParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelDerivationParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelDerivationParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelDerivationParametersDecodeErrorZ;

/**
 * The contents of CResult_HTLCDescriptorDecodeErrorZ
 */
typedef union LDKCResult_HTLCDescriptorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCDescriptor *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCDescriptorDecodeErrorZPtr;

/**
 * A CResult_HTLCDescriptorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::events::bump_transaction::HTLCDescriptor on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCDescriptorDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCDescriptorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCDescriptorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCDescriptorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCDescriptorDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::chan_utils::HTLCOutputInCommitments of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_HTLCOutputInCommitmentZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKHTLCOutputInCommitment *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_HTLCOutputInCommitmentZ;

/**
 * A dynamically-allocated array of crate::lightning::events::bump_transaction::HTLCDescriptors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_HTLCDescriptorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKHTLCDescriptor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_HTLCDescriptorZ;



/**
 * An unspent transaction output that is available to spend resulting from a successful
 * [`CoinSelection`] attempt.
 */
typedef struct MUST_USE_STRUCT LDKUtxo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUtxo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUtxo;

/**
 * A dynamically-allocated array of crate::lightning::events::bump_transaction::Utxos of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UtxoZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUtxo *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UtxoZ;

/**
 * An enum which can either contain a crate::c_types::TxOut or not
 */
typedef enum LDKCOption_TxOutZ_Tag {
   /**
    * When we're in this state, this COption_TxOutZ contains a crate::c_types::TxOut
    */
   LDKCOption_TxOutZ_Some,
   /**
    * When we're in this state, this COption_TxOutZ contains nothing
    */
   LDKCOption_TxOutZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_TxOutZ_Sentinel,
} LDKCOption_TxOutZ_Tag;

typedef struct LDKCOption_TxOutZ {
   LDKCOption_TxOutZ_Tag tag;
   union {
      struct {
         struct LDKTxOut some;
      };
   };
} LDKCOption_TxOutZ;



/**
 * An input that must be included in a transaction when performing coin selection through
 * [`CoinSelectionSource::select_confirmed_utxos`]. It is guaranteed to be a SegWit input, so it
 * must have an empty [`TxIn::script_sig`] when spent.
 */
typedef struct MUST_USE_STRUCT LDKInput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInput;

/**
 * A dynamically-allocated array of crate::lightning::events::bump_transaction::Inputs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_InputZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKInput *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_InputZ;



/**
 * The result of a successful coin selection attempt for a transaction requiring additional UTXOs
 * to cover its fees.
 */
typedef struct MUST_USE_STRUCT LDKCoinSelection {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCoinSelection *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCoinSelection;

/**
 * The contents of CResult_CoinSelectionNoneZ
 */
typedef union LDKCResult_CoinSelectionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCoinSelection *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CoinSelectionNoneZPtr;

/**
 * A CResult_CoinSelectionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::events::bump_transaction::CoinSelection on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CoinSelectionNoneZ {
   /**
    * The contents of this CResult_CoinSelectionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CoinSelectionNoneZPtr contents;
   /**
    * Whether this CResult_CoinSelectionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CoinSelectionNoneZ;

/**
 * The contents of CResult_CVec_UtxoZNoneZ
 */
typedef union LDKCResult_CVec_UtxoZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_UtxoZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_UtxoZNoneZPtr;

/**
 * A CResult_CVec_UtxoZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_UtxoZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_UtxoZNoneZ {
   /**
    * The contents of this CResult_CVec_UtxoZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_UtxoZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_UtxoZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_UtxoZNoneZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u64u16Z {
   /**
    * The element at position 0
    */
   uint64_t a;
   /**
    * The element at position 1
    */
   uint16_t b;
} LDKC2Tuple_u64u16Z;

/**
 * An enum which can either contain a crate::c_types::derived::C2Tuple_u64u16Z or not
 */
typedef enum LDKCOption_C2Tuple_u64u16ZZ_Tag {
   /**
    * When we're in this state, this COption_C2Tuple_u64u16ZZ contains a crate::c_types::derived::C2Tuple_u64u16Z
    */
   LDKCOption_C2Tuple_u64u16ZZ_Some,
   /**
    * When we're in this state, this COption_C2Tuple_u64u16ZZ contains nothing
    */
   LDKCOption_C2Tuple_u64u16ZZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_C2Tuple_u64u16ZZ_Sentinel,
} LDKCOption_C2Tuple_u64u16ZZ_Tag;

typedef struct LDKCOption_C2Tuple_u64u16ZZ {
   LDKCOption_C2Tuple_u64u16ZZ_Tag tag;
   union {
      struct {
         struct LDKC2Tuple_u64u16Z some;
      };
   };
} LDKCOption_C2Tuple_u64u16ZZ;

/**
 * An enum which can either contain a crate::lightning::ln::channelmanager::ChannelShutdownState or not
 */
typedef enum LDKCOption_ChannelShutdownStateZ_Tag {
   /**
    * When we're in this state, this COption_ChannelShutdownStateZ contains a crate::lightning::ln::channelmanager::ChannelShutdownState
    */
   LDKCOption_ChannelShutdownStateZ_Some,
   /**
    * When we're in this state, this COption_ChannelShutdownStateZ contains nothing
    */
   LDKCOption_ChannelShutdownStateZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ChannelShutdownStateZ_Sentinel,
} LDKCOption_ChannelShutdownStateZ_Tag;

typedef struct LDKCOption_ChannelShutdownStateZ {
   LDKCOption_ChannelShutdownStateZ_Tag tag;
   union {
      struct {
         enum LDKChannelShutdownState some;
      };
   };
} LDKCOption_ChannelShutdownStateZ;

/**
 * The contents of CResult_ThirtyTwoBytesAPIErrorZ
 */
typedef union LDKCResult_ThirtyTwoBytesAPIErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKAPIError *err;
} LDKCResult_ThirtyTwoBytesAPIErrorZPtr;

/**
 * A CResult_ThirtyTwoBytesAPIErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::util::errors::APIError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ThirtyTwoBytesAPIErrorZ {
   /**
    * The contents of this CResult_ThirtyTwoBytesAPIErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ThirtyTwoBytesAPIErrorZPtr contents;
   /**
    * Whether this CResult_ThirtyTwoBytesAPIErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ThirtyTwoBytesAPIErrorZ;

/**
 * Used by [`ChannelManager::list_recent_payments`] to express the status of recent payments.
 * These include payments that have yet to find a successful path, or have unresolved HTLCs.
 */
typedef enum LDKRecentPaymentDetails_Tag {
   /**
    * When an invoice was requested and thus a payment has not yet been sent.
    */
   LDKRecentPaymentDetails_AwaitingInvoice,
   /**
    * When a payment is still being sent and awaiting successful delivery.
    */
   LDKRecentPaymentDetails_Pending,
   /**
    * When a pending payment is fulfilled, we continue tracking it until all pending HTLCs have
    * been resolved. Upon receiving [`Event::PaymentSent`], we delay for a few minutes before the
    * payment is removed from tracking.
    */
   LDKRecentPaymentDetails_Fulfilled,
   /**
    * After a payment's retries are exhausted per the provided [`Retry`], or it is explicitly
    * abandoned via [`ChannelManager::abandon_payment`], it is marked as abandoned until all
    * pending HTLCs for this payment resolve and an [`Event::PaymentFailed`] is generated.
    */
   LDKRecentPaymentDetails_Abandoned,
   /**
    * Must be last for serialization purposes
    */
   LDKRecentPaymentDetails_Sentinel,
} LDKRecentPaymentDetails_Tag;

typedef struct LDKRecentPaymentDetails_LDKAwaitingInvoice_Body {
   /**
    * A user-provided identifier in [`ChannelManager::send_payment`] used to uniquely identify
    * a payment and ensure idempotency in LDK.
    */
   struct LDKThirtyTwoBytes payment_id;
} LDKRecentPaymentDetails_LDKAwaitingInvoice_Body;

typedef struct LDKRecentPaymentDetails_LDKPending_Body {
   /**
    * A user-provided identifier in [`ChannelManager::send_payment`] used to uniquely identify
    * a payment and ensure idempotency in LDK.
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * Hash of the payment that is currently being sent but has yet to be fulfilled or
    * abandoned.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Total amount (in msat, excluding fees) across all paths for this payment,
    * not just the amount currently inflight.
    */
   uint64_t total_msat;
} LDKRecentPaymentDetails_LDKPending_Body;

typedef struct LDKRecentPaymentDetails_LDKFulfilled_Body {
   /**
    * A user-provided identifier in [`ChannelManager::send_payment`] used to uniquely identify
    * a payment and ensure idempotency in LDK.
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * Hash of the payment that was claimed. `None` for serializations of [`ChannelManager`]
    * made before LDK version 0.0.104.
    */
   struct LDKCOption_ThirtyTwoBytesZ payment_hash;
} LDKRecentPaymentDetails_LDKFulfilled_Body;

typedef struct LDKRecentPaymentDetails_LDKAbandoned_Body {
   /**
    * A user-provided identifier in [`ChannelManager::send_payment`] used to uniquely identify
    * a payment and ensure idempotency in LDK.
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * Hash of the payment that we have given up trying to send.
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKRecentPaymentDetails_LDKAbandoned_Body;

typedef struct MUST_USE_STRUCT LDKRecentPaymentDetails {
   LDKRecentPaymentDetails_Tag tag;
   union {
      LDKRecentPaymentDetails_LDKAwaitingInvoice_Body awaiting_invoice;
      LDKRecentPaymentDetails_LDKPending_Body pending;
      LDKRecentPaymentDetails_LDKFulfilled_Body fulfilled;
      LDKRecentPaymentDetails_LDKAbandoned_Body abandoned;
   };
} LDKRecentPaymentDetails;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::RecentPaymentDetailss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_RecentPaymentDetailsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKRecentPaymentDetails *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_RecentPaymentDetailsZ;

/**
 * If a payment fails to send with [`ChannelManager::send_payment_with_route`], it can be in one
 * of several states. This enum is returned as the Err() type describing which state the payment
 * is in, see the description of individual enum states for more.
 *
 * [`ChannelManager::send_payment_with_route`]: crate::ln::channelmanager::ChannelManager::send_payment_with_route
 */
typedef enum LDKPaymentSendFailure_Tag {
   /**
    * A parameter which was passed to send_payment was invalid, preventing us from attempting to
    * send the payment at all.
    *
    * You can freely resend the payment in full (with the parameter error fixed).
    *
    * Because the payment failed outright, no payment tracking is done and no
    * [`Event::PaymentPathFailed`] or [`Event::PaymentFailed`] events will be generated.
    *
    * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
    * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
    */
   LDKPaymentSendFailure_ParameterError,
   /**
    * A parameter in a single path which was passed to send_payment was invalid, preventing us
    * from attempting to send the payment at all.
    *
    * You can freely resend the payment in full (with the parameter error fixed).
    *
    * Because the payment failed outright, no payment tracking is done and no
    * [`Event::PaymentPathFailed`] or [`Event::PaymentFailed`] events will be generated.
    *
    * The results here are ordered the same as the paths in the route object which was passed to
    * send_payment.
    *
    * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
    * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
    */
   LDKPaymentSendFailure_PathParameterError,
   /**
    * All paths which were attempted failed to send, with no channel state change taking place.
    * You can freely resend the payment in full (though you probably want to do so over different
    * paths than the ones selected).
    *
    * Because the payment failed outright, no payment tracking is done and no
    * [`Event::PaymentPathFailed`] or [`Event::PaymentFailed`] events will be generated.
    *
    * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
    * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
    */
   LDKPaymentSendFailure_AllFailedResendSafe,
   /**
    * Indicates that a payment for the provided [`PaymentId`] is already in-flight and has not
    * yet completed (i.e. generated an [`Event::PaymentSent`] or [`Event::PaymentFailed`]).
    *
    * [`PaymentId`]: crate::ln::channelmanager::PaymentId
    * [`Event::PaymentSent`]: crate::events::Event::PaymentSent
    * [`Event::PaymentFailed`]: crate::events::Event::PaymentFailed
    */
   LDKPaymentSendFailure_DuplicatePayment,
   /**
    * Some paths that were attempted failed to send, though some paths may have succeeded. At least
    * some paths have irrevocably committed to the HTLC.
    *
    * The results here are ordered the same as the paths in the route object that was passed to
    * send_payment.
    *
    * Any entries that contain `Err(APIError::MonitorUpdateInprogress)` will send once a
    * [`MonitorEvent::Completed`] is provided for the next-hop channel with the latest update_id.
    *
    * [`MonitorEvent::Completed`]: crate::chain::channelmonitor::MonitorEvent::Completed
    */
   LDKPaymentSendFailure_PartialFailure,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentSendFailure_Sentinel,
} LDKPaymentSendFailure_Tag;

typedef struct LDKPaymentSendFailure_LDKPartialFailure_Body {
   /**
    * The errors themselves, in the same order as the paths from the route.
    */
   struct LDKCVec_CResult_NoneAPIErrorZZ results;
   /**
    * If some paths failed without irrevocably committing to the new HTLC(s), this will
    * contain a [`RouteParameters`] object for the failing paths.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRouteParameters failed_paths_retry;
   /**
    * The payment id for the payment, which is now at least partially pending.
    */
   struct LDKThirtyTwoBytes payment_id;
} LDKPaymentSendFailure_LDKPartialFailure_Body;

typedef struct MUST_USE_STRUCT LDKPaymentSendFailure {
   LDKPaymentSendFailure_Tag tag;
   union {
      struct {
         struct LDKAPIError parameter_error;
      };
      struct {
         struct LDKCVec_CResult_NoneAPIErrorZZ path_parameter_error;
      };
      struct {
         struct LDKCVec_APIErrorZ all_failed_resend_safe;
      };
      LDKPaymentSendFailure_LDKPartialFailure_Body partial_failure;
   };
} LDKPaymentSendFailure;

/**
 * The contents of CResult_NonePaymentSendFailureZ
 */
typedef union LDKCResult_NonePaymentSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_NonePaymentSendFailureZPtr;

/**
 * A CResult_NonePaymentSendFailureZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentSendFailureZ {
   /**
    * The contents of this CResult_NonePaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_NonePaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentSendFailureZ;

/**
 * The contents of CResult_NoneRetryableSendFailureZ
 */
typedef union LDKCResult_NoneRetryableSendFailureZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKRetryableSendFailure *err;
} LDKCResult_NoneRetryableSendFailureZPtr;

/**
 * A CResult_NoneRetryableSendFailureZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneRetryableSendFailureZ {
   /**
    * The contents of this CResult_NoneRetryableSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneRetryableSendFailureZPtr contents;
   /**
    * Whether this CResult_NoneRetryableSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneRetryableSendFailureZ;

/**
 * The contents of CResult_ThirtyTwoBytesPaymentSendFailureZ
 */
typedef union LDKCResult_ThirtyTwoBytesPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_ThirtyTwoBytesPaymentSendFailureZPtr;

/**
 * A CResult_ThirtyTwoBytesPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ {
   /**
    * The contents of this CResult_ThirtyTwoBytesPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ThirtyTwoBytesPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_ThirtyTwoBytesPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ThirtyTwoBytesPaymentSendFailureZ;

/**
 * The contents of CResult_ThirtyTwoBytesRetryableSendFailureZ
 */
typedef union LDKCResult_ThirtyTwoBytesRetryableSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKRetryableSendFailure *err;
} LDKCResult_ThirtyTwoBytesRetryableSendFailureZPtr;

/**
 * A CResult_ThirtyTwoBytesRetryableSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning::ln::outbound_payment::RetryableSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ {
   /**
    * The contents of this CResult_ThirtyTwoBytesRetryableSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ThirtyTwoBytesRetryableSendFailureZPtr contents;
   /**
    * Whether this CResult_ThirtyTwoBytesRetryableSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ThirtyTwoBytesRetryableSendFailureZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
} LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ;

/**
 * The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ
 */
typedef union LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentSendFailure *err;
} LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr;

/**
 * A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a crate::lightning::ln::outbound_payment::PaymentSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ {
   /**
    * The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ;

/**
 * Indicates that we failed to send a payment probe. Further errors may be surfaced later via
 * [`Event::ProbeFailed`].
 *
 * [`Event::ProbeFailed`]: crate::events::Event::ProbeFailed
 */
typedef enum LDKProbeSendFailure_Tag {
   /**
    * We were unable to find a route to the destination.
    */
   LDKProbeSendFailure_RouteNotFound,
   /**
    * We failed to send the payment probes.
    */
   LDKProbeSendFailure_SendingFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKProbeSendFailure_Sentinel,
} LDKProbeSendFailure_Tag;

typedef struct MUST_USE_STRUCT LDKProbeSendFailure {
   LDKProbeSendFailure_Tag tag;
   union {
      struct {
         struct LDKPaymentSendFailure sending_failed;
      };
   };
} LDKProbeSendFailure;

/**
 * The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ
 */
typedef union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKProbeSendFailure *err;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr;

/**
 * A CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ on success and a crate::lightning::ln::outbound_payment::ProbeSendFailure on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKPublicKey b;
} LDKC2Tuple_ThirtyTwoBytesPublicKeyZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesPublicKeyZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ;

/**
 * The contents of CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ
 */
typedef union LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr;

/**
 * A CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ;



/**
 * Information needed for constructing an invoice route hint for this channel.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyForwardingInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyForwardingInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyForwardingInfo;

/**
 * The contents of CResult_CounterpartyForwardingInfoDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyForwardingInfo *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr;

/**
 * A CResult_CounterpartyForwardingInfoDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::CounterpartyForwardingInfo on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyForwardingInfoDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyForwardingInfoDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyForwardingInfoDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyForwardingInfoDecodeErrorZ;



/**
 * Channel parameters which apply to our counterparty. These are split out from [`ChannelDetails`]
 * to better separate parameters.
 */
typedef struct MUST_USE_STRUCT LDKChannelCounterparty {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelCounterparty *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelCounterparty;

/**
 * The contents of CResult_ChannelCounterpartyDecodeErrorZ
 */
typedef union LDKCResult_ChannelCounterpartyDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelCounterparty *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelCounterpartyDecodeErrorZPtr;

/**
 * A CResult_ChannelCounterpartyDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelCounterparty on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelCounterpartyDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelCounterpartyDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelCounterpartyDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelCounterpartyDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelCounterpartyDecodeErrorZ;

/**
 * The contents of CResult_ChannelDetailsDecodeErrorZ
 */
typedef union LDKCResult_ChannelDetailsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelDetails *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelDetailsDecodeErrorZPtr;

/**
 * A CResult_ChannelDetailsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelDetails on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelDetailsDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelDetailsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelDetailsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelDetailsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelDetailsDecodeErrorZ;



/**
 * Route hints used in constructing invoices for [phantom node payents].
 *
 * [phantom node payments]: crate::sign::PhantomKeysManager
 */
typedef struct MUST_USE_STRUCT LDKPhantomRouteHints {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomRouteHints *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomRouteHints;

/**
 * The contents of CResult_PhantomRouteHintsDecodeErrorZ
 */
typedef union LDKCResult_PhantomRouteHintsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPhantomRouteHints *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PhantomRouteHintsDecodeErrorZPtr;

/**
 * A CResult_PhantomRouteHintsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::PhantomRouteHints on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PhantomRouteHintsDecodeErrorZ {
   /**
    * The contents of this CResult_PhantomRouteHintsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PhantomRouteHintsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PhantomRouteHintsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PhantomRouteHintsDecodeErrorZ;

/**
 * The contents of CResult_ChannelShutdownStateDecodeErrorZ
 */
typedef union LDKCResult_ChannelShutdownStateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKChannelShutdownState *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelShutdownStateDecodeErrorZPtr;

/**
 * A CResult_ChannelShutdownStateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::channelmanager::ChannelShutdownState on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelShutdownStateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelShutdownStateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelShutdownStateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelShutdownStateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelShutdownStateDecodeErrorZ;



/**
 * A ChannelMonitor handles chain events (blocks connected and disconnected) and generates
 * on-chain transactions to ensure no loss of funds occurs.
 *
 * You MUST ensure that no ChannelMonitors for a given channel anywhere contain out-of-date
 * information and are actively monitoring the chain.
 *
 * Note that the deserializer is only implemented for (BlockHash, ChannelMonitor), which
 * tells you the last block hash which was block_connect()ed. You MUST rescan any blocks along
 * the \"reorg path\" (ie disconnecting blocks until you find a common ancestor from both the
 * returned block hash and the the current chain and then reconnecting blocks to get to the
 * best chain) upon deserializing the object!
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitor;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::ChannelMonitors of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ChannelMonitorZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKChannelMonitor *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ChannelMonitorZ;



/**
 * An update generated by the underlying channel itself which contains some new information the
 * [`ChannelMonitor`] should be made aware of.
 *
 * Because this represents only a small number of updates to the underlying state, it is generally
 * much smaller than a full [`ChannelMonitor`]. However, for large single commitment transaction
 * updates (e.g. ones during which there are hundreds of HTLCs pending on the commitment
 * transaction), a single update may reach upwards of 1 MiB in serialized size.
 */
typedef struct MUST_USE_STRUCT LDKChannelMonitorUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelMonitorUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelMonitorUpdate;

/**
 * The `Watch` trait defines behavior for watching on-chain activity pertaining to channels as
 * blocks are connected and disconnected.
 *
 * Each channel is associated with a [`ChannelMonitor`]. Implementations of this trait are
 * responsible for maintaining a set of monitors such that they can be updated as channel state
 * changes. On each update, *all copies* of a [`ChannelMonitor`] must be updated and the update
 * persisted to disk to ensure that the latest [`ChannelMonitor`] state can be reloaded if the
 * application crashes.
 *
 * See method documentation and [`ChannelMonitorUpdateStatus`] for specific requirements.
 */
typedef struct LDKWatch {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Watches a channel identified by `funding_txo` using `monitor`.
    *
    * Implementations are responsible for watching the chain for the funding transaction along
    * with any spends of outputs returned by [`get_outputs_to_watch`]. In practice, this means
    * calling [`block_connected`] and [`block_disconnected`] on the monitor.
    *
    * A return of `Err(())` indicates that the channel should immediately be force-closed without
    * broadcasting the funding transaction.
    *
    * If the given `funding_txo` has previously been registered via `watch_channel`, `Err(())`
    * must be returned.
    *
    * [`get_outputs_to_watch`]: channelmonitor::ChannelMonitor::get_outputs_to_watch
    * [`block_connected`]: channelmonitor::ChannelMonitor::block_connected
    * [`block_disconnected`]: channelmonitor::ChannelMonitor::block_disconnected
    */
   struct LDKCResult_ChannelMonitorUpdateStatusNoneZ (*watch_channel)(const void *this_arg, struct LDKOutPoint funding_txo, struct LDKChannelMonitor monitor);
   /**
    * Updates a channel identified by `funding_txo` by applying `update` to its monitor.
    *
    * Implementations must call [`ChannelMonitor::update_monitor`] with the given update. This
    * may fail (returning an `Err(())`), in which case this should return
    * [`ChannelMonitorUpdateStatus::InProgress`] (and the update should never complete). This
    * generally implies the channel has been closed (either by the funding outpoint being spent
    * on-chain or the [`ChannelMonitor`] having decided to do so and broadcasted a transaction),
    * and the [`ChannelManager`] state will be updated once it sees the funding spend on-chain.
    *
    * In general, persistence failures should be retried after returning
    * [`ChannelMonitorUpdateStatus::InProgress`] and eventually complete. If a failure truly
    * cannot be retried, the node should shut down immediately after returning
    * [`ChannelMonitorUpdateStatus::UnrecoverableError`], see its documentation for more info.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   enum LDKChannelMonitorUpdateStatus (*update_channel)(const void *this_arg, struct LDKOutPoint funding_txo, const struct LDKChannelMonitorUpdate *NONNULL_PTR update);
   /**
    * Returns any monitor events since the last call. Subsequent calls must only return new
    * events.
    *
    * Note that after any block- or transaction-connection calls to a [`ChannelMonitor`], no
    * further events may be returned here until the [`ChannelMonitor`] has been fully persisted
    * to disk.
    *
    * For details on asynchronous [`ChannelMonitor`] updating and returning
    * [`MonitorEvent::Completed`] here, see [`ChannelMonitorUpdateStatus::InProgress`].
    */
   struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ (*release_pending_monitor_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWatch;

/**
 * A dynamically-allocated array of crate::c_types::Transactions of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKTransaction *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionZ;

/**
 * An interface to send a transaction to the Bitcoin network.
 */
typedef struct LDKBroadcasterInterface {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Sends a list of transactions out to (hopefully) be mined.
    * This only needs to handle the actual broadcasting of transactions, LDK will automatically
    * rebroadcast transactions that haven't made it into a block.
    *
    * In some cases LDK may attempt to broadcast a transaction which double-spends another
    * and this isn't a bug and can be safely ignored.
    *
    * If more than one transaction is given, these transactions should be considered to be a
    * package and broadcast together. Some of the transactions may or may not depend on each other,
    * be sure to manage both cases correctly.
    *
    * Bitcoin transaction packages are defined in BIP 331 and here:
    * https://github.com/bitcoin/bitcoin/blob/master/doc/policy/packages.md
    */
   void (*broadcast_transactions)(const void *this_arg, struct LDKCVec_TransactionZ txs);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKBroadcasterInterface;

/**
 * A trait that describes a source of entropy.
 */
typedef struct LDKEntropySource {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets a unique, cryptographically-secure, random 32-byte value. This method must return a
    * different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*get_secure_random_bytes)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEntropySource;

/**
 * A "slice" referencing some byte array. This is simply a length-tagged pointer which does not
 * own the memory pointed to by data.
 */
typedef struct LDKu8slice {
   /**
    * A pointer to the byte buffer
    */
   const uint8_t *data;
   /**
    * The number of bytes pointed to by `data`.
    */
   uintptr_t datalen;
} LDKu8slice;



/**
 * A semantically valid [`InvoiceRequest`] that hasn't been signed.
 *
 * # Serialization
 *
 * This is serialized as a TLV stream, which includes TLV records from the originating message. As
 * such, it may include unknown, odd TLV records.
 */
typedef struct MUST_USE_STRUCT LDKUnsignedInvoiceRequest {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedInvoiceRequest *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedInvoiceRequest;



/**
 * A semantically valid [`Bolt12Invoice`] that hasn't been signed.
 *
 * # Serialization
 *
 * This is serialized as a TLV stream, which includes TLV records from the originating message. As
 * such, it may include unknown, odd TLV records.
 */
typedef struct MUST_USE_STRUCT LDKUnsignedBolt12Invoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedBolt12Invoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedBolt12Invoice;



/**
 * The unsigned part of a [`channel_update`] message.
 *
 * [`channel_update`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
 */
typedef struct MUST_USE_STRUCT LDKUnsignedChannelUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedChannelUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedChannelUpdate;



/**
 * The unsigned part of a [`node_announcement`] message.
 *
 * [`node_announcement`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-node_announcement-message
 */
typedef struct MUST_USE_STRUCT LDKUnsignedNodeAnnouncement {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUnsignedNodeAnnouncement *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUnsignedNodeAnnouncement;

/**
 * Represents the set of gossip messages that require a signature from a node's identity key.
 */
typedef enum LDKUnsignedGossipMessage_Tag {
   /**
    * An unsigned channel announcement.
    */
   LDKUnsignedGossipMessage_ChannelAnnouncement,
   /**
    * An unsigned channel update.
    */
   LDKUnsignedGossipMessage_ChannelUpdate,
   /**
    * An unsigned node announcement.
    */
   LDKUnsignedGossipMessage_NodeAnnouncement,
   /**
    * Must be last for serialization purposes
    */
   LDKUnsignedGossipMessage_Sentinel,
} LDKUnsignedGossipMessage_Tag;

typedef struct MUST_USE_STRUCT LDKUnsignedGossipMessage {
   LDKUnsignedGossipMessage_Tag tag;
   union {
      struct {
         struct LDKUnsignedChannelAnnouncement channel_announcement;
      };
      struct {
         struct LDKUnsignedChannelUpdate channel_update;
      };
      struct {
         struct LDKUnsignedNodeAnnouncement node_announcement;
      };
   };
} LDKUnsignedGossipMessage;

/**
 * A trait that can handle cryptographic operations at the scope level of a node.
 */
typedef struct LDKNodeSigner {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Get secret key material as bytes for use in encrypting and decrypting inbound payment data.
    *
    * If the implementor of this trait supports [phantom node payments], then every node that is
    * intended to be included in the phantom invoice route hints must return the same value from
    * this method.
    *
    * This method must return the same value each time it is called.
    *
    * [phantom node payments]: PhantomKeysManager
    */
   struct LDKThirtyTwoBytes (*get_inbound_payment_key_material)(const void *this_arg);
   /**
    * Get node id based on the provided [`Recipient`].
    *
    * This method must return the same value each time it is called with a given [`Recipient`]
    * parameter.
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    */
   struct LDKCResult_PublicKeyNoneZ (*get_node_id)(const void *this_arg, enum LDKRecipient recipient);
   /**
    * Gets the ECDH shared secret of our node secret and `other_key`, multiplying by `tweak` if
    * one is provided. Note that this tweak can be applied to `other_key` instead of our node
    * secret, though this is less efficient.
    *
    * Note that if this fails while attempting to forward an HTLC, LDK will panic. The error
    * should be resolved to allow LDK to resume forwarding HTLCs.
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    */
   struct LDKCResult_ThirtyTwoBytesNoneZ (*ecdh)(const void *this_arg, enum LDKRecipient recipient, struct LDKPublicKey other_key, struct LDKCOption_BigEndianScalarZ tweak);
   /**
    * Sign an invoice.
    *
    * By parameterizing by the raw invoice bytes instead of the hash, we allow implementors of
    * this trait to parse the invoice and make sure they're signing what they expect, rather than
    * blindly signing the hash.
    *
    * The `hrp_bytes` are ASCII bytes, while the `invoice_data` is base32.
    *
    * The secret key used to sign the invoice is dependent on the [`Recipient`].
    *
    * Errors if the [`Recipient`] variant is not supported by the implementation.
    */
   struct LDKCResult_RecoverableSignatureNoneZ (*sign_invoice)(const void *this_arg, struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z invoice_data, enum LDKRecipient recipient);
   /**
    * Signs the [`TaggedHash`] of a BOLT 12 invoice request.
    *
    * May be called by a function passed to [`UnsignedInvoiceRequest::sign`] where
    * `invoice_request` is the callee.
    *
    * Implementors may check that the `invoice_request` is expected rather than blindly signing
    * the tagged hash. An `Ok` result should sign `invoice_request.tagged_hash().as_digest()` with
    * the node's signing key or an ephemeral key to preserve privacy, whichever is associated with
    * [`UnsignedInvoiceRequest::payer_id`].
    *
    * [`TaggedHash`]: crate::offers::merkle::TaggedHash
    */
   struct LDKCResult_SchnorrSignatureNoneZ (*sign_bolt12_invoice_request)(const void *this_arg, const struct LDKUnsignedInvoiceRequest *NONNULL_PTR invoice_request);
   /**
    * Signs the [`TaggedHash`] of a BOLT 12 invoice.
    *
    * May be called by a function passed to [`UnsignedBolt12Invoice::sign`] where `invoice` is the
    * callee.
    *
    * Implementors may check that the `invoice` is expected rather than blindly signing the tagged
    * hash. An `Ok` result should sign `invoice.tagged_hash().as_digest()` with the node's signing
    * key or an ephemeral key to preserve privacy, whichever is associated with
    * [`UnsignedBolt12Invoice::signing_pubkey`].
    *
    * [`TaggedHash`]: crate::offers::merkle::TaggedHash
    */
   struct LDKCResult_SchnorrSignatureNoneZ (*sign_bolt12_invoice)(const void *this_arg, const struct LDKUnsignedBolt12Invoice *NONNULL_PTR invoice);
   /**
    * Sign a gossip message.
    *
    * Note that if this fails, LDK may panic and the message will not be broadcast to the network
    * or a possible channel counterparty. If LDK panics, the error should be resolved to allow the
    * message to be broadcast, as otherwise it may prevent one from receiving funds over the
    * corresponding channel.
    */
   struct LDKCResult_ECDSASignatureNoneZ (*sign_gossip_message)(const void *this_arg, struct LDKUnsignedGossipMessage msg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKNodeSigner;

/**
 * A trait that can return signer instances for individual channels.
 */
typedef struct LDKSignerProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Generates a unique `channel_keys_id` that can be used to obtain a [`Self::Signer`] through
    * [`SignerProvider::derive_channel_signer`]. The `user_channel_id` is provided to allow
    * implementations of [`SignerProvider`] to maintain a mapping between itself and the generated
    * `channel_keys_id`.
    *
    * This method must return a different value each time it is called.
    */
   struct LDKThirtyTwoBytes (*generate_channel_keys_id)(const void *this_arg, bool inbound, uint64_t channel_value_satoshis, struct LDKU128 user_channel_id);
   /**
    * Derives the private key material backing a `Signer`.
    *
    * To derive a new `Signer`, a fresh `channel_keys_id` should be obtained through
    * [`SignerProvider::generate_channel_keys_id`]. Otherwise, an existing `Signer` can be
    * re-derived from its `channel_keys_id`, which can be obtained through its trait method
    * [`ChannelSigner::channel_keys_id`].
    */
   struct LDKWriteableEcdsaChannelSigner (*derive_channel_signer)(const void *this_arg, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id);
   /**
    * Reads a [`Signer`] for this [`SignerProvider`] from the given input stream.
    * This is only called during deserialization of other objects which contain
    * [`WriteableEcdsaChannelSigner`]-implementing objects (i.e., [`ChannelMonitor`]s and [`ChannelManager`]s).
    * The bytes are exactly those which `<Self::Signer as Writeable>::write()` writes, and
    * contain no versioning scheme. You may wish to include your own version prefix and ensure
    * you've read all of the provided bytes to ensure no corruption occurred.
    *
    * This method is slowly being phased out -- it will only be called when reading objects
    * written by LDK versions prior to 0.0.113.
    *
    * [`Signer`]: Self::Signer
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ (*read_chan_signer)(const void *this_arg, struct LDKu8slice reader);
   /**
    * Get a script pubkey which we send funds to when claiming on-chain contestable outputs.
    *
    * If this function returns an error, this will result in a channel failing to open.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCResult_CVec_u8ZNoneZ (*get_destination_script)(const void *this_arg);
   /**
    * Get a script pubkey which we will send funds to when closing a channel.
    *
    * If this function returns an error, this will result in a channel failing to open or close.
    * In the event of a failure when the counterparty is initiating a close, this can result in a
    * channel force close.
    *
    * This method should return a different value each time it is called, to avoid linking
    * on-chain funds across channels as controlled to the same user.
    */
   struct LDKCResult_ShutdownScriptNoneZ (*get_shutdown_scriptpubkey)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSignerProvider;

/**
 * A trait which should be implemented to provide feerate information on a number of time
 * horizons.
 *
 * If access to a local mempool is not feasible, feerate estimates should be fetched from a set of
 * third-parties hosting them. Note that this enables them to affect the propagation of your
 * pre-signed transactions at any time and therefore endangers the safety of channels funds. It
 * should be considered carefully as a deployment.
 *
 * Note that all of the functions implemented here *must* be reentrant-safe (obviously - they're
 * called from inside the library in response to chain events, P2P events, or timer events).
 */
typedef struct LDKFeeEstimator {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets estimated satoshis of fee required per 1000 Weight-Units.
    *
    * LDK will wrap this method and ensure that the value returned is no smaller than 253
    * (ie 1 satoshi-per-byte rounded up to ensure later round-downs don't put us below 1 satoshi-per-byte).
    *
    * The following unit conversions can be used to convert to sats/KW:
    *  * satoshis-per-byte * 250
    *  * satoshis-per-kbyte / 4
    */
   uint32_t (*get_est_sat_per_1000_weight)(const void *this_arg, enum LDKConfirmationTarget confirmation_target);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFeeEstimator;

/**
 * A trait defining behavior for routing a payment.
 */
typedef struct LDKRouter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Finds a [`Route`] for a payment between the given `payer` and a payee.
    *
    * The `payee` and the payment's value are given in [`RouteParameters::payment_params`]
    * and [`RouteParameters::final_value_msat`], respectively.
    *
    * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_RouteLightningErrorZ (*find_route)(const void *this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs);
   /**
    * Finds a [`Route`] for a payment between the given `payer` and a payee.
    *
    * The `payee` and the payment's value are given in [`RouteParameters::payment_params`]
    * and [`RouteParameters::final_value_msat`], respectively.
    *
    * Includes a [`PaymentHash`] and a [`PaymentId`] to be able to correlate the request with a specific
    * payment.
    *
    * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKCResult_RouteLightningErrorZ (*find_route_with_id)(const void *this_arg, struct LDKPublicKey payer, const struct LDKRouteParameters *NONNULL_PTR route_params, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKInFlightHtlcs inflight_htlcs, struct LDKThirtyTwoBytes _payment_hash, struct LDKThirtyTwoBytes _payment_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRouter;



/**
 * Manager which keeps track of a number of channels and sends messages to the appropriate
 * channel, also tracking HTLC preimages and forwarding onion packets appropriately.
 *
 * Implements [`ChannelMessageHandler`], handling the multi-channel parts and passing things through
 * to individual Channels.
 *
 * Implements [`Writeable`] to write out all channel state to disk. Implies [`peer_disconnected`] for
 * all peers during write/read (though does not modify this instance, only the instance being
 * serialized). This will result in any channels which have not yet exchanged [`funding_created`] (i.e.,
 * called [`funding_transaction_generated`] for outbound channels) being closed.
 *
 * Note that you can be a bit lazier about writing out `ChannelManager` than you can be with
 * [`ChannelMonitor`]. With [`ChannelMonitor`] you MUST durably write each
 * [`ChannelMonitorUpdate`] before returning from
 * [`chain::Watch::watch_channel`]/[`update_channel`] or before completing async writes. With
 * `ChannelManager`s, writing updates happens out-of-band (and will prevent any other
 * `ChannelManager` operations from occurring during the serialization process). If the
 * deserialized version is out-of-date compared to the [`ChannelMonitor`] passed by reference to
 * [`read`], those channels will be force-closed based on the `ChannelMonitor` state and no funds
 * will be lost (modulo on-chain transaction fees).
 *
 * Note that the deserializer is only implemented for `(`[`BlockHash`]`, `[`ChannelManager`]`)`, which
 * tells you the last block hash which was connected. You should get the best block tip before using the manager.
 * See [`chain::Listen`] and [`chain::Confirm`] for more details.
 *
 * Note that `ChannelManager` is responsible for tracking liveness of its channels and generating
 * [`ChannelUpdate`] messages informing peers that the channel is temporarily disabled. To avoid
 * spam due to quick disconnection/reconnection, updates are not sent until the channel has been
 * offline for a full minute. In order to track this, you must call
 * [`timer_tick_occurred`] roughly once per minute, though it doesn't have to be perfect.
 *
 * To avoid trivial DoS issues, `ChannelManager` limits the number of inbound connections and
 * inbound channels without confirmed funding transactions. This may result in nodes which we do
 * not have a channel with being unable to connect to us or open new channels with us if we have
 * many peers with unfunded channels.
 *
 * Because it is an indication of trust, inbound channels which we've accepted as 0conf are
 * exempted from the count of unfunded channels. Similarly, outbound channels and connections are
 * never limited. Please ensure you limit the count of such channels yourself.
 *
 * Rather than using a plain `ChannelManager`, it is preferable to use either a [`SimpleArcChannelManager`]
 * a [`SimpleRefChannelManager`], for conciseness. See their documentation for more details, but
 * essentially you should default to using a [`SimpleRefChannelManager`], and use a
 * [`SimpleArcChannelManager`] when you require a `ChannelManager` with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`peer_disconnected`]: msgs::ChannelMessageHandler::peer_disconnected
 * [`funding_created`]: msgs::FundingCreated
 * [`funding_transaction_generated`]: Self::funding_transaction_generated
 * [`BlockHash`]: bitcoin::hash_types::BlockHash
 * [`update_channel`]: chain::Watch::update_channel
 * [`ChannelUpdate`]: msgs::ChannelUpdate
 * [`timer_tick_occurred`]: Self::timer_tick_occurred
 * [`read`]: ReadableArgs::read
 */
typedef struct MUST_USE_STRUCT LDKChannelManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManager;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesChannelManagerZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelManager b;
} LDKC2Tuple_ThirtyTwoBytesChannelManagerZ;

/**
 * The contents of CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ThirtyTwoBytesChannelManagerZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelManagerZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ;

/**
 * Options for how to set the max dust HTLC exposure allowed on a channel. See
 * [`ChannelConfig::max_dust_htlc_exposure`] for details.
 */
typedef enum LDKMaxDustHTLCExposure_Tag {
   /**
    * This sets a fixed limit on the total dust exposure in millisatoshis. Setting this too low
    * may prevent the sending or receipt of low-value HTLCs on high-traffic nodes, however this
    * limit is very important to prevent stealing of large amounts of dust HTLCs by miners
    * through [fee griefing
    * attacks](https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-May/002714.html).
    *
    * Note that if the feerate increases significantly, without a manual increase
    * to this maximum the channel may be unable to send/receive HTLCs between the maximum dust
    * exposure and the new minimum value for HTLCs to be economically viable to claim.
    */
   LDKMaxDustHTLCExposure_FixedLimitMsat,
   /**
    * This sets a multiplier on the estimated high priority feerate (sats/KW, as obtained from
    * [`FeeEstimator`]) to determine the maximum allowed dust exposure. If this variant is used
    * then the maximum dust exposure in millisatoshis is calculated as:
    * `high_priority_feerate_per_kw * value`. For example, with our default value
    * `FeeRateMultiplier(5000)`:
    *
    * - For the minimum fee rate of 1 sat/vByte (250 sat/KW, although the minimum
    * defaults to 253 sats/KW for rounding, see [`FeeEstimator`]), the max dust exposure would
    * be 253 * 5000 = 1,265,000 msats.
    * - For a fee rate of 30 sat/vByte (7500 sat/KW), the max dust exposure would be
    * 7500 * 5000 = 37,500,000 msats.
    *
    * This allows the maximum dust exposure to automatically scale with fee rate changes.
    *
    * Note, if you're using a third-party fee estimator, this may leave you more exposed to a
    * fee griefing attack, where your fee estimator may purposely overestimate the fee rate,
    * causing you to accept more dust HTLCs than you would otherwise.
    *
    * This variant is primarily meant to serve pre-anchor channels, as HTLC fees being included
    * on HTLC outputs means your channel may be subject to more dust exposure in the event of
    * increases in fee rate.
    *
    * # Backwards Compatibility
    * This variant only became available in LDK 0.0.116, so if you downgrade to a prior version
    * by default this will be set to a [`Self::FixedLimitMsat`] of 5,000,000 msat.
    *
    * [`FeeEstimator`]: crate::chain::chaininterface::FeeEstimator
    */
   LDKMaxDustHTLCExposure_FeeRateMultiplier,
   /**
    * Must be last for serialization purposes
    */
   LDKMaxDustHTLCExposure_Sentinel,
} LDKMaxDustHTLCExposure_Tag;

typedef struct MUST_USE_STRUCT LDKMaxDustHTLCExposure {
   LDKMaxDustHTLCExposure_Tag tag;
   union {
      struct {
         uint64_t fixed_limit_msat;
      };
      struct {
         uint64_t fee_rate_multiplier;
      };
   };
} LDKMaxDustHTLCExposure;

/**
 * The contents of CResult_MaxDustHTLCExposureDecodeErrorZ
 */
typedef union LDKCResult_MaxDustHTLCExposureDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKMaxDustHTLCExposure *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_MaxDustHTLCExposureDecodeErrorZPtr;

/**
 * A CResult_MaxDustHTLCExposureDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::config::MaxDustHTLCExposure on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ {
   /**
    * The contents of this CResult_MaxDustHTLCExposureDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_MaxDustHTLCExposureDecodeErrorZPtr contents;
   /**
    * Whether this CResult_MaxDustHTLCExposureDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_MaxDustHTLCExposureDecodeErrorZ;



/**
 * Options which apply on a per-channel basis and may change at runtime or based on negotiation
 * with our counterparty.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfig;

/**
 * The contents of CResult_ChannelConfigDecodeErrorZ
 */
typedef union LDKCResult_ChannelConfigDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelConfig *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelConfigDecodeErrorZPtr;

/**
 * A CResult_ChannelConfigDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::config::ChannelConfig on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelConfigDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelConfigDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelConfigDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelConfigDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelConfigDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::util::config::MaxDustHTLCExposure or not
 */
typedef enum LDKCOption_MaxDustHTLCExposureZ_Tag {
   /**
    * When we're in this state, this COption_MaxDustHTLCExposureZ contains a crate::lightning::util::config::MaxDustHTLCExposure
    */
   LDKCOption_MaxDustHTLCExposureZ_Some,
   /**
    * When we're in this state, this COption_MaxDustHTLCExposureZ contains nothing
    */
   LDKCOption_MaxDustHTLCExposureZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_MaxDustHTLCExposureZ_Sentinel,
} LDKCOption_MaxDustHTLCExposureZ_Tag;

typedef struct LDKCOption_MaxDustHTLCExposureZ {
   LDKCOption_MaxDustHTLCExposureZ_Tag tag;
   union {
      struct {
         struct LDKMaxDustHTLCExposure some;
      };
   };
} LDKCOption_MaxDustHTLCExposureZ;

/**
 * An enum which can either contain a crate::lightning::util::errors::APIError or not
 */
typedef enum LDKCOption_APIErrorZ_Tag {
   /**
    * When we're in this state, this COption_APIErrorZ contains a crate::lightning::util::errors::APIError
    */
   LDKCOption_APIErrorZ_Some,
   /**
    * When we're in this state, this COption_APIErrorZ contains nothing
    */
   LDKCOption_APIErrorZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_APIErrorZ_Sentinel,
} LDKCOption_APIErrorZ_Tag;

typedef struct LDKCOption_APIErrorZ {
   LDKCOption_APIErrorZ_Tag tag;
   union {
      struct {
         struct LDKAPIError some;
      };
   };
} LDKCOption_APIErrorZ;

/**
 * The contents of CResult_COption_APIErrorZDecodeErrorZ
 */
typedef union LDKCResult_COption_APIErrorZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_APIErrorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_APIErrorZDecodeErrorZPtr;

/**
 * A CResult_COption_APIErrorZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_APIErrorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_APIErrorZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_APIErrorZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_APIErrorZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_APIErrorZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_APIErrorZDecodeErrorZ;

/**
 * The contents of CResult_ChannelMonitorUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelMonitorUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelMonitorUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::ChannelMonitorUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelMonitorUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelMonitorUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelMonitorUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelMonitorUpdateDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::chain::channelmonitor::MonitorEvent or not
 */
typedef enum LDKCOption_MonitorEventZ_Tag {
   /**
    * When we're in this state, this COption_MonitorEventZ contains a crate::lightning::chain::channelmonitor::MonitorEvent
    */
   LDKCOption_MonitorEventZ_Some,
   /**
    * When we're in this state, this COption_MonitorEventZ contains nothing
    */
   LDKCOption_MonitorEventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_MonitorEventZ_Sentinel,
} LDKCOption_MonitorEventZ_Tag;

typedef struct LDKCOption_MonitorEventZ {
   LDKCOption_MonitorEventZ_Tag tag;
   union {
      struct {
         struct LDKMonitorEvent some;
      };
   };
} LDKCOption_MonitorEventZ;

/**
 * The contents of CResult_COption_MonitorEventZDecodeErrorZ
 */
typedef union LDKCResult_COption_MonitorEventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_MonitorEventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_MonitorEventZDecodeErrorZPtr;

/**
 * A CResult_COption_MonitorEventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_MonitorEventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_MonitorEventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_MonitorEventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_MonitorEventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_MonitorEventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_MonitorEventZDecodeErrorZ;

/**
 * The contents of CResult_HTLCUpdateDecodeErrorZ
 */
typedef union LDKCResult_HTLCUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCUpdateDecodeErrorZPtr;

/**
 * A CResult_HTLCUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::channelmonitor::HTLCUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCUpdateDecodeErrorZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointCVec_u8ZZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_OutPointCVec_u8ZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32CVec_u8ZZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKCVec_u8Z b;
} LDKC2Tuple_u32CVec_u8ZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32CVec_u8ZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32CVec_u8ZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32CVec_u8ZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32CVec_u8ZZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32CVec_u8ZZZ b;
} LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::chan_utils::CommitmentTransactions of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_CommitmentTransactionZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKCommitmentTransaction *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_CommitmentTransactionZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_u32TxOutZ {
   /**
    * The element at position 0
    */
   uint32_t a;
   /**
    * The element at position 1
    */
   struct LDKTxOut b;
} LDKC2Tuple_u32TxOutZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_u32TxOutZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_u32TxOutZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_u32TxOutZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_u32TxOutZZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKCVec_C2Tuple_u32TxOutZZ b;
} LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_TransactionOutputsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_TransactionOutputsZ;

/**
 * Details about the balance(s) available for spending once the channel appears on chain.
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on when these will or will not
 * be provided.
 */
typedef enum LDKBalance_Tag {
   /**
    * The channel is not yet closed (or the commitment or closing transaction has not yet
    * appeared in a block). The given balance is claimable (less on-chain fees) if the channel is
    * force-closed now.
    */
   LDKBalance_ClaimableOnChannelClose,
   /**
    * The channel has been closed, and the given balance is ours but awaiting confirmations until
    * we consider it spendable.
    */
   LDKBalance_ClaimableAwaitingConfirmations,
   /**
    * The channel has been closed, and the given balance should be ours but awaiting spending
    * transaction confirmation. If the spending transaction does not confirm in time, it is
    * possible our counterparty can take the funds by broadcasting an HTLC timeout on-chain.
    *
    * Once the spending transaction confirms, before it has reached enough confirmations to be
    * considered safe from chain reorganizations, the balance will instead be provided via
    * [`Balance::ClaimableAwaitingConfirmations`].
    */
   LDKBalance_ContentiousClaimable,
   /**
    * HTLCs which we sent to our counterparty which are claimable after a timeout (less on-chain
    * fees) if the counterparty does not know the preimage for the HTLCs. These are somewhat
    * likely to be claimed by our counterparty before we do.
    */
   LDKBalance_MaybeTimeoutClaimableHTLC,
   /**
    * HTLCs which we received from our counterparty which are claimable with a preimage which we
    * do not currently have. This will only be claimable if we receive the preimage from the node
    * to which we forwarded this HTLC before the timeout.
    */
   LDKBalance_MaybePreimageClaimableHTLC,
   /**
    * The channel has been closed, and our counterparty broadcasted a revoked commitment
    * transaction.
    *
    * Thus, we're able to claim all outputs in the commitment transaction, one of which has the
    * following amount.
    */
   LDKBalance_CounterpartyRevokedOutputClaimable,
   /**
    * Must be last for serialization purposes
    */
   LDKBalance_Sentinel,
} LDKBalance_Tag;

typedef struct LDKBalance_LDKClaimableOnChannelClose_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t amount_satoshis;
} LDKBalance_LDKClaimableOnChannelClose_Body;

typedef struct LDKBalance_LDKClaimableAwaitingConfirmations_Body {
   /**
    * The amount available to claim, in satoshis, possibly excluding the on-chain fees which
    * were spent in broadcasting the transaction.
    */
   uint64_t amount_satoshis;
   /**
    * The height at which an [`Event::SpendableOutputs`] event will be generated for this
    * amount.
    */
   uint32_t confirmation_height;
} LDKBalance_LDKClaimableAwaitingConfirmations_Body;

typedef struct LDKBalance_LDKContentiousClaimable_Body {
   /**
    * The amount available to claim, in satoshis, excluding the on-chain fees which will be
    * required to do so.
    */
   uint64_t amount_satoshis;
   /**
    * The height at which the counterparty may be able to claim the balance if we have not
    * done so.
    */
   uint32_t timeout_height;
   /**
    * The payment hash that locks this HTLC.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The preimage that can be used to claim this HTLC.
    */
   struct LDKThirtyTwoBytes payment_preimage;
} LDKBalance_LDKContentiousClaimable_Body;

typedef struct LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body {
   /**
    * The amount potentially available to claim, in satoshis, excluding the on-chain fees
    * which will be required to do so.
    */
   uint64_t amount_satoshis;
   /**
    * The height at which we will be able to claim the balance if our counterparty has not
    * done so.
    */
   uint32_t claimable_height;
   /**
    * The payment hash whose preimage our counterparty needs to claim this HTLC.
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body;

typedef struct LDKBalance_LDKMaybePreimageClaimableHTLC_Body {
   /**
    * The amount potentially available to claim, in satoshis, excluding the on-chain fees
    * which will be required to do so.
    */
   uint64_t amount_satoshis;
   /**
    * The height at which our counterparty will be able to claim the balance if we have not
    * yet received the preimage and claimed it ourselves.
    */
   uint32_t expiry_height;
   /**
    * The payment hash whose preimage we need to claim this HTLC.
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKBalance_LDKMaybePreimageClaimableHTLC_Body;

typedef struct LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body {
   /**
    * The amount, in satoshis, of the output which we can claim.
    *
    * Note that for outputs from HTLC balances this may be excluding some on-chain fees that
    * were already spent.
    */
   uint64_t amount_satoshis;
} LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body;

typedef struct MUST_USE_STRUCT LDKBalance {
   LDKBalance_Tag tag;
   union {
      LDKBalance_LDKClaimableOnChannelClose_Body claimable_on_channel_close;
      LDKBalance_LDKClaimableAwaitingConfirmations_Body claimable_awaiting_confirmations;
      LDKBalance_LDKContentiousClaimable_Body contentious_claimable;
      LDKBalance_LDKMaybeTimeoutClaimableHTLC_Body maybe_timeout_claimable_htlc;
      LDKBalance_LDKMaybePreimageClaimableHTLC_Body maybe_preimage_claimable_htlc;
      LDKBalance_LDKCounterpartyRevokedOutputClaimable_Body counterparty_revoked_output_claimable;
   };
} LDKBalance;

/**
 * A dynamically-allocated array of crate::lightning::chain::channelmonitor::Balances of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_BalanceZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKBalance *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_BalanceZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ {
   /**
    * The element at position 0
    */
   struct LDKThirtyTwoBytes a;
   /**
    * The element at position 1
    */
   struct LDKChannelMonitor b;
} LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ;

/**
 * The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ
 */
typedef union LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr;

/**
 * A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ {
   /**
    * The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ;

/**
 * Defines a type identifier for sending messages over the wire.
 *
 * Messages implementing this trait specify a type and must be [`Writeable`].
 */
typedef struct LDKType {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the type identifying the message payload.
    */
   uint16_t (*type_id)(const void *this_arg);
   /**
    * Return a human-readable "debug" string describing this object
    */
   struct LDKStr (*debug_str)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this Type has been cloned into a duplicate object.
    * The new Type is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKType *NONNULL_PTR new_Type);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKType;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PublicKeyTypeZ {
   /**
    * The element at position 0
    */
   struct LDKPublicKey a;
   /**
    * The element at position 1
    */
   struct LDKType b;
} LDKC2Tuple_PublicKeyTypeZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyTypeZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_PublicKeyTypeZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_PublicKeyTypeZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_PublicKeyTypeZZ;



/**
 * An `InvoiceRequest` is a request for a [`Bolt12Invoice`] formulated from an [`Offer`].
 *
 * An offer may provide choices such as quantity, amount, chain, features, etc. An invoice request
 * specifies these such that its recipient can send an invoice for payment.
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 * [`Offer`]: crate::offers::offer::Offer
 */
typedef struct MUST_USE_STRUCT LDKInvoiceRequest {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceRequest *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceRequest;



/**
 * A `Bolt12Invoice` is a payment request, typically corresponding to an [`Offer`] or a [`Refund`].
 *
 * An invoice may be sent in response to an [`InvoiceRequest`] in the case of an offer or sent
 * directly after scanning a refund. It includes all the information needed to pay a recipient.
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Refund`]: crate::offers::refund::Refund
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 */
typedef struct MUST_USE_STRUCT LDKBolt12Invoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt12Invoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt12Invoice;



/**
 * An error in response to an [`InvoiceRequest`] or an [`Bolt12Invoice`].
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 */
typedef struct MUST_USE_STRUCT LDKInvoiceError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceError;

/**
 * Possible BOLT 12 Offers messages sent and received via an [`OnionMessage`].
 *
 * [`OnionMessage`]: crate::ln::msgs::OnionMessage
 */
typedef enum LDKOffersMessage_Tag {
   /**
    * A request for a [`Bolt12Invoice`] for a particular [`Offer`].
    *
    * [`Offer`]: crate::offers::offer::Offer
    */
   LDKOffersMessage_InvoiceRequest,
   /**
    * A [`Bolt12Invoice`] sent in response to an [`InvoiceRequest`] or a [`Refund`].
    *
    * [`Refund`]: crate::offers::refund::Refund
    */
   LDKOffersMessage_Invoice,
   /**
    * An error from handling an [`OffersMessage`].
    */
   LDKOffersMessage_InvoiceError,
   /**
    * Must be last for serialization purposes
    */
   LDKOffersMessage_Sentinel,
} LDKOffersMessage_Tag;

typedef struct MUST_USE_STRUCT LDKOffersMessage {
   LDKOffersMessage_Tag tag;
   union {
      struct {
         struct LDKInvoiceRequest invoice_request;
      };
      struct {
         struct LDKBolt12Invoice invoice;
      };
      struct {
         struct LDKInvoiceError invoice_error;
      };
   };
} LDKOffersMessage;

/**
 * An enum which can either contain a crate::lightning::onion_message::offers::OffersMessage or not
 */
typedef enum LDKCOption_OffersMessageZ_Tag {
   /**
    * When we're in this state, this COption_OffersMessageZ contains a crate::lightning::onion_message::offers::OffersMessage
    */
   LDKCOption_OffersMessageZ_Some,
   /**
    * When we're in this state, this COption_OffersMessageZ contains nothing
    */
   LDKCOption_OffersMessageZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_OffersMessageZ_Sentinel,
} LDKCOption_OffersMessageZ_Tag;

typedef struct LDKCOption_OffersMessageZ {
   LDKCOption_OffersMessageZ_Tag tag;
   union {
      struct {
         struct LDKOffersMessage some;
      };
   };
} LDKCOption_OffersMessageZ;

/**
 * The contents of a custom onion message.
 */
typedef struct LDKCustomOnionMessageContents {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the TLV type identifying the message contents. MUST be >= 64.
    */
   uint64_t (*tlv_type)(const void *this_arg);
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Called, if set, after this CustomOnionMessageContents has been cloned into a duplicate object.
    * The new CustomOnionMessageContents is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKCustomOnionMessageContents *NONNULL_PTR new_CustomOnionMessageContents);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomOnionMessageContents;

/**
 * An enum which can either contain a crate::lightning::onion_message::packet::CustomOnionMessageContents or not
 */
typedef enum LDKCOption_CustomOnionMessageContentsZ_Tag {
   /**
    * When we're in this state, this COption_CustomOnionMessageContentsZ contains a crate::lightning::onion_message::packet::CustomOnionMessageContents
    */
   LDKCOption_CustomOnionMessageContentsZ_Some,
   /**
    * When we're in this state, this COption_CustomOnionMessageContentsZ contains nothing
    */
   LDKCOption_CustomOnionMessageContentsZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_CustomOnionMessageContentsZ_Sentinel,
} LDKCOption_CustomOnionMessageContentsZ_Tag;

typedef struct LDKCOption_CustomOnionMessageContentsZ {
   LDKCOption_CustomOnionMessageContentsZ_Tag tag;
   union {
      struct {
         struct LDKCustomOnionMessageContents some;
      };
   };
} LDKCOption_CustomOnionMessageContentsZ;

/**
 * The contents of CResult_COption_CustomOnionMessageContentsZDecodeErrorZ
 */
typedef union LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_CustomOnionMessageContentsZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr;

/**
 * A CResult_COption_CustomOnionMessageContentsZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_CustomOnionMessageContentsZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_CustomOnionMessageContentsZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_CustomOnionMessageContentsZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::ln::wire::Type or not
 */
typedef enum LDKCOption_TypeZ_Tag {
   /**
    * When we're in this state, this COption_TypeZ contains a crate::lightning::ln::wire::Type
    */
   LDKCOption_TypeZ_Some,
   /**
    * When we're in this state, this COption_TypeZ contains nothing
    */
   LDKCOption_TypeZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_TypeZ_Sentinel,
} LDKCOption_TypeZ_Tag;

typedef struct LDKCOption_TypeZ {
   LDKCOption_TypeZ_Tag tag;
   union {
      struct {
         struct LDKType some;
      };
   };
} LDKCOption_TypeZ;

/**
 * The contents of CResult_COption_TypeZDecodeErrorZ
 */
typedef union LDKCResult_COption_TypeZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_TypeZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_TypeZDecodeErrorZPtr;

/**
 * A CResult_COption_TypeZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_TypeZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_TypeZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_TypeZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_TypeZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_TypeZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_TypeZDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::ln::msgs::SocketAddress or not
 */
typedef enum LDKCOption_SocketAddressZ_Tag {
   /**
    * When we're in this state, this COption_SocketAddressZ contains a crate::lightning::ln::msgs::SocketAddress
    */
   LDKCOption_SocketAddressZ_Some,
   /**
    * When we're in this state, this COption_SocketAddressZ contains nothing
    */
   LDKCOption_SocketAddressZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_SocketAddressZ_Sentinel,
} LDKCOption_SocketAddressZ_Tag;

typedef struct LDKCOption_SocketAddressZ {
   LDKCOption_SocketAddressZ_Tag tag;
   union {
      struct {
         struct LDKSocketAddress some;
      };
   };
} LDKCOption_SocketAddressZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ {
   /**
    * The element at position 0
    */
   struct LDKPublicKey a;
   /**
    * The element at position 1
    */
   struct LDKCOption_SocketAddressZ b;
} LDKC2Tuple_PublicKeyCOption_SocketAddressZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_PublicKeyCOption_SocketAddressZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ;



/**
 * Error for PeerManager errors. If you get one of these, you must disconnect the socket and
 * generate no further read_event/write_buffer_space_avail/socket_disconnected calls for the
 * descriptor.
 */
typedef struct MUST_USE_STRUCT LDKPeerHandleError {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerHandleError *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerHandleError;

/**
 * The contents of CResult_CVec_u8ZPeerHandleErrorZ
 */
typedef union LDKCResult_CVec_u8ZPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_CVec_u8ZPeerHandleErrorZPtr;

/**
 * A CResult_CVec_u8ZPeerHandleErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZPeerHandleErrorZ {
   /**
    * The contents of this CResult_CVec_u8ZPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZPeerHandleErrorZ;

/**
 * The contents of CResult_NonePeerHandleErrorZ
 */
typedef union LDKCResult_NonePeerHandleErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_NonePeerHandleErrorZPtr;

/**
 * A CResult_NonePeerHandleErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePeerHandleErrorZ {
   /**
    * The contents of this CResult_NonePeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_NonePeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePeerHandleErrorZ;

/**
 * The contents of CResult_boolPeerHandleErrorZ
 */
typedef union LDKCResult_boolPeerHandleErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   bool *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPeerHandleError *err;
} LDKCResult_boolPeerHandleErrorZPtr;

/**
 * A CResult_boolPeerHandleErrorZ represents the result of a fallible operation,
 * containing a bool on success and a crate::lightning::ln::peer_handler::PeerHandleError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_boolPeerHandleErrorZ {
   /**
    * The contents of this CResult_boolPeerHandleErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_boolPeerHandleErrorZPtr contents;
   /**
    * Whether this CResult_boolPeerHandleErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_boolPeerHandleErrorZ;

/**
 * All-encompassing standard error type that processing can return
 */
typedef enum LDKGraphSyncError_Tag {
   /**
    * Error trying to read the update data, typically due to an erroneous data length indication
    * that is greater than the actual amount of data provided
    */
   LDKGraphSyncError_DecodeError,
   /**
    * Error applying the patch to the network graph, usually the result of updates that are too
    * old or missing prerequisite data to the application of updates out of order
    */
   LDKGraphSyncError_LightningError,
   /**
    * Must be last for serialization purposes
    */
   LDKGraphSyncError_Sentinel,
} LDKGraphSyncError_Tag;

typedef struct MUST_USE_STRUCT LDKGraphSyncError {
   LDKGraphSyncError_Tag tag;
   union {
      struct {
         struct LDKDecodeError decode_error;
      };
      struct {
         struct LDKLightningError lightning_error;
      };
   };
} LDKGraphSyncError;

/**
 * The contents of CResult_u32GraphSyncErrorZ
 */
typedef union LDKCResult_u32GraphSyncErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   uint32_t *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKGraphSyncError *err;
} LDKCResult_u32GraphSyncErrorZPtr;

/**
 * A CResult_u32GraphSyncErrorZ represents the result of a fallible operation,
 * containing a u32 on success and a crate::lightning_rapid_gossip_sync::error::GraphSyncError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_u32GraphSyncErrorZ {
   /**
    * The contents of this CResult_u32GraphSyncErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_u32GraphSyncErrorZPtr contents;
   /**
    * Whether this CResult_u32GraphSyncErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_u32GraphSyncErrorZ;

/**
 * The contents of CResult_CVec_u8ZIOErrorZ
 */
typedef union LDKCResult_CVec_u8ZIOErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_u8Z *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_u8ZIOErrorZPtr;

/**
 * A CResult_CVec_u8ZIOErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_u8Z on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_u8ZIOErrorZ {
   /**
    * The contents of this CResult_CVec_u8ZIOErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_u8ZIOErrorZPtr contents;
   /**
    * Whether this CResult_CVec_u8ZIOErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_u8ZIOErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::Strs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_StrZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKStr *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_StrZ;

/**
 * The contents of CResult_CVec_StrZIOErrorZ
 */
typedef union LDKCResult_CVec_StrZIOErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_StrZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_StrZIOErrorZPtr;

/**
 * A CResult_CVec_StrZIOErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_StrZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_StrZIOErrorZ {
   /**
    * The contents of this CResult_CVec_StrZIOErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_StrZIOErrorZPtr contents;
   /**
    * Whether this CResult_CVec_StrZIOErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_StrZIOErrorZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ;

/**
 * The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ
 */
typedef union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr;

/**
 * A CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ;

/**
 * The contents of CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ
 */
typedef union LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKIOError *err;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr;

/**
 * A CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_ThirtyTwoBytesChannelMonitorZ on success and a crate::c_types::IOError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ {
   /**
    * The contents of this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ;

/**
 * Represents a valid secp256k1 secret key serialized as a 32 byte array.
 */
typedef struct LDKSecretKey {
   /**
    * The bytes of the secret key
    */
   uint8_t bytes[32];
} LDKSecretKey;

/**
 * An enum which can either contain a crate::c_types::SecretKey or not
 */
typedef enum LDKCOption_SecretKeyZ_Tag {
   /**
    * When we're in this state, this COption_SecretKeyZ contains a crate::c_types::SecretKey
    */
   LDKCOption_SecretKeyZ_Some,
   /**
    * When we're in this state, this COption_SecretKeyZ contains nothing
    */
   LDKCOption_SecretKeyZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_SecretKeyZ_Sentinel,
} LDKCOption_SecretKeyZ_Tag;

typedef struct LDKCOption_SecretKeyZ {
   LDKCOption_SecretKeyZ_Tag tag;
   union {
      struct {
         struct LDKSecretKey some;
      };
   };
} LDKCOption_SecretKeyZ;



/**
 * An [`InvoiceRequest`] that has been verified by [`InvoiceRequest::verify`] and exposes different
 * ways to respond depending on whether the signing keys were derived.
 */
typedef struct MUST_USE_STRUCT LDKVerifiedInvoiceRequest {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeVerifiedInvoiceRequest *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKVerifiedInvoiceRequest;

/**
 * The contents of CResult_VerifiedInvoiceRequestNoneZ
 */
typedef union LDKCResult_VerifiedInvoiceRequestNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKVerifiedInvoiceRequest *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_VerifiedInvoiceRequestNoneZPtr;

/**
 * A CResult_VerifiedInvoiceRequestNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::offers::invoice_request::VerifiedInvoiceRequest on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_VerifiedInvoiceRequestNoneZ {
   /**
    * The contents of this CResult_VerifiedInvoiceRequestNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_VerifiedInvoiceRequestNoneZPtr contents;
   /**
    * Whether this CResult_VerifiedInvoiceRequestNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_VerifiedInvoiceRequestNoneZ;

/**
 * A dynamically-allocated array of crate::c_types::Witnesss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_WitnessZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKWitness *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_WitnessZ;

/**
 * An enum which can either contain a i64 or not
 */
typedef enum LDKCOption_i64Z_Tag {
   /**
    * When we're in this state, this COption_i64Z contains a i64
    */
   LDKCOption_i64Z_Some,
   /**
    * When we're in this state, this COption_i64Z contains nothing
    */
   LDKCOption_i64Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_i64Z_Sentinel,
} LDKCOption_i64Z_Tag;

typedef struct LDKCOption_i64Z {
   LDKCOption_i64Z_Tag tag;
   union {
      struct {
         int64_t some;
      };
   };
} LDKCOption_i64Z;

/**
 * The contents of CResult_SocketAddressDecodeErrorZ
 */
typedef union LDKCResult_SocketAddressDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSocketAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_SocketAddressDecodeErrorZPtr;

/**
 * A CResult_SocketAddressDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SocketAddressDecodeErrorZ {
   /**
    * The contents of this CResult_SocketAddressDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SocketAddressDecodeErrorZPtr contents;
   /**
    * Whether this CResult_SocketAddressDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SocketAddressDecodeErrorZ;

/**
 * The contents of CResult_SocketAddressSocketAddressParseErrorZ
 */
typedef union LDKCResult_SocketAddressSocketAddressParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSocketAddress *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSocketAddressParseError *err;
} LDKCResult_SocketAddressSocketAddressParseErrorZPtr;

/**
 * A CResult_SocketAddressSocketAddressParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::SocketAddress on success and a crate::lightning::ln::msgs::SocketAddressParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SocketAddressSocketAddressParseErrorZ {
   /**
    * The contents of this CResult_SocketAddressSocketAddressParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SocketAddressSocketAddressParseErrorZPtr contents;
   /**
    * Whether this CResult_SocketAddressSocketAddressParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SocketAddressSocketAddressParseErrorZ;



/**
 * An [`update_add_htlc`] message to be sent to or received from a peer.
 *
 * [`update_add_htlc`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#adding-an-htlc-update_add_htlc
 */
typedef struct MUST_USE_STRUCT LDKUpdateAddHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateAddHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateAddHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateAddHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateAddHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateAddHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateAddHTLCZ;



/**
 * An [`update_fulfill_htlc`] message to be sent to or received from a peer.
 *
 * [`update_fulfill_htlc`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc
 */
typedef struct MUST_USE_STRUCT LDKUpdateFulfillHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFulfillHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFulfillHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFulfillHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFulfillHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFulfillHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFulfillHTLCZ;



/**
 * An [`update_fail_htlc`] message to be sent to or received from a peer.
 *
 * [`update_fail_htlc`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailHTLCZ;



/**
 * An [`update_fail_malformed_htlc`] message to be sent to or received from a peer.
 *
 * [`update_fail_malformed_htlc`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#removing-an-htlc-update_fulfill_htlc-update_fail_htlc-and-update_fail_malformed_htlc
 */
typedef struct MUST_USE_STRUCT LDKUpdateFailMalformedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFailMalformedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFailMalformedHTLC;

/**
 * A dynamically-allocated array of crate::lightning::ln::msgs::UpdateFailMalformedHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_UpdateFailMalformedHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKUpdateFailMalformedHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_UpdateFailMalformedHTLCZ;

/**
 * The contents of CResult_AcceptChannelDecodeErrorZ
 */
typedef union LDKCResult_AcceptChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAcceptChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelDecodeErrorZPtr;

/**
 * A CResult_AcceptChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AcceptChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AcceptChannelDecodeErrorZ {
   /**
    * The contents of this CResult_AcceptChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AcceptChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AcceptChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AcceptChannelDecodeErrorZ;

/**
 * The contents of CResult_AcceptChannelV2DecodeErrorZ
 */
typedef union LDKCResult_AcceptChannelV2DecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAcceptChannelV2 *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AcceptChannelV2DecodeErrorZPtr;

/**
 * A CResult_AcceptChannelV2DecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AcceptChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AcceptChannelV2DecodeErrorZ {
   /**
    * The contents of this CResult_AcceptChannelV2DecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AcceptChannelV2DecodeErrorZPtr contents;
   /**
    * Whether this CResult_AcceptChannelV2DecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AcceptChannelV2DecodeErrorZ;

/**
 * The contents of CResult_TxAddInputDecodeErrorZ
 */
typedef union LDKCResult_TxAddInputDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxAddInput *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxAddInputDecodeErrorZPtr;

/**
 * A CResult_TxAddInputDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxAddInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxAddInputDecodeErrorZ {
   /**
    * The contents of this CResult_TxAddInputDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxAddInputDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxAddInputDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxAddInputDecodeErrorZ;

/**
 * The contents of CResult_TxAddOutputDecodeErrorZ
 */
typedef union LDKCResult_TxAddOutputDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxAddOutput *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxAddOutputDecodeErrorZPtr;

/**
 * A CResult_TxAddOutputDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxAddOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxAddOutputDecodeErrorZ {
   /**
    * The contents of this CResult_TxAddOutputDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxAddOutputDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxAddOutputDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxAddOutputDecodeErrorZ;

/**
 * The contents of CResult_TxRemoveInputDecodeErrorZ
 */
typedef union LDKCResult_TxRemoveInputDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxRemoveInput *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxRemoveInputDecodeErrorZPtr;

/**
 * A CResult_TxRemoveInputDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxRemoveInput on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxRemoveInputDecodeErrorZ {
   /**
    * The contents of this CResult_TxRemoveInputDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxRemoveInputDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxRemoveInputDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxRemoveInputDecodeErrorZ;

/**
 * The contents of CResult_TxRemoveOutputDecodeErrorZ
 */
typedef union LDKCResult_TxRemoveOutputDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxRemoveOutput *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxRemoveOutputDecodeErrorZPtr;

/**
 * A CResult_TxRemoveOutputDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxRemoveOutput on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxRemoveOutputDecodeErrorZ {
   /**
    * The contents of this CResult_TxRemoveOutputDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxRemoveOutputDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxRemoveOutputDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxRemoveOutputDecodeErrorZ;

/**
 * The contents of CResult_TxCompleteDecodeErrorZ
 */
typedef union LDKCResult_TxCompleteDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxComplete *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxCompleteDecodeErrorZPtr;

/**
 * A CResult_TxCompleteDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxComplete on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCompleteDecodeErrorZ {
   /**
    * The contents of this CResult_TxCompleteDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCompleteDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxCompleteDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCompleteDecodeErrorZ;

/**
 * The contents of CResult_TxSignaturesDecodeErrorZ
 */
typedef union LDKCResult_TxSignaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxSignatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxSignaturesDecodeErrorZPtr;

/**
 * A CResult_TxSignaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxSignaturesDecodeErrorZ {
   /**
    * The contents of this CResult_TxSignaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxSignaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxSignaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxSignaturesDecodeErrorZ;

/**
 * The contents of CResult_TxInitRbfDecodeErrorZ
 */
typedef union LDKCResult_TxInitRbfDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxInitRbf *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxInitRbfDecodeErrorZPtr;

/**
 * A CResult_TxInitRbfDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxInitRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxInitRbfDecodeErrorZ {
   /**
    * The contents of this CResult_TxInitRbfDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxInitRbfDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxInitRbfDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxInitRbfDecodeErrorZ;

/**
 * The contents of CResult_TxAckRbfDecodeErrorZ
 */
typedef union LDKCResult_TxAckRbfDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxAckRbf *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxAckRbfDecodeErrorZPtr;

/**
 * A CResult_TxAckRbfDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxAckRbf on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxAckRbfDecodeErrorZ {
   /**
    * The contents of this CResult_TxAckRbfDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxAckRbfDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxAckRbfDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxAckRbfDecodeErrorZ;

/**
 * The contents of CResult_TxAbortDecodeErrorZ
 */
typedef union LDKCResult_TxAbortDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxAbort *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxAbortDecodeErrorZPtr;

/**
 * A CResult_TxAbortDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::TxAbort on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxAbortDecodeErrorZ {
   /**
    * The contents of this CResult_TxAbortDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxAbortDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxAbortDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxAbortDecodeErrorZ;

/**
 * The contents of CResult_AnnouncementSignaturesDecodeErrorZ
 */
typedef union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKAnnouncementSignatures *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_AnnouncementSignaturesDecodeErrorZPtr;

/**
 * A CResult_AnnouncementSignaturesDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::AnnouncementSignatures on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_AnnouncementSignaturesDecodeErrorZ {
   /**
    * The contents of this CResult_AnnouncementSignaturesDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_AnnouncementSignaturesDecodeErrorZPtr contents;
   /**
    * Whether this CResult_AnnouncementSignaturesDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_AnnouncementSignaturesDecodeErrorZ;

/**
 * The contents of CResult_ChannelReestablishDecodeErrorZ
 */
typedef union LDKCResult_ChannelReestablishDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReestablish *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReestablishDecodeErrorZPtr;

/**
 * A CResult_ChannelReestablishDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReestablish on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReestablishDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReestablishDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReestablishDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReestablishDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReestablishDecodeErrorZ;

/**
 * The contents of CResult_ClosingSignedDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedDecodeErrorZ;



/**
 * The minimum and maximum fees which the sender is willing to place on the closing transaction.
 *
 * This is provided in [`ClosingSigned`] by both sides to indicate the fee range they are willing
 * to use.
 */
typedef struct MUST_USE_STRUCT LDKClosingSignedFeeRange {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClosingSignedFeeRange *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClosingSignedFeeRange;

/**
 * The contents of CResult_ClosingSignedFeeRangeDecodeErrorZ
 */
typedef union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClosingSignedFeeRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr;

/**
 * A CResult_ClosingSignedFeeRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ClosingSignedFeeRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ClosingSignedFeeRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClosingSignedFeeRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClosingSignedFeeRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClosingSignedFeeRangeDecodeErrorZ;



/**
 * A [`commitment_signed`] message to be sent to or received from a peer.
 *
 * [`commitment_signed`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#committing-updates-so-far-commitment_signed
 */
typedef struct MUST_USE_STRUCT LDKCommitmentSigned {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCommitmentSigned *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCommitmentSigned;

/**
 * The contents of CResult_CommitmentSignedDecodeErrorZ
 */
typedef union LDKCResult_CommitmentSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentSignedDecodeErrorZPtr;

/**
 * A CResult_CommitmentSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::CommitmentSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentSignedDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentSignedDecodeErrorZ;

/**
 * The contents of CResult_FundingCreatedDecodeErrorZ
 */
typedef union LDKCResult_FundingCreatedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingCreated *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingCreatedDecodeErrorZPtr;

/**
 * A CResult_FundingCreatedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingCreated on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingCreatedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingCreatedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingCreatedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingCreatedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingCreatedDecodeErrorZ;

/**
 * The contents of CResult_FundingSignedDecodeErrorZ
 */
typedef union LDKCResult_FundingSignedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKFundingSigned *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_FundingSignedDecodeErrorZPtr;

/**
 * A CResult_FundingSignedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::FundingSigned on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_FundingSignedDecodeErrorZ {
   /**
    * The contents of this CResult_FundingSignedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_FundingSignedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_FundingSignedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_FundingSignedDecodeErrorZ;

/**
 * The contents of CResult_ChannelReadyDecodeErrorZ
 */
typedef union LDKCResult_ChannelReadyDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelReady *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelReadyDecodeErrorZPtr;

/**
 * A CResult_ChannelReadyDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelReady on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelReadyDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelReadyDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelReadyDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelReadyDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelReadyDecodeErrorZ;



/**
 * An [`init`] message to be sent to or received from a peer.
 *
 * [`init`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-init-message
 */
typedef struct MUST_USE_STRUCT LDKInit {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInit *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInit;

/**
 * The contents of CResult_InitDecodeErrorZ
 */
typedef union LDKCResult_InitDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInit *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InitDecodeErrorZPtr;

/**
 * A CResult_InitDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Init on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InitDecodeErrorZ {
   /**
    * The contents of this CResult_InitDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InitDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InitDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InitDecodeErrorZ;

/**
 * The contents of CResult_OpenChannelDecodeErrorZ
 */
typedef union LDKCResult_OpenChannelDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOpenChannel *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelDecodeErrorZPtr;

/**
 * A CResult_OpenChannelDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OpenChannel on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OpenChannelDecodeErrorZ {
   /**
    * The contents of this CResult_OpenChannelDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OpenChannelDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OpenChannelDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OpenChannelDecodeErrorZ;

/**
 * The contents of CResult_OpenChannelV2DecodeErrorZ
 */
typedef union LDKCResult_OpenChannelV2DecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOpenChannelV2 *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OpenChannelV2DecodeErrorZPtr;

/**
 * A CResult_OpenChannelV2DecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OpenChannelV2 on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OpenChannelV2DecodeErrorZ {
   /**
    * The contents of this CResult_OpenChannelV2DecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OpenChannelV2DecodeErrorZPtr contents;
   /**
    * Whether this CResult_OpenChannelV2DecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OpenChannelV2DecodeErrorZ;

/**
 * The contents of CResult_RevokeAndACKDecodeErrorZ
 */
typedef union LDKCResult_RevokeAndACKDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKRevokeAndACK *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_RevokeAndACKDecodeErrorZPtr;

/**
 * A CResult_RevokeAndACKDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::RevokeAndACK on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_RevokeAndACKDecodeErrorZ {
   /**
    * The contents of this CResult_RevokeAndACKDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_RevokeAndACKDecodeErrorZPtr contents;
   /**
    * Whether this CResult_RevokeAndACKDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_RevokeAndACKDecodeErrorZ;

/**
 * The contents of CResult_ShutdownDecodeErrorZ
 */
typedef union LDKCResult_ShutdownDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdown *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownDecodeErrorZPtr;

/**
 * A CResult_ShutdownDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Shutdown on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateFailMalformedHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFailMalformedHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFailMalformedHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFailMalformedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFailMalformedHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFailMalformedHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFailMalformedHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ;



/**
 * An [`update_fee`] message to be sent to or received from a peer
 *
 * [`update_fee`]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md#updating-fees-update_fee
 */
typedef struct MUST_USE_STRUCT LDKUpdateFee {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUpdateFee *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUpdateFee;

/**
 * The contents of CResult_UpdateFeeDecodeErrorZ
 */
typedef union LDKCResult_UpdateFeeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFee *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFeeDecodeErrorZPtr;

/**
 * A CResult_UpdateFeeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFee on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFeeDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFeeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFeeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFeeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFeeDecodeErrorZ;

/**
 * The contents of CResult_UpdateFulfillHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateFulfillHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateFulfillHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateFulfillHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateFulfillHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateFulfillHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateFulfillHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateFulfillHTLCDecodeErrorZ;

/**
 * The contents of CResult_UpdateAddHTLCDecodeErrorZ
 */
typedef union LDKCResult_UpdateAddHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUpdateAddHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UpdateAddHTLCDecodeErrorZPtr;

/**
 * A CResult_UpdateAddHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UpdateAddHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UpdateAddHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_UpdateAddHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UpdateAddHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UpdateAddHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UpdateAddHTLCDecodeErrorZ;



/**
 * An onion message to be sent to or received from a peer.
 *
 */
typedef struct MUST_USE_STRUCT LDKOnionMessage {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOnionMessage *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOnionMessage;

/**
 * The contents of CResult_OnionMessageDecodeErrorZ
 */
typedef union LDKCResult_OnionMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOnionMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OnionMessageDecodeErrorZPtr;

/**
 * A CResult_OnionMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::OnionMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OnionMessageDecodeErrorZ {
   /**
    * The contents of this CResult_OnionMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OnionMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OnionMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OnionMessageDecodeErrorZ;



/**
 * A [`ping`] message to be sent to or received from a peer.
 *
 * [`ping`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-ping-and-pong-messages
 */
typedef struct MUST_USE_STRUCT LDKPing {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePing *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPing;

/**
 * The contents of CResult_PingDecodeErrorZ
 */
typedef union LDKCResult_PingDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPing *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PingDecodeErrorZPtr;

/**
 * A CResult_PingDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Ping on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PingDecodeErrorZ {
   /**
    * The contents of this CResult_PingDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PingDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PingDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PingDecodeErrorZ;



/**
 * A [`pong`] message to be sent to or received from a peer.
 *
 * [`pong`]: https://github.com/lightning/bolts/blob/master/01-messaging.md#the-ping-and-pong-messages
 */
typedef struct MUST_USE_STRUCT LDKPong {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePong *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPong;

/**
 * The contents of CResult_PongDecodeErrorZ
 */
typedef union LDKCResult_PongDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPong *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PongDecodeErrorZPtr;

/**
 * A CResult_PongDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::Pong on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PongDecodeErrorZ {
   /**
    * The contents of this CResult_PongDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PongDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PongDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PongDecodeErrorZ;

/**
 * The contents of CResult_UnsignedChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_ChannelAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_ChannelAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelAnnouncementDecodeErrorZPtr;

/**
 * A CResult_ChannelAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_UnsignedChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_UnsignedChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ChannelUpdateDecodeErrorZ
 */
typedef union LDKCResult_ChannelUpdateDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelUpdate *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelUpdateDecodeErrorZPtr;

/**
 * A CResult_ChannelUpdateDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ChannelUpdate on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelUpdateDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelUpdateDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelUpdateDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelUpdateDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelUpdateDecodeErrorZ;

/**
 * The contents of CResult_ErrorMessageDecodeErrorZ
 */
typedef union LDKCResult_ErrorMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKErrorMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ErrorMessageDecodeErrorZPtr;

/**
 * A CResult_ErrorMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ErrorMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ErrorMessageDecodeErrorZ {
   /**
    * The contents of this CResult_ErrorMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ErrorMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ErrorMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ErrorMessageDecodeErrorZ;

/**
 * The contents of CResult_WarningMessageDecodeErrorZ
 */
typedef union LDKCResult_WarningMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKWarningMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_WarningMessageDecodeErrorZPtr;

/**
 * A CResult_WarningMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::WarningMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_WarningMessageDecodeErrorZ {
   /**
    * The contents of this CResult_WarningMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_WarningMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_WarningMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_WarningMessageDecodeErrorZ;

/**
 * The contents of CResult_UnsignedNodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUnsignedNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_UnsignedNodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::UnsignedNodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_UnsignedNodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UnsignedNodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UnsignedNodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_NodeAnnouncementDecodeErrorZ
 */
typedef union LDKCResult_NodeAnnouncementDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKNodeAnnouncement *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_NodeAnnouncementDecodeErrorZPtr;

/**
 * A CResult_NodeAnnouncementDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::NodeAnnouncement on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NodeAnnouncementDecodeErrorZ {
   /**
    * The contents of this CResult_NodeAnnouncementDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NodeAnnouncementDecodeErrorZPtr contents;
   /**
    * Whether this CResult_NodeAnnouncementDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NodeAnnouncementDecodeErrorZ;

/**
 * The contents of CResult_QueryShortChannelIdsDecodeErrorZ
 */
typedef union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryShortChannelIds *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryShortChannelIdsDecodeErrorZPtr;

/**
 * A CResult_QueryShortChannelIdsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryShortChannelIds on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryShortChannelIdsDecodeErrorZ {
   /**
    * The contents of this CResult_QueryShortChannelIdsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryShortChannelIdsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryShortChannelIdsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryShortChannelIdsDecodeErrorZ;



/**
 * A [`reply_short_channel_ids_end`] message is sent as a reply to a
 * message. The query recipient makes a best
 * effort to respond based on their local network view which may not be
 * a perfect view of the network.
 *
 * [`reply_short_channel_ids_end`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-query_short_channel_idsreply_short_channel_ids_end-messages
 */
typedef struct MUST_USE_STRUCT LDKReplyShortChannelIdsEnd {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReplyShortChannelIdsEnd *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReplyShortChannelIdsEnd;

/**
 * The contents of CResult_ReplyShortChannelIdsEndDecodeErrorZ
 */
typedef union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyShortChannelIdsEnd *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr;

/**
 * A CResult_ReplyShortChannelIdsEndDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyShortChannelIdsEnd on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyShortChannelIdsEndDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyShortChannelIdsEndDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyShortChannelIdsEndDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ;

/**
 * The contents of CResult_QueryChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_QueryChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKQueryChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_QueryChannelRangeDecodeErrorZPtr;

/**
 * A CResult_QueryChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::QueryChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_QueryChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_QueryChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_QueryChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_QueryChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_QueryChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_ReplyChannelRangeDecodeErrorZ
 */
typedef union LDKCResult_ReplyChannelRangeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReplyChannelRange *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReplyChannelRangeDecodeErrorZPtr;

/**
 * A CResult_ReplyChannelRangeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::ReplyChannelRange on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReplyChannelRangeDecodeErrorZ {
   /**
    * The contents of this CResult_ReplyChannelRangeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReplyChannelRangeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReplyChannelRangeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReplyChannelRangeDecodeErrorZ;

/**
 * The contents of CResult_GossipTimestampFilterDecodeErrorZ
 */
typedef union LDKCResult_GossipTimestampFilterDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKGossipTimestampFilter *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_GossipTimestampFilterDecodeErrorZPtr;

/**
 * A CResult_GossipTimestampFilterDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::msgs::GossipTimestampFilter on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_GossipTimestampFilterDecodeErrorZ {
   /**
    * The contents of this CResult_GossipTimestampFilterDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_GossipTimestampFilterDecodeErrorZPtr contents;
   /**
    * Whether this CResult_GossipTimestampFilterDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_GossipTimestampFilterDecodeErrorZ;

/**
 * A dynamically-allocated array of crate::lightning::ln::channelmanager::PhantomRouteHintss of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PhantomRouteHintsZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPhantomRouteHints *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PhantomRouteHintsZ;



/**
 * Represents a syntactically and semantically correct lightning BOLT11 invoice.
 *
 * There are three ways to construct a `Bolt11Invoice`:
 *  1. using [`InvoiceBuilder`]
 *  2. using [`Bolt11Invoice::from_signed`]
 *  3. using `str::parse::<Bolt11Invoice>(&str)` (see [`Bolt11Invoice::from_str`])
 *
 * [`Bolt11Invoice::from_str`]: crate::Bolt11Invoice#impl-FromStr
 */
typedef struct MUST_USE_STRUCT LDKBolt11Invoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt11Invoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt11Invoice;

/**
 * When signing using a fallible method either an user-supplied `SignError` or a [`CreationError`]
 * may occur.
 */
typedef enum LDKSignOrCreationError_Tag {
   /**
    * An error occurred during signing
    */
   LDKSignOrCreationError_SignError,
   /**
    * An error occurred while building the transaction
    */
   LDKSignOrCreationError_CreationError,
   /**
    * Must be last for serialization purposes
    */
   LDKSignOrCreationError_Sentinel,
} LDKSignOrCreationError_Tag;

typedef struct MUST_USE_STRUCT LDKSignOrCreationError {
   LDKSignOrCreationError_Tag tag;
   union {
      struct {
         enum LDKCreationError creation_error;
      };
   };
} LDKSignOrCreationError;

/**
 * The contents of CResult_Bolt11InvoiceSignOrCreationErrorZ
 */
typedef union LDKCResult_Bolt11InvoiceSignOrCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBolt11Invoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSignOrCreationError *err;
} LDKCResult_Bolt11InvoiceSignOrCreationErrorZPtr;

/**
 * A CResult_Bolt11InvoiceSignOrCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::SignOrCreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ {
   /**
    * The contents of this CResult_Bolt11InvoiceSignOrCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_Bolt11InvoiceSignOrCreationErrorZPtr contents;
   /**
    * Whether this CResult_Bolt11InvoiceSignOrCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_Bolt11InvoiceSignOrCreationErrorZ;



/**
 * A simple future which can complete once, and calls some callback(s) when it does so.
 *
 * Clones can be made and all futures cloned from the same source will complete at the same time.
 */
typedef struct MUST_USE_STRUCT LDKFuture {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFuture *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFuture;

/**
 * A dynamically-allocated array of crate::lightning::util::wakers::Futures of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_FutureZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKFuture *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_FutureZ;

/**
 * The contents of CResult_OffersMessageDecodeErrorZ
 */
typedef union LDKCResult_OffersMessageDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOffersMessage *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OffersMessageDecodeErrorZPtr;

/**
 * A CResult_OffersMessageDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::onion_message::offers::OffersMessage on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OffersMessageDecodeErrorZ {
   /**
    * The contents of this CResult_OffersMessageDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OffersMessageDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OffersMessageDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OffersMessageDecodeErrorZ;

/**
 * An enum which can either contain a crate::lightning::ln::chan_utils::HTLCClaim or not
 */
typedef enum LDKCOption_HTLCClaimZ_Tag {
   /**
    * When we're in this state, this COption_HTLCClaimZ contains a crate::lightning::ln::chan_utils::HTLCClaim
    */
   LDKCOption_HTLCClaimZ_Some,
   /**
    * When we're in this state, this COption_HTLCClaimZ contains nothing
    */
   LDKCOption_HTLCClaimZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_HTLCClaimZ_Sentinel,
} LDKCOption_HTLCClaimZ_Tag;

typedef struct LDKCOption_HTLCClaimZ {
   LDKCOption_HTLCClaimZ_Tag tag;
   union {
      struct {
         enum LDKHTLCClaim some;
      };
   };
} LDKCOption_HTLCClaimZ;



/**
 * Implements the per-commitment secret storage scheme from
 * [BOLT 3](https://github.com/lightning/bolts/blob/dcbf8583976df087c79c3ce0b535311212e6812d/03-transactions.md#efficient-per-commitment-secret-storage).
 *
 * Allows us to keep track of all of the revocation secrets of our counterparty in just 50*32 bytes
 * or so.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyCommitmentSecrets {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyCommitmentSecrets *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyCommitmentSecrets;

/**
 * The contents of CResult_CounterpartyCommitmentSecretsDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyCommitmentSecrets *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr;

/**
 * A CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyCommitmentSecrets on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyCommitmentSecretsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyCommitmentSecretsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ;



/**
 * The set of public keys which are used in the creation of one commitment transaction.
 * These are derived from the channel base keys and per-commitment data.
 *
 * A broadcaster key is provided from potential broadcaster of the computed transaction.
 * A countersignatory key is coming from a protocol participant unable to broadcast the
 * transaction.
 *
 * These keys are assumed to be good, either because the code derived them from
 * channel basepoints via the new function, or they were obtained via
 * CommitmentTransaction.trust().keys() because we trusted the source of the
 * pre-calculated keys.
 */
typedef struct MUST_USE_STRUCT LDKTxCreationKeys {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTxCreationKeys *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTxCreationKeys;

/**
 * The contents of CResult_TxCreationKeysDecodeErrorZ
 */
typedef union LDKCResult_TxCreationKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTxCreationKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TxCreationKeysDecodeErrorZPtr;

/**
 * A CResult_TxCreationKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TxCreationKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TxCreationKeysDecodeErrorZ {
   /**
    * The contents of this CResult_TxCreationKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TxCreationKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TxCreationKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TxCreationKeysDecodeErrorZ;

/**
 * The contents of CResult_ChannelPublicKeysDecodeErrorZ
 */
typedef union LDKCResult_ChannelPublicKeysDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelPublicKeys *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelPublicKeysDecodeErrorZPtr;

/**
 * A CResult_ChannelPublicKeysDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelPublicKeys on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelPublicKeysDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelPublicKeysDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelPublicKeysDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelPublicKeysDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelPublicKeysDecodeErrorZ;

/**
 * The contents of CResult_HTLCOutputInCommitmentDecodeErrorZ
 */
typedef union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHTLCOutputInCommitment *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr;

/**
 * A CResult_HTLCOutputInCommitmentDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HTLCOutputInCommitment on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ {
   /**
    * The contents of this CResult_HTLCOutputInCommitmentDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HTLCOutputInCommitmentDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HTLCOutputInCommitmentDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HTLCOutputInCommitmentDecodeErrorZ;



/**
 * Late-bound per-channel counterparty data used to build transactions.
 */
typedef struct MUST_USE_STRUCT LDKCounterpartyChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeCounterpartyChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKCounterpartyChannelTransactionParameters;

/**
 * The contents of CResult_CounterpartyChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCounterpartyChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CounterpartyChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CounterpartyChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ;

/**
 * The contents of CResult_ChannelTransactionParametersDecodeErrorZ
 */
typedef union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKChannelTransactionParameters *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ChannelTransactionParametersDecodeErrorZPtr;

/**
 * A CResult_ChannelTransactionParametersDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::ChannelTransactionParameters on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ChannelTransactionParametersDecodeErrorZ {
   /**
    * The contents of this CResult_ChannelTransactionParametersDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ChannelTransactionParametersDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ChannelTransactionParametersDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ChannelTransactionParametersDecodeErrorZ;

/**
 * The contents of CResult_HolderCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHolderCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_HolderCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::HolderCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_HolderCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HolderCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HolderCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HolderCommitmentTransactionDecodeErrorZ;



/**
 * A pre-built Bitcoin commitment transaction and its txid.
 */
typedef struct MUST_USE_STRUCT LDKBuiltCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBuiltCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBuiltCommitmentTransaction;

/**
 * The contents of CResult_BuiltCommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBuiltCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_BuiltCommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::BuiltCommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_BuiltCommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BuiltCommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BuiltCommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BuiltCommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on ClosingTransaction indicating that the built bitcoin
 * transaction is trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedClosingTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedClosingTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedClosingTransaction;

/**
 * The contents of CResult_TrustedClosingTransactionNoneZ
 */
typedef union LDKCResult_TrustedClosingTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedClosingTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedClosingTransactionNoneZPtr;

/**
 * A CResult_TrustedClosingTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedClosingTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedClosingTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedClosingTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedClosingTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedClosingTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedClosingTransactionNoneZ;

/**
 * The contents of CResult_CommitmentTransactionDecodeErrorZ
 */
typedef union LDKCResult_CommitmentTransactionDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCommitmentTransaction *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_CommitmentTransactionDecodeErrorZPtr;

/**
 * A CResult_CommitmentTransactionDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::CommitmentTransaction on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CommitmentTransactionDecodeErrorZ {
   /**
    * The contents of this CResult_CommitmentTransactionDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CommitmentTransactionDecodeErrorZPtr contents;
   /**
    * Whether this CResult_CommitmentTransactionDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CommitmentTransactionDecodeErrorZ;



/**
 * A wrapper on CommitmentTransaction indicating that the derived fields (the built bitcoin
 * transaction and the transaction creation keys) are trusted.
 *
 * See trust() and verify() functions on CommitmentTransaction.
 *
 * This structure implements Deref.
 */
typedef struct MUST_USE_STRUCT LDKTrustedCommitmentTransaction {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTrustedCommitmentTransaction *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTrustedCommitmentTransaction;

/**
 * The contents of CResult_TrustedCommitmentTransactionNoneZ
 */
typedef union LDKCResult_TrustedCommitmentTransactionNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTrustedCommitmentTransaction *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TrustedCommitmentTransactionNoneZPtr;

/**
 * A CResult_TrustedCommitmentTransactionNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::chan_utils::TrustedCommitmentTransaction on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TrustedCommitmentTransactionNoneZ {
   /**
    * The contents of this CResult_TrustedCommitmentTransactionNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TrustedCommitmentTransactionNoneZPtr contents;
   /**
    * Whether this CResult_TrustedCommitmentTransactionNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TrustedCommitmentTransactionNoneZ;

/**
 * The contents of CResult_CVec_ECDSASignatureZNoneZ
 */
typedef union LDKCResult_CVec_ECDSASignatureZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_ECDSASignatureZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_CVec_ECDSASignatureZNoneZPtr;

/**
 * A CResult_CVec_ECDSASignatureZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_ECDSASignatureZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_ECDSASignatureZNoneZ {
   /**
    * The contents of this CResult_CVec_ECDSASignatureZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_ECDSASignatureZNoneZPtr contents;
   /**
    * Whether this CResult_CVec_ECDSASignatureZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_ECDSASignatureZNoneZ;

/**
 * An enum which can either contain a usize or not
 */
typedef enum LDKCOption_usizeZ_Tag {
   /**
    * When we're in this state, this COption_usizeZ contains a usize
    */
   LDKCOption_usizeZ_Some,
   /**
    * When we're in this state, this COption_usizeZ contains nothing
    */
   LDKCOption_usizeZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_usizeZ_Sentinel,
} LDKCOption_usizeZ_Tag;

typedef struct LDKCOption_usizeZ {
   LDKCOption_usizeZ_Tag tag;
   union {
      struct {
         uintptr_t some;
      };
   };
} LDKCOption_usizeZ;

/**
 * The contents of CResult_ShutdownScriptDecodeErrorZ
 */
typedef union LDKCResult_ShutdownScriptDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ShutdownScriptDecodeErrorZPtr;

/**
 * A CResult_ShutdownScriptDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptDecodeErrorZ {
   /**
    * The contents of this CResult_ShutdownScriptDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptDecodeErrorZ;



/**
 * An error occurring when converting from [`Script`] to [`ShutdownScript`].
 */
typedef struct MUST_USE_STRUCT LDKInvalidShutdownScript {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvalidShutdownScript *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvalidShutdownScript;

/**
 * The contents of CResult_ShutdownScriptInvalidShutdownScriptZ
 */
typedef union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKShutdownScript *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKInvalidShutdownScript *err;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr;

/**
 * A CResult_ShutdownScriptInvalidShutdownScriptZ represents the result of a fallible operation,
 * containing a crate::lightning::ln::script::ShutdownScript on success and a crate::lightning::ln::script::InvalidShutdownScript on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ {
   /**
    * The contents of this CResult_ShutdownScriptInvalidShutdownScriptZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ShutdownScriptInvalidShutdownScriptZPtr contents;
   /**
    * Whether this CResult_ShutdownScriptInvalidShutdownScriptZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ShutdownScriptInvalidShutdownScriptZ;

/**
 * Some information provided on receipt of payment depends on whether the payment received is a
 * spontaneous payment or a \"conventional\" lightning payment that's paying an invoice.
 */
typedef enum LDKPaymentPurpose_Tag {
   /**
    * Information for receiving a payment that we generated an invoice for.
    */
   LDKPaymentPurpose_InvoicePayment,
   /**
    * Because this is a spontaneous payment, the payer generated their own preimage rather than us
    * (the payee) providing a preimage.
    */
   LDKPaymentPurpose_SpontaneousPayment,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentPurpose_Sentinel,
} LDKPaymentPurpose_Tag;

typedef struct LDKPaymentPurpose_LDKInvoicePayment_Body {
   /**
    * The preimage to the payment_hash, if the payment hash (and secret) were fetched via
    * [`ChannelManager::create_inbound_payment`]. If provided, this can be handed directly to
    * [`ChannelManager::claim_funds`].
    *
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    */
   struct LDKCOption_ThirtyTwoBytesZ payment_preimage;
   /**
    * The \"payment secret\". This authenticates the sender to the recipient, preventing a
    * number of deanonymization attacks during the routing process.
    * It is provided here for your reference, however its accuracy is enforced directly by
    * [`ChannelManager`] using the values you previously provided to
    * [`ChannelManager::create_inbound_payment`] or
    * [`ChannelManager::create_inbound_payment_for_hash`].
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::create_inbound_payment`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment
    * [`ChannelManager::create_inbound_payment_for_hash`]: crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
    */
   struct LDKThirtyTwoBytes payment_secret;
} LDKPaymentPurpose_LDKInvoicePayment_Body;

typedef struct MUST_USE_STRUCT LDKPaymentPurpose {
   LDKPaymentPurpose_Tag tag;
   union {
      LDKPaymentPurpose_LDKInvoicePayment_Body invoice_payment;
      struct {
         struct LDKThirtyTwoBytes spontaneous_payment;
      };
   };
} LDKPaymentPurpose;

/**
 * The contents of CResult_PaymentPurposeDecodeErrorZ
 */
typedef union LDKCResult_PaymentPurposeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentPurpose *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentPurposeDecodeErrorZPtr;

/**
 * A CResult_PaymentPurposeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::events::PaymentPurpose on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentPurposeDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentPurposeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentPurposeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentPurposeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentPurposeDecodeErrorZ;



/**
 * Information about an HTLC that is part of a payment that can be claimed.
 */
typedef struct MUST_USE_STRUCT LDKClaimedHTLC {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeClaimedHTLC *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKClaimedHTLC;

/**
 * The contents of CResult_ClaimedHTLCDecodeErrorZ
 */
typedef union LDKCResult_ClaimedHTLCDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKClaimedHTLC *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ClaimedHTLCDecodeErrorZPtr;

/**
 * A CResult_ClaimedHTLCDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::events::ClaimedHTLC on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ClaimedHTLCDecodeErrorZ {
   /**
    * The contents of this CResult_ClaimedHTLCDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ClaimedHTLCDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ClaimedHTLCDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ClaimedHTLCDecodeErrorZ;

/**
 * When the payment path failure took place and extra details about it. [`PathFailure::OnPath`] may
 * contain a [`NetworkUpdate`] that needs to be applied to the [`NetworkGraph`].
 *
 * [`NetworkUpdate`]: crate::routing::gossip::NetworkUpdate
 * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
 */
typedef enum LDKPathFailure_Tag {
   /**
    * We failed to initially send the payment and no HTLC was committed to. Contains the relevant
    * error.
    */
   LDKPathFailure_InitialSend,
   /**
    * A hop on the path failed to forward our payment.
    */
   LDKPathFailure_OnPath,
   /**
    * Must be last for serialization purposes
    */
   LDKPathFailure_Sentinel,
} LDKPathFailure_Tag;

typedef struct LDKPathFailure_LDKInitialSend_Body {
   /**
    * The error surfaced from initial send.
    */
   struct LDKAPIError err;
} LDKPathFailure_LDKInitialSend_Body;

typedef struct LDKPathFailure_LDKOnPath_Body {
   /**
    * If present, this [`NetworkUpdate`] should be applied to the [`NetworkGraph`] so that routing
    * decisions can take into account the update.
    *
    * [`NetworkUpdate`]: crate::routing::gossip::NetworkUpdate
    * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
    */
   struct LDKCOption_NetworkUpdateZ network_update;
} LDKPathFailure_LDKOnPath_Body;

typedef struct MUST_USE_STRUCT LDKPathFailure {
   LDKPathFailure_Tag tag;
   union {
      LDKPathFailure_LDKInitialSend_Body initial_send;
      LDKPathFailure_LDKOnPath_Body on_path;
   };
} LDKPathFailure;

/**
 * An enum which can either contain a crate::lightning::events::PathFailure or not
 */
typedef enum LDKCOption_PathFailureZ_Tag {
   /**
    * When we're in this state, this COption_PathFailureZ contains a crate::lightning::events::PathFailure
    */
   LDKCOption_PathFailureZ_Some,
   /**
    * When we're in this state, this COption_PathFailureZ contains nothing
    */
   LDKCOption_PathFailureZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_PathFailureZ_Sentinel,
} LDKCOption_PathFailureZ_Tag;

typedef struct LDKCOption_PathFailureZ {
   LDKCOption_PathFailureZ_Tag tag;
   union {
      struct {
         struct LDKPathFailure some;
      };
   };
} LDKCOption_PathFailureZ;

/**
 * The contents of CResult_COption_PathFailureZDecodeErrorZ
 */
typedef union LDKCResult_COption_PathFailureZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_PathFailureZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_PathFailureZDecodeErrorZPtr;

/**
 * A CResult_COption_PathFailureZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_PathFailureZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_PathFailureZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_PathFailureZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_PathFailureZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_PathFailureZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_PathFailureZDecodeErrorZ;



/**
 * Struct to `Display` fields in a safe way using `PrintableString`
 */
typedef struct MUST_USE_STRUCT LDKUntrustedString {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUntrustedString *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUntrustedString;

/**
 * The reason the channel was closed. See individual variants for more details.
 */
typedef enum LDKClosureReason_Tag {
   /**
    * Closure generated from receiving a peer error message.
    *
    * Our counterparty may have broadcasted their latest commitment state, and we have
    * as well.
    */
   LDKClosureReason_CounterpartyForceClosed,
   /**
    * Closure generated from [`ChannelManager::force_close_channel`], called by the user.
    *
    * [`ChannelManager::force_close_channel`]: crate::ln::channelmanager::ChannelManager::force_close_channel.
    */
   LDKClosureReason_HolderForceClosed,
   /**
    * The channel was closed after negotiating a cooperative close and we've now broadcasted
    * the cooperative close transaction. Note the shutdown may have been initiated by us.
    */
   LDKClosureReason_CooperativeClosure,
   /**
    * A commitment transaction was confirmed on chain, closing the channel. Most likely this
    * commitment transaction came from our counterparty, but it may also have come from
    * a copy of our own `ChannelMonitor`.
    */
   LDKClosureReason_CommitmentTxConfirmed,
   /**
    * The funding transaction failed to confirm in a timely manner on an inbound channel.
    */
   LDKClosureReason_FundingTimedOut,
   /**
    * Closure generated from processing an event, likely a HTLC forward/relay/reception.
    */
   LDKClosureReason_ProcessingError,
   /**
    * The peer disconnected prior to funding completing. In this case the spec mandates that we
    * forget the channel entirely - we can attempt again if the peer reconnects.
    *
    * This includes cases where we restarted prior to funding completion, including prior to the
    * initial [`ChannelMonitor`] persistence completing.
    *
    * In LDK versions prior to 0.0.107 this could also occur if we were unable to connect to the
    * peer because of mutual incompatibility between us and our channel counterparty.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    */
   LDKClosureReason_DisconnectedPeer,
   /**
    * Closure generated from `ChannelManager::read` if the [`ChannelMonitor`] is newer than
    * the [`ChannelManager`] deserialized.
    *
    * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   LDKClosureReason_OutdatedChannelManager,
   /**
    * The counterparty requested a cooperative close of a channel that had not been funded yet.
    * The channel has been immediately closed.
    */
   LDKClosureReason_CounterpartyCoopClosedUnfundedChannel,
   /**
    * Another channel in the same funding batch closed before the funding transaction
    * was ready to be broadcast.
    */
   LDKClosureReason_FundingBatchClosure,
   /**
    * Must be last for serialization purposes
    */
   LDKClosureReason_Sentinel,
} LDKClosureReason_Tag;

typedef struct LDKClosureReason_LDKCounterpartyForceClosed_Body {
   /**
    * The error which the peer sent us.
    *
    * Be careful about printing the peer_msg, a well-crafted message could exploit
    * a security vulnerability in the terminal emulator or the logging subsystem.
    * To be safe, use `Display` on `UntrustedString`
    *
    * [`UntrustedString`]: crate::util::string::UntrustedString
    */
   struct LDKUntrustedString peer_msg;
} LDKClosureReason_LDKCounterpartyForceClosed_Body;

typedef struct LDKClosureReason_LDKProcessingError_Body {
   /**
    * A developer-readable error message which we generated.
    */
   struct LDKStr err;
} LDKClosureReason_LDKProcessingError_Body;

typedef struct MUST_USE_STRUCT LDKClosureReason {
   LDKClosureReason_Tag tag;
   union {
      LDKClosureReason_LDKCounterpartyForceClosed_Body counterparty_force_closed;
      LDKClosureReason_LDKProcessingError_Body processing_error;
   };
} LDKClosureReason;

/**
 * An enum which can either contain a crate::lightning::events::ClosureReason or not
 */
typedef enum LDKCOption_ClosureReasonZ_Tag {
   /**
    * When we're in this state, this COption_ClosureReasonZ contains a crate::lightning::events::ClosureReason
    */
   LDKCOption_ClosureReasonZ_Some,
   /**
    * When we're in this state, this COption_ClosureReasonZ contains nothing
    */
   LDKCOption_ClosureReasonZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_ClosureReasonZ_Sentinel,
} LDKCOption_ClosureReasonZ_Tag;

typedef struct LDKCOption_ClosureReasonZ {
   LDKCOption_ClosureReasonZ_Tag tag;
   union {
      struct {
         struct LDKClosureReason some;
      };
   };
} LDKCOption_ClosureReasonZ;

/**
 * The contents of CResult_COption_ClosureReasonZDecodeErrorZ
 */
typedef union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_ClosureReasonZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_ClosureReasonZDecodeErrorZPtr;

/**
 * A CResult_COption_ClosureReasonZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_ClosureReasonZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_ClosureReasonZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_ClosureReasonZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_ClosureReasonZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_ClosureReasonZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_ClosureReasonZDecodeErrorZ;

/**
 * Intended destination of a failed HTLC as indicated in [`Event::HTLCHandlingFailed`].
 */
typedef enum LDKHTLCDestination_Tag {
   /**
    * We tried forwarding to a channel but failed to do so. An example of such an instance is when
    * there is insufficient capacity in our outbound channel.
    */
   LDKHTLCDestination_NextHopChannel,
   /**
    * Scenario where we are unsure of the next node to forward the HTLC to.
    */
   LDKHTLCDestination_UnknownNextHop,
   /**
    * We couldn't forward to the outgoing scid. An example would be attempting to send a duplicate
    * intercept HTLC.
    */
   LDKHTLCDestination_InvalidForward,
   /**
    * Failure scenario where an HTLC may have been forwarded to be intended for us,
    * but is invalid for some reason, so we reject it.
    *
    * Some of the reasons may include:
    * * HTLC Timeouts
    * * Excess HTLCs for a payment that we have already fully received, over-paying for the
    *   payment,
    * * The counterparty node modified the HTLC in transit,
    * * A probing attack where an intermediary node is trying to detect if we are the ultimate
    *   recipient for a payment.
    */
   LDKHTLCDestination_FailedPayment,
   /**
    * Must be last for serialization purposes
    */
   LDKHTLCDestination_Sentinel,
} LDKHTLCDestination_Tag;

typedef struct LDKHTLCDestination_LDKNextHopChannel_Body {
   /**
    * The `node_id` of the next node. For backwards compatibility, this field is
    * marked as optional, versions prior to 0.0.110 may not always be able to provide
    * counterparty node information.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey node_id;
   /**
    * The outgoing `channel_id` between us and the next node.
    */
   struct LDKThirtyTwoBytes channel_id;
} LDKHTLCDestination_LDKNextHopChannel_Body;

typedef struct LDKHTLCDestination_LDKUnknownNextHop_Body {
   /**
    * Short channel id we are requesting to forward an HTLC to.
    */
   uint64_t requested_forward_scid;
} LDKHTLCDestination_LDKUnknownNextHop_Body;

typedef struct LDKHTLCDestination_LDKInvalidForward_Body {
   /**
    * Short channel id we are requesting to forward an HTLC to.
    */
   uint64_t requested_forward_scid;
} LDKHTLCDestination_LDKInvalidForward_Body;

typedef struct LDKHTLCDestination_LDKFailedPayment_Body {
   /**
    * The payment hash of the payment we attempted to process.
    */
   struct LDKThirtyTwoBytes payment_hash;
} LDKHTLCDestination_LDKFailedPayment_Body;

typedef struct MUST_USE_STRUCT LDKHTLCDestination {
   LDKHTLCDestination_Tag tag;
   union {
      LDKHTLCDestination_LDKNextHopChannel_Body next_hop_channel;
      LDKHTLCDestination_LDKUnknownNextHop_Body unknown_next_hop;
      LDKHTLCDestination_LDKInvalidForward_Body invalid_forward;
      LDKHTLCDestination_LDKFailedPayment_Body failed_payment;
   };
} LDKHTLCDestination;

/**
 * An enum which can either contain a crate::lightning::events::HTLCDestination or not
 */
typedef enum LDKCOption_HTLCDestinationZ_Tag {
   /**
    * When we're in this state, this COption_HTLCDestinationZ contains a crate::lightning::events::HTLCDestination
    */
   LDKCOption_HTLCDestinationZ_Some,
   /**
    * When we're in this state, this COption_HTLCDestinationZ contains nothing
    */
   LDKCOption_HTLCDestinationZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_HTLCDestinationZ_Sentinel,
} LDKCOption_HTLCDestinationZ_Tag;

typedef struct LDKCOption_HTLCDestinationZ {
   LDKCOption_HTLCDestinationZ_Tag tag;
   union {
      struct {
         struct LDKHTLCDestination some;
      };
   };
} LDKCOption_HTLCDestinationZ;

/**
 * The contents of CResult_COption_HTLCDestinationZDecodeErrorZ
 */
typedef union LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_HTLCDestinationZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr;

/**
 * A CResult_COption_HTLCDestinationZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_HTLCDestinationZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_HTLCDestinationZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_HTLCDestinationZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_HTLCDestinationZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_HTLCDestinationZDecodeErrorZ;

/**
 * The contents of CResult_PaymentFailureReasonDecodeErrorZ
 */
typedef union LDKCResult_PaymentFailureReasonDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKPaymentFailureReason *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentFailureReasonDecodeErrorZPtr;

/**
 * A CResult_PaymentFailureReasonDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::events::PaymentFailureReason on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentFailureReasonDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentFailureReasonDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentFailureReasonDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentFailureReasonDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentFailureReasonDecodeErrorZ;

/**
 * An enum which can either contain a crate::c_types::U128 or not
 */
typedef enum LDKCOption_U128Z_Tag {
   /**
    * When we're in this state, this COption_U128Z contains a crate::c_types::U128
    */
   LDKCOption_U128Z_Some,
   /**
    * When we're in this state, this COption_U128Z contains nothing
    */
   LDKCOption_U128Z_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_U128Z_Sentinel,
} LDKCOption_U128Z_Tag;

typedef struct LDKCOption_U128Z {
   LDKCOption_U128Z_Tag tag;
   union {
      struct {
         struct LDKU128 some;
      };
   };
} LDKCOption_U128Z;

/**
 * A dynamically-allocated array of crate::lightning::events::ClaimedHTLCs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_ClaimedHTLCZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKClaimedHTLC *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_ClaimedHTLCZ;

/**
 * An enum which can either contain a crate::lightning::events::PaymentFailureReason or not
 */
typedef enum LDKCOption_PaymentFailureReasonZ_Tag {
   /**
    * When we're in this state, this COption_PaymentFailureReasonZ contains a crate::lightning::events::PaymentFailureReason
    */
   LDKCOption_PaymentFailureReasonZ_Some,
   /**
    * When we're in this state, this COption_PaymentFailureReasonZ contains nothing
    */
   LDKCOption_PaymentFailureReasonZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_PaymentFailureReasonZ_Sentinel,
} LDKCOption_PaymentFailureReasonZ_Tag;

typedef struct LDKCOption_PaymentFailureReasonZ {
   LDKCOption_PaymentFailureReasonZ_Tag tag;
   union {
      struct {
         enum LDKPaymentFailureReason some;
      };
   };
} LDKCOption_PaymentFailureReasonZ;



/**
 * A descriptor used to sign for a commitment transaction's anchor output.
 */
typedef struct MUST_USE_STRUCT LDKAnchorDescriptor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAnchorDescriptor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAnchorDescriptor;

/**
 * Represents the different types of transactions, originating from LDK, to be bumped.
 */
typedef enum LDKBumpTransactionEvent_Tag {
   /**
    * Indicates that a channel featuring anchor outputs is to be closed by broadcasting the local
    * commitment transaction. Since commitment transactions have a static feerate pre-agreed upon,
    * they may need additional fees to be attached through a child transaction using the popular
    * [Child-Pays-For-Parent](https://bitcoinops.org/en/topics/cpfp) fee bumping technique. This
    * child transaction must include the anchor input described within `anchor_descriptor` along
    * with additional inputs to meet the target feerate. Failure to meet the target feerate
    * decreases the confirmation odds of the transaction package (which includes the commitment
    * and child anchor transactions), possibly resulting in a loss of funds. Once the transaction
    * is constructed, it must be fully signed for and broadcast by the consumer of the event
    * along with the `commitment_tx` enclosed. Note that the `commitment_tx` must always be
    * broadcast first, as the child anchor transaction depends on it.
    *
    * The consumer should be able to sign for any of the additional inputs included within the
    * child anchor transaction. To sign its anchor input, an [`EcdsaChannelSigner`] should be
    * re-derived through [`AnchorDescriptor::derive_channel_signer`]. The anchor input signature
    * can be computed with [`EcdsaChannelSigner::sign_holder_anchor_input`], which can then be
    * provided to [`build_anchor_input_witness`] along with the `funding_pubkey` to obtain the
    * full witness required to spend.
    *
    * It is possible to receive more than one instance of this event if a valid child anchor
    * transaction is never broadcast or is but not with a sufficient fee to be mined. Care should
    * be taken by the consumer of the event to ensure any future iterations of the child anchor
    * transaction adhere to the [Replace-By-Fee
    * rules](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md)
    * for fee bumps to be accepted into the mempool, and eventually the chain. As the frequency of
    * these events is not user-controlled, users may ignore/drop the event if they are no longer
    * able to commit external confirmed funds to the child anchor transaction.
    *
    * The set of `pending_htlcs` on the commitment transaction to be broadcast can be inspected to
    * determine whether a significant portion of the channel's funds are allocated to HTLCs,
    * enabling users to make their own decisions regarding the importance of the commitment
    * transaction's confirmation. Note that this is not required, but simply exists as an option
    * for users to override LDK's behavior. On commitments with no HTLCs (indicated by those with
    * an empty `pending_htlcs`), confirmation of the commitment transaction can be considered to
    * be not urgent.
    *
    * [`EcdsaChannelSigner`]: crate::sign::EcdsaChannelSigner
    * [`EcdsaChannelSigner::sign_holder_anchor_input`]: crate::sign::EcdsaChannelSigner::sign_holder_anchor_input
    * [`build_anchor_input_witness`]: crate::ln::chan_utils::build_anchor_input_witness
    */
   LDKBumpTransactionEvent_ChannelClose,
   /**
    * Indicates that a channel featuring anchor outputs has unilaterally closed on-chain by a
    * holder commitment transaction and its HTLC(s) need to be resolved on-chain. With the
    * zero-HTLC-transaction-fee variant of anchor outputs, the pre-signed HTLC
    * transactions have a zero fee, thus requiring additional inputs and/or outputs to be attached
    * for a timely confirmation within the chain. These additional inputs and/or outputs must be
    * appended to the resulting HTLC transaction to meet the target feerate. Failure to meet the
    * target feerate decreases the confirmation odds of the transaction, possibly resulting in a
    * loss of funds. Once the transaction meets the target feerate, it must be signed for and
    * broadcast by the consumer of the event.
    *
    * The consumer should be able to sign for any of the non-HTLC inputs added to the resulting
    * HTLC transaction. To sign HTLC inputs, an [`EcdsaChannelSigner`] should be re-derived
    * through [`HTLCDescriptor::derive_channel_signer`]. Each HTLC input's signature can be
    * computed with [`EcdsaChannelSigner::sign_holder_htlc_transaction`], which can then be
    * provided to [`HTLCDescriptor::tx_input_witness`] to obtain the fully signed witness required
    * to spend.
    *
    * It is possible to receive more than one instance of this event if a valid HTLC transaction
    * is never broadcast or is but not with a sufficient fee to be mined. Care should be taken by
    * the consumer of the event to ensure any future iterations of the HTLC transaction adhere to
    * the [Replace-By-Fee
    * rules](https://github.com/bitcoin/bitcoin/blob/master/doc/policy/mempool-replacements.md)
    * for fee bumps to be accepted into the mempool, and eventually the chain. As the frequency of
    * these events is not user-controlled, users may ignore/drop the event if either they are no
    * longer able to commit external confirmed funds to the HTLC transaction or the fee committed
    * to the HTLC transaction is greater in value than the HTLCs being claimed.
    *
    * [`EcdsaChannelSigner`]: crate::sign::EcdsaChannelSigner
    * [`EcdsaChannelSigner::sign_holder_htlc_transaction`]: crate::sign::EcdsaChannelSigner::sign_holder_htlc_transaction
    * [`HTLCDescriptor::tx_input_witness`]: HTLCDescriptor::tx_input_witness
    */
   LDKBumpTransactionEvent_HTLCResolution,
   /**
    * Must be last for serialization purposes
    */
   LDKBumpTransactionEvent_Sentinel,
} LDKBumpTransactionEvent_Tag;

typedef struct LDKBumpTransactionEvent_LDKChannelClose_Body {
   /**
    * The unique identifier for the claim of the anchor output in the commitment transaction.
    *
    * The identifier must map to the set of external UTXOs assigned to the claim, such that
    * they can be reused when a new claim with the same identifier needs to be made, resulting
    * in a fee-bumping attempt.
    */
   struct LDKThirtyTwoBytes claim_id;
   /**
    * The target feerate that the transaction package, which consists of the commitment
    * transaction and the to-be-crafted child anchor transaction, must meet.
    */
   uint32_t package_target_feerate_sat_per_1000_weight;
   /**
    * The channel's commitment transaction to bump the fee of. This transaction should be
    * broadcast along with the anchor transaction constructed as a result of consuming this
    * event.
    */
   struct LDKTransaction commitment_tx;
   /**
    * The absolute fee in satoshis of the commitment transaction. This can be used along the
    * with weight of the commitment transaction to determine its feerate.
    */
   uint64_t commitment_tx_fee_satoshis;
   /**
    * The descriptor to sign the anchor input of the anchor transaction constructed as a
    * result of consuming this event.
    */
   struct LDKAnchorDescriptor anchor_descriptor;
   /**
    * The set of pending HTLCs on the commitment transaction that need to be resolved once the
    * commitment transaction confirms.
    */
   struct LDKCVec_HTLCOutputInCommitmentZ pending_htlcs;
} LDKBumpTransactionEvent_LDKChannelClose_Body;

typedef struct LDKBumpTransactionEvent_LDKHTLCResolution_Body {
   /**
    * The unique identifier for the claim of the HTLCs in the confirmed commitment
    * transaction.
    *
    * The identifier must map to the set of external UTXOs assigned to the claim, such that
    * they can be reused when a new claim with the same identifier needs to be made, resulting
    * in a fee-bumping attempt.
    */
   struct LDKThirtyTwoBytes claim_id;
   /**
    * The target feerate that the resulting HTLC transaction must meet.
    */
   uint32_t target_feerate_sat_per_1000_weight;
   /**
    * The set of pending HTLCs on the confirmed commitment that need to be claimed, preferably
    * by the same transaction.
    */
   struct LDKCVec_HTLCDescriptorZ htlc_descriptors;
   /**
    * The locktime required for the resulting HTLC transaction.
    */
   uint32_t tx_lock_time;
} LDKBumpTransactionEvent_LDKHTLCResolution_Body;

typedef struct MUST_USE_STRUCT LDKBumpTransactionEvent {
   LDKBumpTransactionEvent_Tag tag;
   union {
      LDKBumpTransactionEvent_LDKChannelClose_Body channel_close;
      LDKBumpTransactionEvent_LDKHTLCResolution_Body htlc_resolution;
   };
} LDKBumpTransactionEvent;

/**
 * An Event which you should probably take some action in response to.
 *
 * Note that while Writeable and Readable are implemented for Event, you probably shouldn't use
 * them directly as they don't round-trip exactly (for example FundingGenerationReady is never
 * written as it makes no sense to respond to it after reconnecting to peers).
 */
typedef enum LDKEvent_Tag {
   /**
    * Used to indicate that the client should generate a funding transaction with the given
    * parameters and then call [`ChannelManager::funding_transaction_generated`].
    * Generated in [`ChannelManager`] message handling.
    * Note that *all inputs* in the funding transaction must spend SegWit outputs or your
    * counterparty can steal your funds!
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   LDKEvent_FundingGenerationReady,
   /**
    * Indicates that we've been offered a payment and it needs to be claimed via calling
    * [`ChannelManager::claim_funds`] with the preimage given in [`PaymentPurpose`].
    *
    * Note that if the preimage is not known, you should call
    * [`ChannelManager::fail_htlc_backwards`] or [`ChannelManager::fail_htlc_backwards_with_reason`]
    * to free up resources for this HTLC and avoid network congestion.
    *
    * If [`Event::PaymentClaimable::onion_fields`] is `Some`, and includes custom TLVs with even type
    * numbers, you should use [`ChannelManager::fail_htlc_backwards_with_reason`] with
    * [`FailureCode::InvalidOnionPayload`] if you fail to understand and handle the contents, or
    * [`ChannelManager::claim_funds_with_known_custom_tlvs`] upon successful handling.
    * If you don't intend to check for custom TLVs, you can simply use
    * [`ChannelManager::claim_funds`], which will automatically fail back even custom TLVs.
    *
    * If you fail to call [`ChannelManager::claim_funds`],
    * [`ChannelManager::claim_funds_with_known_custom_tlvs`],
    * [`ChannelManager::fail_htlc_backwards`], or
    * [`ChannelManager::fail_htlc_backwards_with_reason`] within the HTLC's timeout, the HTLC will
    * be automatically failed.
    *
    * # Note
    * LDK will not stop an inbound payment from being paid multiple times, so multiple
    * `PaymentClaimable` events may be generated for the same payment. In such a case it is
    * polite (and required in the lightning specification) to fail the payment the second time
    * and give the sender their money back rather than accepting double payment.
    *
    * # Note
    * This event used to be called `PaymentReceived` in LDK versions 0.0.112 and earlier.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    * [`ChannelManager::claim_funds_with_known_custom_tlvs`]: crate::ln::channelmanager::ChannelManager::claim_funds_with_known_custom_tlvs
    * [`FailureCode::InvalidOnionPayload`]: crate::ln::channelmanager::FailureCode::InvalidOnionPayload
    * [`ChannelManager::fail_htlc_backwards`]: crate::ln::channelmanager::ChannelManager::fail_htlc_backwards
    * [`ChannelManager::fail_htlc_backwards_with_reason`]: crate::ln::channelmanager::ChannelManager::fail_htlc_backwards_with_reason
    */
   LDKEvent_PaymentClaimable,
   /**
    * Indicates a payment has been claimed and we've received money!
    *
    * This most likely occurs when [`ChannelManager::claim_funds`] has been called in response
    * to an [`Event::PaymentClaimable`]. However, if we previously crashed during a
    * [`ChannelManager::claim_funds`] call you may see this event without a corresponding
    * [`Event::PaymentClaimable`] event.
    *
    * # Note
    * LDK will not stop an inbound payment from being paid multiple times, so multiple
    * `PaymentClaimable` events may be generated for the same payment. If you then call
    * [`ChannelManager::claim_funds`] twice for the same [`Event::PaymentClaimable`] you may get
    * multiple `PaymentClaimed` events.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    */
   LDKEvent_PaymentClaimed,
   /**
    * Indicates an outbound payment we made succeeded (i.e. it made it all the way to its target
    * and we got back the payment preimage for it).
    *
    * Note for MPP payments: in rare cases, this event may be preceded by a `PaymentPathFailed`
    * event. In this situation, you SHOULD treat this payment as having succeeded.
    */
   LDKEvent_PaymentSent,
   /**
    * Indicates an outbound payment failed. Individual [`Event::PaymentPathFailed`] events
    * provide failure information for each path attempt in the payment, including retries.
    *
    * This event is provided once there are no further pending HTLCs for the payment and the
    * payment is no longer retryable, due either to the [`Retry`] provided or
    * [`ChannelManager::abandon_payment`] having been called for the corresponding payment.
    *
    * In exceedingly rare cases, it is possible that an [`Event::PaymentFailed`] is generated for
    * a payment after an [`Event::PaymentSent`] event for this same payment has already been
    * received and processed. In this case, the [`Event::PaymentFailed`] event MUST be ignored,
    * and the payment MUST be treated as having succeeded.
    *
    * [`Retry`]: crate::ln::channelmanager::Retry
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   LDKEvent_PaymentFailed,
   /**
    * Indicates that a path for an outbound payment was successful.
    *
    * Always generated after [`Event::PaymentSent`] and thus useful for scoring channels. See
    * [`Event::PaymentSent`] for obtaining the payment preimage.
    */
   LDKEvent_PaymentPathSuccessful,
   /**
    * Indicates an outbound HTLC we sent failed, likely due to an intermediary node being unable to
    * handle the HTLC.
    *
    * Note that this does *not* indicate that all paths for an MPP payment have failed, see
    * [`Event::PaymentFailed`].
    *
    * See [`ChannelManager::abandon_payment`] for giving up on this payment before its retries have
    * been exhausted.
    *
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   LDKEvent_PaymentPathFailed,
   /**
    * Indicates that a probe payment we sent returned successful, i.e., only failed at the destination.
    */
   LDKEvent_ProbeSuccessful,
   /**
    * Indicates that a probe payment we sent failed at an intermediary node on the path.
    */
   LDKEvent_ProbeFailed,
   /**
    * Used to indicate that [`ChannelManager::process_pending_htlc_forwards`] should be called at
    * a time in the future.
    *
    * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
    */
   LDKEvent_PendingHTLCsForwardable,
   /**
    * Used to indicate that we've intercepted an HTLC forward. This event will only be generated if
    * you've encoded an intercept scid in the receiver's invoice route hints using
    * [`ChannelManager::get_intercept_scid`] and have set [`UserConfig::accept_intercept_htlcs`].
    *
    * [`ChannelManager::forward_intercepted_htlc`] or
    * [`ChannelManager::fail_intercepted_htlc`] MUST be called in response to this event. See
    * their docs for more information.
    *
    * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
    * [`UserConfig::accept_intercept_htlcs`]: crate::util::config::UserConfig::accept_intercept_htlcs
    * [`ChannelManager::forward_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::forward_intercepted_htlc
    * [`ChannelManager::fail_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::fail_intercepted_htlc
    */
   LDKEvent_HTLCIntercepted,
   /**
    * Used to indicate that an output which you should know how to spend was confirmed on chain
    * and is now spendable.
    * Such an output will *not* ever be spent by rust-lightning, and are not at risk of your
    * counterparty spending them due to some kind of timeout. Thus, you need to store them
    * somewhere and spend them when you create on-chain transactions.
    */
   LDKEvent_SpendableOutputs,
   /**
    * This event is generated when a payment has been successfully forwarded through us and a
    * forwarding fee earned.
    */
   LDKEvent_PaymentForwarded,
   /**
    * Used to indicate that a channel with the given `channel_id` is being opened and pending
    * confirmation on-chain.
    *
    * This event is emitted when the funding transaction has been signed and is broadcast to the
    * network. For 0conf channels it will be immediately followed by the corresponding
    * [`Event::ChannelReady`] event.
    */
   LDKEvent_ChannelPending,
   /**
    * Used to indicate that a channel with the given `channel_id` is ready to
    * be used. This event is emitted either when the funding transaction has been confirmed
    * on-chain, or, in case of a 0conf channel, when both parties have confirmed the channel
    * establishment.
    */
   LDKEvent_ChannelReady,
   /**
    * Used to indicate that a previously opened channel with the given `channel_id` is in the
    * process of closure.
    *
    * Note that this event is only triggered for accepted channels: if the
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true and the channel is
    * rejected, no `ChannelClosed` event will be sent.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   LDKEvent_ChannelClosed,
   /**
    * Used to indicate to the user that they can abandon the funding transaction and recycle the
    * inputs for another purpose.
    *
    * This event is not guaranteed to be generated for channels that are closed due to a restart.
    */
   LDKEvent_DiscardFunding,
   /**
    * Indicates a request to open a new channel by a peer.
    *
    * To accept the request, call [`ChannelManager::accept_inbound_channel`]. To reject the request,
    * call [`ChannelManager::force_close_without_broadcasting_txn`]. Note that a ['ChannelClosed`]
    * event will _not_ be triggered if the channel is rejected.
    *
    * The event is only triggered when a new open channel request is received and the
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   LDKEvent_OpenChannelRequest,
   /**
    * Indicates that the HTLC was accepted, but could not be processed when or after attempting to
    * forward it.
    *
    * Some scenarios where this event may be sent include:
    * * Insufficient capacity in the outbound channel
    * * While waiting to forward the HTLC, the channel it is meant to be forwarded through closes
    * * When an unknown SCID is requested for forwarding a payment.
    * * Expected MPP amount has already been reached
    * * The HTLC has timed out
    *
    * This event, however, does not get generated if an HTLC fails to meet the forwarding
    * requirements (i.e. insufficient fees paid, or a CLTV that is too soon).
    */
   LDKEvent_HTLCHandlingFailed,
   /**
    * Indicates that a transaction originating from LDK needs to have its fee bumped. This event
    * requires confirmed external funds to be readily available to spend.
    *
    * LDK does not currently generate this event unless the
    * [`ChannelHandshakeConfig::negotiate_anchors_zero_fee_htlc_tx`] config flag is set to true.
    * It is limited to the scope of channels with anchor outputs.
    *
    * [`ChannelHandshakeConfig::negotiate_anchors_zero_fee_htlc_tx`]: crate::util::config::ChannelHandshakeConfig::negotiate_anchors_zero_fee_htlc_tx
    */
   LDKEvent_BumpTransaction,
   /**
    * Must be last for serialization purposes
    */
   LDKEvent_Sentinel,
} LDKEvent_Tag;

typedef struct LDKEvent_LDKFundingGenerationReady_Body {
   /**
    * The random channel_id we picked which you'll need to pass into
    * [`ChannelManager::funding_transaction_generated`].
    *
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The counterparty's node_id, which you'll need to pass back into
    * [`ChannelManager::funding_transaction_generated`].
    *
    * [`ChannelManager::funding_transaction_generated`]: crate::ln::channelmanager::ChannelManager::funding_transaction_generated
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The value, in satoshis, that the output should have.
    */
   uint64_t channel_value_satoshis;
   /**
    * The script which should be used in the transaction output.
    */
   struct LDKCVec_u8Z output_script;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for an inbound channel.  This may be zero for objects
    * serialized with LDK versions prior to 0.0.113.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
} LDKEvent_LDKFundingGenerationReady_Body;

typedef struct LDKEvent_LDKPaymentClaimable_Body {
   /**
    * The node that will receive the payment after it has been claimed.
    * This is useful to identify payments received via [phantom nodes].
    * This field will always be filled in when the event was generated by LDK versions
    * 0.0.113 and above.
    *
    * [phantom nodes]: crate::sign::PhantomKeysManager
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey receiver_node_id;
   /**
    * The hash for which the preimage should be handed to the ChannelManager. Note that LDK will
    * not stop you from registering duplicate payment hashes for inbound payments.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The fields in the onion which were received with each HTLC. Only fields which were
    * identical in each HTLC involved in the payment will be included here.
    *
    * Payments received on LDK versions prior to 0.0.115 will have this field unset.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKRecipientOnionFields onion_fields;
   /**
    * The value, in thousandths of a satoshi, that this payment is claimable for. May be greater
    * than the invoice amount.
    *
    * May be less than the invoice amount if [`ChannelConfig::accept_underpaying_htlcs`] is set
    * and the previous hop took an extra fee.
    *
    * # Note
    * If [`ChannelConfig::accept_underpaying_htlcs`] is set and you claim without verifying this
    * field, you may lose money!
    *
    * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
    */
   uint64_t amount_msat;
   /**
    * The value, in thousands of a satoshi, that was skimmed off of this payment as an extra fee
    * taken by our channel counterparty.
    *
    * Will always be 0 unless [`ChannelConfig::accept_underpaying_htlcs`] is set.
    *
    * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
    */
   uint64_t counterparty_skimmed_fee_msat;
   /**
    * Information for claiming this received payment, based on whether the purpose of the
    * payment is to pay an invoice or to send a spontaneous payment.
    */
   struct LDKPaymentPurpose purpose;
   /**
    * The `channel_id` indicating over which channel we received the payment.
    */
   struct LDKCOption_ThirtyTwoBytesZ via_channel_id;
   /**
    * The `user_channel_id` indicating over which channel we received the payment.
    */
   struct LDKCOption_U128Z via_user_channel_id;
   /**
    * The block height at which this payment will be failed back and will no longer be
    * eligible for claiming.
    *
    * Prior to this height, a call to [`ChannelManager::claim_funds`] is guaranteed to
    * succeed, however you should wait for [`Event::PaymentClaimed`] to be sure.
    *
    * [`ChannelManager::claim_funds`]: crate::ln::channelmanager::ChannelManager::claim_funds
    */
   struct LDKCOption_u32Z claim_deadline;
} LDKEvent_LDKPaymentClaimable_Body;

typedef struct LDKEvent_LDKPaymentClaimed_Body {
   /**
    * The node that received the payment.
    * This is useful to identify payments which were received via [phantom nodes].
    * This field will always be filled in when the event was generated by LDK versions
    * 0.0.113 and above.
    *
    * [phantom nodes]: crate::sign::PhantomKeysManager
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey receiver_node_id;
   /**
    * The payment hash of the claimed payment. Note that LDK will not stop you from
    * registering duplicate payment hashes for inbound payments.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The value, in thousandths of a satoshi, that this payment is for. May be greater than the
    * invoice amount.
    */
   uint64_t amount_msat;
   /**
    * The purpose of the claimed payment, i.e. whether the payment was for an invoice or a
    * spontaneous payment.
    */
   struct LDKPaymentPurpose purpose;
   /**
    * The HTLCs that comprise the claimed payment. This will be empty for events serialized prior
    * to LDK version 0.0.117.
    */
   struct LDKCVec_ClaimedHTLCZ htlcs;
   /**
    * The sender-intended sum total of all the MPP parts. This will be `None` for events
    * serialized prior to LDK version 0.0.117.
    */
   struct LDKCOption_u64Z sender_intended_total_msat;
} LDKEvent_LDKPaymentClaimed_Body;

typedef struct LDKEvent_LDKPaymentSent_Body {
   /**
    * The `payment_id` passed to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKCOption_ThirtyTwoBytesZ payment_id;
   /**
    * The preimage to the hash given to ChannelManager::send_payment.
    * Note that this serves as a payment receipt, if you wish to have such a thing, you must
    * store it somehow!
    */
   struct LDKThirtyTwoBytes payment_preimage;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The total fee which was spent at intermediate hops in this payment, across all paths.
    *
    * Note that, like [`Route::get_total_fees`] this does *not* include any potential
    * overpayment to the recipient node.
    *
    * If the recipient or an intermediate node misbehaves and gives us free money, this may
    * overstate the amount paid, though this is unlikely.
    *
    * [`Route::get_total_fees`]: crate::routing::router::Route::get_total_fees
    */
   struct LDKCOption_u64Z fee_paid_msat;
} LDKEvent_LDKPaymentSent_Body;

typedef struct LDKEvent_LDKPaymentFailed_Body {
   /**
    * The `payment_id` passed to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The reason the payment failed. This is only `None` for events generated or serialized
    * by versions prior to 0.0.115.
    */
   struct LDKCOption_PaymentFailureReasonZ reason;
} LDKEvent_LDKPaymentFailed_Body;

typedef struct LDKEvent_LDKPaymentPathSuccessful_Body {
   /**
    * The `payment_id` passed to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * This will be `Some` for all payments which completed on LDK 0.0.104 or later.
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKCOption_ThirtyTwoBytesZ payment_hash;
   /**
    * The payment path that was successful.
    *
    * May contain a closed channel if the HTLC sent along the path was fulfilled on chain.
    */
   struct LDKPath path;
} LDKEvent_LDKPaymentPathSuccessful_Body;

typedef struct LDKEvent_LDKPaymentPathFailed_Body {
   /**
    * The `payment_id` passed to [`ChannelManager::send_payment`].
    *
    * This will be `Some` for all payment paths which failed on LDK 0.0.103 or later.
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    * [`ChannelManager::abandon_payment`]: crate::ln::channelmanager::ChannelManager::abandon_payment
    */
   struct LDKCOption_ThirtyTwoBytesZ payment_id;
   /**
    * The hash that was given to [`ChannelManager::send_payment`].
    *
    * [`ChannelManager::send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * Indicates the payment was rejected for some reason by the recipient. This implies that
    * the payment has failed, not just the route in question. If this is not set, the payment may
    * be retried via a different route.
    */
   bool payment_failed_permanently;
   /**
    * Extra error details based on the failure type. May contain an update that needs to be
    * applied to the [`NetworkGraph`].
    *
    * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
    */
   struct LDKPathFailure failure;
   /**
    * The payment path that failed.
    */
   struct LDKPath path;
   /**
    * The channel responsible for the failed payment path.
    *
    * Note that for route hints or for the first hop in a path this may be an SCID alias and
    * may not refer to a channel in the public network graph. These aliases may also collide
    * with channels in the public network graph.
    *
    * If this is `Some`, then the corresponding channel should be avoided when the payment is
    * retried. May be `None` for older [`Event`] serializations.
    */
   struct LDKCOption_u64Z short_channel_id;
} LDKEvent_LDKPaymentPathFailed_Body;

typedef struct LDKEvent_LDKProbeSuccessful_Body {
   /**
    * The id returned by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash generated by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that was successful.
    */
   struct LDKPath path;
} LDKEvent_LDKProbeSuccessful_Body;

typedef struct LDKEvent_LDKProbeFailed_Body {
   /**
    * The id returned by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_id;
   /**
    * The hash generated by [`ChannelManager::send_probe`].
    *
    * [`ChannelManager::send_probe`]: crate::ln::channelmanager::ChannelManager::send_probe
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * The payment path that failed.
    */
   struct LDKPath path;
   /**
    * The channel responsible for the failed probe.
    *
    * Note that for route hints or for the first hop in a path this may be an SCID alias and
    * may not refer to a channel in the public network graph. These aliases may also collide
    * with channels in the public network graph.
    */
   struct LDKCOption_u64Z short_channel_id;
} LDKEvent_LDKProbeFailed_Body;

typedef struct LDKEvent_LDKPendingHTLCsForwardable_Body {
   /**
    * The minimum amount of time that should be waited prior to calling
    * process_pending_htlc_forwards. To increase the effort required to correlate payments,
    * you should wait a random amount of time in roughly the range (now + time_forwardable,
    * now + 5*time_forwardable).
    */
   uint64_t time_forwardable;
} LDKEvent_LDKPendingHTLCsForwardable_Body;

typedef struct LDKEvent_LDKHTLCIntercepted_Body {
   /**
    * An id to help LDK identify which HTLC is being forwarded or failed.
    */
   struct LDKThirtyTwoBytes intercept_id;
   /**
    * The fake scid that was programmed as the next hop's scid, generated using
    * [`ChannelManager::get_intercept_scid`].
    *
    * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
    */
   uint64_t requested_next_hop_scid;
   /**
    * The payment hash used for this HTLC.
    */
   struct LDKThirtyTwoBytes payment_hash;
   /**
    * How many msats were received on the inbound edge of this HTLC.
    */
   uint64_t inbound_amount_msat;
   /**
    * How many msats the payer intended to route to the next node. Depending on the reason you are
    * intercepting this payment, you might take a fee by forwarding less than this amount.
    * Forwarding less than this amount may break compatibility with LDK versions prior to 0.0.116.
    *
    * Note that LDK will NOT check that expected fees were factored into this value. You MUST
    * check that whatever fee you want has been included here or subtract it as required. Further,
    * LDK will not stop you from forwarding more than you received.
    */
   uint64_t expected_outbound_amount_msat;
} LDKEvent_LDKHTLCIntercepted_Body;

typedef struct LDKEvent_LDKSpendableOutputs_Body {
   /**
    * The outputs which you should store as spendable by you.
    */
   struct LDKCVec_SpendableOutputDescriptorZ outputs;
   /**
    * The `channel_id` indicating which channel the spendable outputs belong to.
    *
    * This will always be `Some` for events generated by LDK versions 0.0.117 and above.
    */
   struct LDKCOption_ThirtyTwoBytesZ channel_id;
} LDKEvent_LDKSpendableOutputs_Body;

typedef struct LDKEvent_LDKPaymentForwarded_Body {
   /**
    * The incoming channel between the previous node and us. This is only `None` for events
    * generated or serialized by versions prior to 0.0.107.
    */
   struct LDKCOption_ThirtyTwoBytesZ prev_channel_id;
   /**
    * The outgoing channel between the next node and us. This is only `None` for events
    * generated or serialized by versions prior to 0.0.107.
    */
   struct LDKCOption_ThirtyTwoBytesZ next_channel_id;
   /**
    * The fee, in milli-satoshis, which was earned as a result of the payment.
    *
    * Note that if we force-closed the channel over which we forwarded an HTLC while the HTLC
    * was pending, the amount the next hop claimed will have been rounded down to the nearest
    * whole satoshi. Thus, the fee calculated here may be higher than expected as we still
    * claimed the full value in millisatoshis from the source. In this case,
    * `claim_from_onchain_tx` will be set.
    *
    * If the channel which sent us the payment has been force-closed, we will claim the funds
    * via an on-chain transaction. In that case we do not yet know the on-chain transaction
    * fees which we will spend and will instead set this to `None`. It is possible duplicate
    * `PaymentForwarded` events are generated for the same payment iff `fee_earned_msat` is
    * `None`.
    */
   struct LDKCOption_u64Z fee_earned_msat;
   /**
    * If this is `true`, the forwarded HTLC was claimed by our counterparty via an on-chain
    * transaction.
    */
   bool claim_from_onchain_tx;
   /**
    * The final amount forwarded, in milli-satoshis, after the fee is deducted.
    *
    * The caveat described above the `fee_earned_msat` field applies here as well.
    */
   struct LDKCOption_u64Z outbound_amount_forwarded_msat;
} LDKEvent_LDKPaymentForwarded_Body;

typedef struct LDKEvent_LDKChannelPending_Body {
   /**
    * The `channel_id` of the channel that is pending confirmation.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for an inbound channel.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
   /**
    * The `temporary_channel_id` this channel used to be known by during channel establishment.
    *
    * Will be `None` for channels created prior to LDK version 0.0.115.
    */
   struct LDKCOption_ThirtyTwoBytesZ former_temporary_channel_id;
   /**
    * The `node_id` of the channel counterparty.
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The outpoint of the channel's funding transaction.
    */
   struct LDKOutPoint funding_txo;
} LDKEvent_LDKChannelPending_Body;

typedef struct LDKEvent_LDKChannelReady_Body {
   /**
    * The `channel_id` of the channel that is ready.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for an inbound channel.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
   /**
    * The `node_id` of the channel counterparty.
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The features that this channel will operate with.
    */
   struct LDKChannelTypeFeatures channel_type;
} LDKEvent_LDKChannelReady_Body;

typedef struct LDKEvent_LDKChannelClosed_Body {
   /**
    * The `channel_id` of the channel which has been closed. Note that on-chain transactions
    * resolving the channel are likely still awaiting confirmation.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
    * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
    * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
    * `user_channel_id` will be randomized for inbound channels.
    * This may be zero for inbound channels serialized prior to 0.0.113 and will always be
    * zero for objects serialized with LDK versions prior to 0.0.102.
    *
    * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
    */
   struct LDKU128 user_channel_id;
   /**
    * The reason the channel was closed.
    */
   struct LDKClosureReason reason;
   /**
    * Counterparty in the closed channel.
    *
    * This field will be `None` for objects serialized prior to LDK 0.0.117.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * Channel capacity of the closing channel (sats).
    *
    * This field will be `None` for objects serialized prior to LDK 0.0.117.
    */
   struct LDKCOption_u64Z channel_capacity_sats;
} LDKEvent_LDKChannelClosed_Body;

typedef struct LDKEvent_LDKDiscardFunding_Body {
   /**
    * The channel_id of the channel which has been closed.
    */
   struct LDKThirtyTwoBytes channel_id;
   /**
    * The full transaction received from the user
    */
   struct LDKTransaction transaction;
} LDKEvent_LDKDiscardFunding_Body;

typedef struct LDKEvent_LDKOpenChannelRequest_Body {
   /**
    * The temporary channel ID of the channel requested to be opened.
    *
    * When responding to the request, the `temporary_channel_id` should be passed
    * back to the ChannelManager through [`ChannelManager::accept_inbound_channel`] to accept,
    * or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    */
   struct LDKThirtyTwoBytes temporary_channel_id;
   /**
    * The node_id of the counterparty requesting to open the channel.
    *
    * When responding to the request, the `counterparty_node_id` should be passed
    * back to the `ChannelManager` through [`ChannelManager::accept_inbound_channel`] to
    * accept the request, or through [`ChannelManager::force_close_without_broadcasting_txn`] to reject the
    * request.
    *
    * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
    * [`ChannelManager::force_close_without_broadcasting_txn`]: crate::ln::channelmanager::ChannelManager::force_close_without_broadcasting_txn
    */
   struct LDKPublicKey counterparty_node_id;
   /**
    * The channel value of the requested channel.
    */
   uint64_t funding_satoshis;
   /**
    * Our starting balance in the channel if the request is accepted, in milli-satoshi.
    */
   uint64_t push_msat;
   /**
    * The features that this channel will operate with. If you reject the channel, a
    * well-behaved counterparty may automatically re-attempt the channel with a new set of
    * feature flags.
    *
    * Note that if [`ChannelTypeFeatures::supports_scid_privacy`] returns true on this type,
    * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
    * 0.0.106.
    *
    * Furthermore, note that if [`ChannelTypeFeatures::supports_zero_conf`] returns true on this type,
    * the resulting [`ChannelManager`] will not be readable by versions of LDK prior to
    * 0.0.107. Channels setting this type also need to get manually accepted via
    * [`crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`],
    * or will be rejected otherwise.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    */
   struct LDKChannelTypeFeatures channel_type;
} LDKEvent_LDKOpenChannelRequest_Body;

typedef struct LDKEvent_LDKHTLCHandlingFailed_Body {
   /**
    * The channel over which the HTLC was received.
    */
   struct LDKThirtyTwoBytes prev_channel_id;
   /**
    * Destination of the HTLC that failed to be processed.
    */
   struct LDKHTLCDestination failed_next_destination;
} LDKEvent_LDKHTLCHandlingFailed_Body;

typedef struct MUST_USE_STRUCT LDKEvent {
   LDKEvent_Tag tag;
   union {
      LDKEvent_LDKFundingGenerationReady_Body funding_generation_ready;
      LDKEvent_LDKPaymentClaimable_Body payment_claimable;
      LDKEvent_LDKPaymentClaimed_Body payment_claimed;
      LDKEvent_LDKPaymentSent_Body payment_sent;
      LDKEvent_LDKPaymentFailed_Body payment_failed;
      LDKEvent_LDKPaymentPathSuccessful_Body payment_path_successful;
      LDKEvent_LDKPaymentPathFailed_Body payment_path_failed;
      LDKEvent_LDKProbeSuccessful_Body probe_successful;
      LDKEvent_LDKProbeFailed_Body probe_failed;
      LDKEvent_LDKPendingHTLCsForwardable_Body pending_htl_cs_forwardable;
      LDKEvent_LDKHTLCIntercepted_Body htlc_intercepted;
      LDKEvent_LDKSpendableOutputs_Body spendable_outputs;
      LDKEvent_LDKPaymentForwarded_Body payment_forwarded;
      LDKEvent_LDKChannelPending_Body channel_pending;
      LDKEvent_LDKChannelReady_Body channel_ready;
      LDKEvent_LDKChannelClosed_Body channel_closed;
      LDKEvent_LDKDiscardFunding_Body discard_funding;
      LDKEvent_LDKOpenChannelRequest_Body open_channel_request;
      LDKEvent_LDKHTLCHandlingFailed_Body htlc_handling_failed;
      struct {
         struct LDKBumpTransactionEvent bump_transaction;
      };
   };
} LDKEvent;

/**
 * An enum which can either contain a crate::lightning::events::Event or not
 */
typedef enum LDKCOption_EventZ_Tag {
   /**
    * When we're in this state, this COption_EventZ contains a crate::lightning::events::Event
    */
   LDKCOption_EventZ_Some,
   /**
    * When we're in this state, this COption_EventZ contains nothing
    */
   LDKCOption_EventZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_EventZ_Sentinel,
} LDKCOption_EventZ_Tag;

typedef struct LDKCOption_EventZ {
   LDKCOption_EventZ_Tag tag;
   union {
      struct {
         struct LDKEvent some;
      };
   };
} LDKCOption_EventZ;

/**
 * The contents of CResult_COption_EventZDecodeErrorZ
 */
typedef union LDKCResult_COption_EventZDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCOption_EventZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_COption_EventZDecodeErrorZPtr;

/**
 * A CResult_COption_EventZDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::COption_EventZ on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_COption_EventZDecodeErrorZ {
   /**
    * The contents of this CResult_COption_EventZDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_COption_EventZDecodeErrorZPtr contents;
   /**
    * Whether this CResult_COption_EventZDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_COption_EventZDecodeErrorZ;

/**
 * Sub-errors which don't have specific information in them use this type.
 */
typedef struct LDKError {
   /**
    * Zero-Sized_types aren't consistent across Rust/C/C++, so we add some size here
    */
   uint8_t _dummy;
} LDKError;

/**
 * Errors that indicate what is wrong with the invoice. They have some granularity for debug
 * reasons, but should generally result in an \"invalid BOLT11 invoice\" message for the user.
 */
typedef enum LDKBolt11ParseError_Tag {
   LDKBolt11ParseError_Bech32Error,
   LDKBolt11ParseError_ParseAmountError,
   LDKBolt11ParseError_MalformedSignature,
   LDKBolt11ParseError_BadPrefix,
   LDKBolt11ParseError_UnknownCurrency,
   LDKBolt11ParseError_UnknownSiPrefix,
   LDKBolt11ParseError_MalformedHRP,
   LDKBolt11ParseError_TooShortDataPart,
   LDKBolt11ParseError_UnexpectedEndOfTaggedFields,
   LDKBolt11ParseError_DescriptionDecodeError,
   LDKBolt11ParseError_PaddingError,
   LDKBolt11ParseError_IntegerOverflowError,
   LDKBolt11ParseError_InvalidSegWitProgramLength,
   LDKBolt11ParseError_InvalidPubKeyHashLength,
   LDKBolt11ParseError_InvalidScriptHashLength,
   LDKBolt11ParseError_InvalidRecoveryId,
   LDKBolt11ParseError_InvalidSliceLength,
   /**
    * Not an error, but used internally to signal that a part of the invoice should be ignored
    * according to BOLT11
    */
   LDKBolt11ParseError_Skip,
   /**
    * Must be last for serialization purposes
    */
   LDKBolt11ParseError_Sentinel,
} LDKBolt11ParseError_Tag;

typedef struct MUST_USE_STRUCT LDKBolt11ParseError {
   LDKBolt11ParseError_Tag tag;
   union {
      struct {
         struct LDKBech32Error bech32_error;
      };
      struct {
         struct LDKError parse_amount_error;
      };
      struct {
         enum LDKSecp256k1Error malformed_signature;
      };
      struct {
         struct LDKError description_decode_error;
      };
      struct {
         struct LDKStr invalid_slice_length;
      };
   };
} LDKBolt11ParseError;

/**
 * The contents of CResult_SiPrefixBolt11ParseErrorZ
 */
typedef union LDKCResult_SiPrefixBolt11ParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   enum LDKSiPrefix *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKBolt11ParseError *err;
} LDKCResult_SiPrefixBolt11ParseErrorZPtr;

/**
 * A CResult_SiPrefixBolt11ParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SiPrefix on success and a crate::lightning_invoice::Bolt11ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SiPrefixBolt11ParseErrorZ {
   /**
    * The contents of this CResult_SiPrefixBolt11ParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SiPrefixBolt11ParseErrorZPtr contents;
   /**
    * Whether this CResult_SiPrefixBolt11ParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SiPrefixBolt11ParseErrorZ;

/**
 * Indicates that something went wrong while parsing or validating the invoice. Parsing errors
 * should be mostly seen as opaque and are only there for debugging reasons. Semantic errors
 * like wrong signatures, missing fields etc. could mean that someone tampered with the invoice.
 */
typedef enum LDKParseOrSemanticError_Tag {
   /**
    * The invoice couldn't be decoded
    */
   LDKParseOrSemanticError_ParseError,
   /**
    * The invoice could be decoded but violates the BOLT11 standard
    */
   LDKParseOrSemanticError_SemanticError,
   /**
    * Must be last for serialization purposes
    */
   LDKParseOrSemanticError_Sentinel,
} LDKParseOrSemanticError_Tag;

typedef struct MUST_USE_STRUCT LDKParseOrSemanticError {
   LDKParseOrSemanticError_Tag tag;
   union {
      struct {
         struct LDKBolt11ParseError parse_error;
      };
      struct {
         enum LDKBolt11SemanticError semantic_error;
      };
   };
} LDKParseOrSemanticError;

/**
 * The contents of CResult_Bolt11InvoiceParseOrSemanticErrorZ
 */
typedef union LDKCResult_Bolt11InvoiceParseOrSemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBolt11Invoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKParseOrSemanticError *err;
} LDKCResult_Bolt11InvoiceParseOrSemanticErrorZPtr;

/**
 * A CResult_Bolt11InvoiceParseOrSemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::ParseOrSemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ {
   /**
    * The contents of this CResult_Bolt11InvoiceParseOrSemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_Bolt11InvoiceParseOrSemanticErrorZPtr contents;
   /**
    * Whether this CResult_Bolt11InvoiceParseOrSemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ;



/**
 * Represents a signed [`RawBolt11Invoice`] with cached hash. The signature is not checked and may be
 * invalid.
 *
 * # Invariants
 * The hash has to be either from the deserialized invoice or from the serialized [`RawBolt11Invoice`].
 */
typedef struct MUST_USE_STRUCT LDKSignedRawBolt11Invoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSignedRawBolt11Invoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSignedRawBolt11Invoice;

/**
 * The contents of CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ
 */
typedef union LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKSignedRawBolt11Invoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKBolt11ParseError *err;
} LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr;

/**
 * A CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::SignedRawBolt11Invoice on success and a crate::lightning_invoice::Bolt11ParseError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ {
   /**
    * The contents of this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZPtr contents;
   /**
    * Whether this CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ;



/**
 * Represents an syntactically correct [`Bolt11Invoice`] for a payment on the lightning network,
 * but without the signature information.
 * Decoding and encoding should not lead to information loss but may lead to different hashes.
 *
 * For methods without docs see the corresponding methods in [`Bolt11Invoice`].
 */
typedef struct MUST_USE_STRUCT LDKRawBolt11Invoice {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawBolt11Invoice *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawBolt11Invoice;



/**
 * Recoverable signature
 */
typedef struct MUST_USE_STRUCT LDKBolt11InvoiceSignature {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBolt11InvoiceSignature *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBolt11InvoiceSignature;

/**
 * A tuple of 3 elements. See the individual fields for the types contained.
 */
typedef struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ {
   /**
    * The element at position 0
    */
   struct LDKRawBolt11Invoice a;
   /**
    * The element at position 1
    */
   struct LDKThirtyTwoBytes b;
   /**
    * The element at position 2
    */
   struct LDKBolt11InvoiceSignature c;
} LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ;



/**
 * Payee public key
 */
typedef struct MUST_USE_STRUCT LDKPayeePubKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePayeePubKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPayeePubKey;

/**
 * The contents of CResult_PayeePubKeySecp256k1ErrorZ
 */
typedef union LDKCResult_PayeePubKeySecp256k1ErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPayeePubKey *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_PayeePubKeySecp256k1ErrorZPtr;

/**
 * A CResult_PayeePubKeySecp256k1ErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PayeePubKey on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PayeePubKeySecp256k1ErrorZ {
   /**
    * The contents of this CResult_PayeePubKeySecp256k1ErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PayeePubKeySecp256k1ErrorZPtr contents;
   /**
    * Whether this CResult_PayeePubKeySecp256k1ErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PayeePubKeySecp256k1ErrorZ;



/**
 * Private routing information
 *
 * # Invariants
 * The encoded route has to be <1024 5bit characters long (<=639 bytes or <=12 hops)
 *
 */
typedef struct MUST_USE_STRUCT LDKPrivateRoute {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrivateRoute *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrivateRoute;

/**
 * A dynamically-allocated array of crate::lightning_invoice::PrivateRoutes of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_PrivateRouteZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKPrivateRoute *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_PrivateRouteZ;



/**
 * A timestamp that refers to a date after 1 January 1970.
 *
 * # Invariants
 *
 * The Unix timestamp representing the stored time has to be positive and no greater than
 * [`MAX_TIMESTAMP`].
 */
typedef struct MUST_USE_STRUCT LDKPositiveTimestamp {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePositiveTimestamp *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPositiveTimestamp;

/**
 * The contents of CResult_PositiveTimestampCreationErrorZ
 */
typedef union LDKCResult_PositiveTimestampCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPositiveTimestamp *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PositiveTimestampCreationErrorZPtr;

/**
 * A CResult_PositiveTimestampCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PositiveTimestamp on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PositiveTimestampCreationErrorZ {
   /**
    * The contents of this CResult_PositiveTimestampCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PositiveTimestampCreationErrorZPtr contents;
   /**
    * Whether this CResult_PositiveTimestampCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PositiveTimestampCreationErrorZ;

/**
 * The contents of CResult_NoneBolt11SemanticErrorZ
 */
typedef union LDKCResult_NoneBolt11SemanticErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKBolt11SemanticError *err;
} LDKCResult_NoneBolt11SemanticErrorZPtr;

/**
 * A CResult_NoneBolt11SemanticErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneBolt11SemanticErrorZ {
   /**
    * The contents of this CResult_NoneBolt11SemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneBolt11SemanticErrorZPtr contents;
   /**
    * Whether this CResult_NoneBolt11SemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneBolt11SemanticErrorZ;

/**
 * The contents of CResult_Bolt11InvoiceBolt11SemanticErrorZ
 */
typedef union LDKCResult_Bolt11InvoiceBolt11SemanticErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBolt11Invoice *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKBolt11SemanticError *err;
} LDKCResult_Bolt11InvoiceBolt11SemanticErrorZPtr;

/**
 * A CResult_Bolt11InvoiceBolt11SemanticErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Bolt11Invoice on success and a crate::lightning_invoice::Bolt11SemanticError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ {
   /**
    * The contents of this CResult_Bolt11InvoiceBolt11SemanticErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_Bolt11InvoiceBolt11SemanticErrorZPtr contents;
   /**
    * Whether this CResult_Bolt11InvoiceBolt11SemanticErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ;



/**
 * Description string
 *
 * # Invariants
 * The description can be at most 639 __bytes__ long
 */
typedef struct MUST_USE_STRUCT LDKDescription {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDescription *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDescription;

/**
 * The contents of CResult_DescriptionCreationErrorZ
 */
typedef union LDKCResult_DescriptionCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKDescription *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_DescriptionCreationErrorZPtr;

/**
 * A CResult_DescriptionCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::Description on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_DescriptionCreationErrorZ {
   /**
    * The contents of this CResult_DescriptionCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_DescriptionCreationErrorZPtr contents;
   /**
    * Whether this CResult_DescriptionCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_DescriptionCreationErrorZ;

/**
 * The contents of CResult_PrivateRouteCreationErrorZ
 */
typedef union LDKCResult_PrivateRouteCreationErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPrivateRoute *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKCreationError *err;
} LDKCResult_PrivateRouteCreationErrorZPtr;

/**
 * A CResult_PrivateRouteCreationErrorZ represents the result of a fallible operation,
 * containing a crate::lightning_invoice::PrivateRoute on success and a crate::lightning_invoice::CreationError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PrivateRouteCreationErrorZ {
   /**
    * The contents of this CResult_PrivateRouteCreationErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PrivateRouteCreationErrorZPtr contents;
   /**
    * Whether this CResult_PrivateRouteCreationErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PrivateRouteCreationErrorZ;

/**
 * The contents of CResult_OutPointDecodeErrorZ
 */
typedef union LDKCResult_OutPointDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOutPoint *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_OutPointDecodeErrorZPtr;

/**
 * A CResult_OutPointDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::transaction::OutPoint on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OutPointDecodeErrorZ {
   /**
    * The contents of this CResult_OutPointDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OutPointDecodeErrorZPtr contents;
   /**
    * Whether this CResult_OutPointDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OutPointDecodeErrorZ;



/**
 * Lightning TLV uses a custom variable-length integer called `BigSize`. It is similar to Bitcoin's
 * variable-length integers except that it is serialized in big-endian instead of little-endian.
 *
 * Like Bitcoin's variable-length integer, it exhibits ambiguity in that certain values can be
 * encoded in several different ways, which we must check for at deserialization-time. Thus, if
 * you're looking for an example of a variable-length integer to use for your own project, move
 * along, this is a rather poor design.
 */
typedef struct MUST_USE_STRUCT LDKBigSize {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBigSize *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBigSize;

/**
 * The contents of CResult_BigSizeDecodeErrorZ
 */
typedef union LDKCResult_BigSizeDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBigSize *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BigSizeDecodeErrorZPtr;

/**
 * A CResult_BigSizeDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::ser::BigSize on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BigSizeDecodeErrorZ {
   /**
    * The contents of this CResult_BigSizeDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BigSizeDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BigSizeDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BigSizeDecodeErrorZ;

/**
 * The contents of CResult_HostnameDecodeErrorZ
 */
typedef union LDKCResult_HostnameDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKHostname *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_HostnameDecodeErrorZPtr;

/**
 * A CResult_HostnameDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::ser::Hostname on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_HostnameDecodeErrorZ {
   /**
    * The contents of this CResult_HostnameDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_HostnameDecodeErrorZPtr contents;
   /**
    * Whether this CResult_HostnameDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_HostnameDecodeErrorZ;



/**
 * A wrapper for a `Transaction` which can only be constructed with [`TransactionU16LenLimited::new`]
 * if the `Transaction`'s consensus-serialized length is <= u16::MAX.
 *
 * Use [`TransactionU16LenLimited::into_transaction`] to convert into the contained `Transaction`.
 */
typedef struct MUST_USE_STRUCT LDKTransactionU16LenLimited {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTransactionU16LenLimited *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTransactionU16LenLimited;

/**
 * The contents of CResult_TransactionU16LenLimitedNoneZ
 */
typedef union LDKCResult_TransactionU16LenLimitedNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransactionU16LenLimited *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_TransactionU16LenLimitedNoneZPtr;

/**
 * A CResult_TransactionU16LenLimitedNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionU16LenLimitedNoneZ {
   /**
    * The contents of this CResult_TransactionU16LenLimitedNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionU16LenLimitedNoneZPtr contents;
   /**
    * Whether this CResult_TransactionU16LenLimitedNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionU16LenLimitedNoneZ;

/**
 * The contents of CResult_TransactionU16LenLimitedDecodeErrorZ
 */
typedef union LDKCResult_TransactionU16LenLimitedDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKTransactionU16LenLimited *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_TransactionU16LenLimitedDecodeErrorZPtr;

/**
 * A CResult_TransactionU16LenLimitedDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::ser::TransactionU16LenLimited on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ {
   /**
    * The contents of this CResult_TransactionU16LenLimitedDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_TransactionU16LenLimitedDecodeErrorZPtr contents;
   /**
    * Whether this CResult_TransactionU16LenLimitedDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_TransactionU16LenLimitedDecodeErrorZ;

/**
 * The contents of CResult_UntrustedStringDecodeErrorZ
 */
typedef union LDKCResult_UntrustedStringDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKUntrustedString *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_UntrustedStringDecodeErrorZPtr;

/**
 * A CResult_UntrustedStringDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::util::string::UntrustedString on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_UntrustedStringDecodeErrorZ {
   /**
    * The contents of this CResult_UntrustedStringDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_UntrustedStringDecodeErrorZPtr contents;
   /**
    * Whether this CResult_UntrustedStringDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_UntrustedStringDecodeErrorZ;



/**
 * Data to construct a [`BlindedHop`] for receiving a payment. This payload is custom to LDK and
 * may not be valid if received by another lightning implementation.
 */
typedef struct MUST_USE_STRUCT LDKReceiveTlvs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReceiveTlvs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReceiveTlvs;

/**
 * The contents of CResult_ReceiveTlvsDecodeErrorZ
 */
typedef union LDKCResult_ReceiveTlvsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKReceiveTlvs *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_ReceiveTlvsDecodeErrorZPtr;

/**
 * A CResult_ReceiveTlvsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::payment::ReceiveTlvs on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ReceiveTlvsDecodeErrorZ {
   /**
    * The contents of this CResult_ReceiveTlvsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ReceiveTlvsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_ReceiveTlvsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ReceiveTlvsDecodeErrorZ;



/**
 * Parameters for relaying over a given [`BlindedHop`].
 *
 * [`BlindedHop`]: crate::blinded_path::BlindedHop
 */
typedef struct MUST_USE_STRUCT LDKPaymentRelay {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePaymentRelay *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPaymentRelay;

/**
 * The contents of CResult_PaymentRelayDecodeErrorZ
 */
typedef union LDKCResult_PaymentRelayDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentRelay *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentRelayDecodeErrorZPtr;

/**
 * A CResult_PaymentRelayDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::payment::PaymentRelay on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentRelayDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentRelayDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentRelayDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentRelayDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentRelayDecodeErrorZ;



/**
 * Constraints for relaying over a given [`BlindedHop`].
 *
 * [`BlindedHop`]: crate::blinded_path::BlindedHop
 */
typedef struct MUST_USE_STRUCT LDKPaymentConstraints {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePaymentConstraints *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPaymentConstraints;

/**
 * The contents of CResult_PaymentConstraintsDecodeErrorZ
 */
typedef union LDKCResult_PaymentConstraintsDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKPaymentConstraints *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_PaymentConstraintsDecodeErrorZPtr;

/**
 * A CResult_PaymentConstraintsDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::payment::PaymentConstraints on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_PaymentConstraintsDecodeErrorZ {
   /**
    * The contents of this CResult_PaymentConstraintsDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_PaymentConstraintsDecodeErrorZPtr contents;
   /**
    * Whether this CResult_PaymentConstraintsDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_PaymentConstraintsDecodeErrorZ;

/**
 * An error that may occur when making a payment.
 */
typedef enum LDKPaymentError_Tag {
   /**
    * An error resulting from the provided [`Bolt11Invoice`] or payment hash.
    */
   LDKPaymentError_Invoice,
   /**
    * An error occurring when sending a payment.
    */
   LDKPaymentError_Sending,
   /**
    * Must be last for serialization purposes
    */
   LDKPaymentError_Sentinel,
} LDKPaymentError_Tag;

typedef struct MUST_USE_STRUCT LDKPaymentError {
   LDKPaymentError_Tag tag;
   union {
      struct {
         struct LDKStr invoice;
      };
      struct {
         enum LDKRetryableSendFailure sending;
      };
   };
} LDKPaymentError;

/**
 * The contents of CResult_ThirtyTwoBytesPaymentErrorZ
 */
typedef union LDKCResult_ThirtyTwoBytesPaymentErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKThirtyTwoBytes *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentError *err;
} LDKCResult_ThirtyTwoBytesPaymentErrorZPtr;

/**
 * A CResult_ThirtyTwoBytesPaymentErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::ThirtyTwoBytes on success and a crate::lightning_invoice::payment::PaymentError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_ThirtyTwoBytesPaymentErrorZ {
   /**
    * The contents of this CResult_ThirtyTwoBytesPaymentErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_ThirtyTwoBytesPaymentErrorZPtr contents;
   /**
    * Whether this CResult_ThirtyTwoBytesPaymentErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_ThirtyTwoBytesPaymentErrorZ;

/**
 * The contents of CResult_NonePaymentErrorZ
 */
typedef union LDKCResult_NonePaymentErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKPaymentError *err;
} LDKCResult_NonePaymentErrorZPtr;

/**
 * A CResult_NonePaymentErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning_invoice::payment::PaymentError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NonePaymentErrorZ {
   /**
    * The contents of this CResult_NonePaymentErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NonePaymentErrorZPtr contents;
   /**
    * Whether this CResult_NonePaymentErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NonePaymentErrorZ;

/**
 * An error that may occur when sending a payment probe.
 */
typedef enum LDKProbingError_Tag {
   /**
    * An error resulting from the provided [`Bolt11Invoice`].
    */
   LDKProbingError_Invoice,
   /**
    * An error occurring when sending a payment probe.
    */
   LDKProbingError_Sending,
   /**
    * Must be last for serialization purposes
    */
   LDKProbingError_Sentinel,
} LDKProbingError_Tag;

typedef struct MUST_USE_STRUCT LDKProbingError {
   LDKProbingError_Tag tag;
   union {
      struct {
         struct LDKStr invoice;
      };
      struct {
         struct LDKProbeSendFailure sending;
      };
   };
} LDKProbingError;

/**
 * The contents of CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ
 */
typedef union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKProbingError *err;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZPtr;

/**
 * A CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ on success and a crate::lightning_invoice::payment::ProbingError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ {
   /**
    * The contents of this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZPtr contents;
   /**
    * Whether this CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ;

/**
 * The contents of CResult_StrSecp256k1ErrorZ
 */
typedef union LDKCResult_StrSecp256k1ErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKStr *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   enum LDKSecp256k1Error *err;
} LDKCResult_StrSecp256k1ErrorZPtr;

/**
 * A CResult_StrSecp256k1ErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::Str on success and a crate::c_types::Secp256k1Error on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_StrSecp256k1ErrorZ {
   /**
    * The contents of this CResult_StrSecp256k1ErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_StrSecp256k1ErrorZPtr contents;
   /**
    * Whether this CResult_StrSecp256k1ErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_StrSecp256k1ErrorZ;



/**
 * A path for sending an [`msgs::OnionMessage`].
 */
typedef struct MUST_USE_STRUCT LDKOnionMessagePath {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOnionMessagePath *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOnionMessagePath;

/**
 * The contents of CResult_OnionMessagePathNoneZ
 */
typedef union LDKCResult_OnionMessagePathNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKOnionMessagePath *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_OnionMessagePathNoneZPtr;

/**
 * A CResult_OnionMessagePathNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::onion_message::messenger::OnionMessagePath on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_OnionMessagePathNoneZ {
   /**
    * The contents of this CResult_OnionMessagePathNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_OnionMessagePathNoneZPtr contents;
   /**
    * Whether this CResult_OnionMessagePathNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_OnionMessagePathNoneZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_PublicKeyOnionMessageZ {
   /**
    * The element at position 0
    */
   struct LDKPublicKey a;
   /**
    * The element at position 1
    */
   struct LDKOnionMessage b;
} LDKC2Tuple_PublicKeyOnionMessageZ;

/**
 * Errors that may occur when [sending an onion message].
 *
 * [sending an onion message]: OnionMessenger::send_onion_message
 */
typedef enum LDKSendError_Tag {
   /**
    * Errored computing onion message packet keys.
    */
   LDKSendError_Secp256k1,
   /**
    * Because implementations such as Eclair will drop onion messages where the message packet
    * exceeds 32834 bytes, we refuse to send messages where the packet exceeds this size.
    */
   LDKSendError_TooBigPacket,
   /**
    * The provided [`Destination`] was an invalid [`BlindedPath`], due to having fewer than two
    * blinded hops.
    */
   LDKSendError_TooFewBlindedHops,
   /**
    * Our next-hop peer was offline or does not support onion message forwarding.
    */
   LDKSendError_InvalidFirstHop,
   /**
    * Onion message contents must have a TLV type >= 64.
    */
   LDKSendError_InvalidMessage,
   /**
    * Our next-hop peer's buffer was full or our total outbound buffer was full.
    */
   LDKSendError_BufferFull,
   /**
    * Failed to retrieve our node id from the provided [`NodeSigner`].
    *
    * [`NodeSigner`]: crate::sign::NodeSigner
    */
   LDKSendError_GetNodeIdFailed,
   /**
    * We attempted to send to a blinded path where we are the introduction node, and failed to
    * advance the blinded path to make the second hop the new introduction node. Either
    * [`NodeSigner::ecdh`] failed, we failed to tweak the current blinding point to get the
    * new blinding point, or we were attempting to send to ourselves.
    */
   LDKSendError_BlindedPathAdvanceFailed,
   /**
    * Must be last for serialization purposes
    */
   LDKSendError_Sentinel,
} LDKSendError_Tag;

typedef struct MUST_USE_STRUCT LDKSendError {
   LDKSendError_Tag tag;
   union {
      struct {
         enum LDKSecp256k1Error secp256k1;
      };
   };
} LDKSendError;

/**
 * The contents of CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ
 */
typedef union LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_PublicKeyOnionMessageZ *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSendError *err;
} LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZPtr;

/**
 * A CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_PublicKeyOnionMessageZ on success and a crate::lightning::onion_message::messenger::SendError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ {
   /**
    * The contents of this CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZPtr contents;
   /**
    * Whether this CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ;

/**
 * The contents of CResult_NoneSendErrorZ
 */
typedef union LDKCResult_NoneSendErrorZPtr {
   /**
    * Note that this value is always NULL, as there are no contents in the OK variant
    */
   void *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKSendError *err;
} LDKCResult_NoneSendErrorZPtr;

/**
 * A CResult_NoneSendErrorZ represents the result of a fallible operation,
 * containing a () on success and a crate::lightning::onion_message::messenger::SendError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_NoneSendErrorZ {
   /**
    * The contents of this CResult_NoneSendErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_NoneSendErrorZPtr contents;
   /**
    * Whether this CResult_NoneSendErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_NoneSendErrorZ;

/**
 * The contents of CResult_BlindedPathNoneZ
 */
typedef union LDKCResult_BlindedPathNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedPath *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_BlindedPathNoneZPtr;

/**
 * A CResult_BlindedPathNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::BlindedPath on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedPathNoneZ {
   /**
    * The contents of this CResult_BlindedPathNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedPathNoneZPtr contents;
   /**
    * Whether this CResult_BlindedPathNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedPathNoneZ;

/**
 * The contents of CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ
 */
typedef union LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKC2Tuple_BlindedPayInfoBlindedPathZ *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr;

/**
 * A CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ represents the result of a fallible operation,
 * containing a crate::c_types::derived::C2Tuple_BlindedPayInfoBlindedPathZ on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ {
   /**
    * The contents of this CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZPtr contents;
   /**
    * Whether this CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ;

/**
 * The contents of CResult_BlindedPathDecodeErrorZ
 */
typedef union LDKCResult_BlindedPathDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedPath *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedPathDecodeErrorZPtr;

/**
 * A CResult_BlindedPathDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::BlindedPath on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedPathDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedPathDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedPathDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedPathDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedPathDecodeErrorZ;

/**
 * The contents of CResult_BlindedHopDecodeErrorZ
 */
typedef union LDKCResult_BlindedHopDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKBlindedHop *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_BlindedHopDecodeErrorZPtr;

/**
 * A CResult_BlindedHopDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::blinded_path::BlindedHop on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_BlindedHopDecodeErrorZ {
   /**
    * The contents of this CResult_BlindedHopDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_BlindedHopDecodeErrorZPtr contents;
   /**
    * Whether this CResult_BlindedHopDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_BlindedHopDecodeErrorZ;

/**
 * The contents of CResult_InvoiceErrorDecodeErrorZ
 */
typedef union LDKCResult_InvoiceErrorDecodeErrorZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKInvoiceError *result;
   /**
    * A pointer to the contents in the error state.
    * Reading from this pointer when `result_ok` is set is undefined.
    */
   struct LDKDecodeError *err;
} LDKCResult_InvoiceErrorDecodeErrorZPtr;

/**
 * A CResult_InvoiceErrorDecodeErrorZ represents the result of a fallible operation,
 * containing a crate::lightning::offers::invoice_error::InvoiceError on success and a crate::lightning::ln::msgs::DecodeError on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_InvoiceErrorDecodeErrorZ {
   /**
    * The contents of this CResult_InvoiceErrorDecodeErrorZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_InvoiceErrorDecodeErrorZPtr contents;
   /**
    * Whether this CResult_InvoiceErrorDecodeErrorZ represents a success state.
    */
   bool result_ok;
} LDKCResult_InvoiceErrorDecodeErrorZ;



/**
 * A transaction output watched by a [`ChannelMonitor`] for spends on-chain.
 *
 * Used to convey to a [`Filter`] such an output with a given spending condition. Any transaction
 * spending the output must be given to [`ChannelMonitor::block_connected`] either directly or via
 * [`Confirm::transactions_confirmed`].
 *
 * If `block_hash` is `Some`, this indicates the output was created in the corresponding block and
 * may have been spent there. See [`Filter::register_output`] for details.
 *
 * [`ChannelMonitor`]: channelmonitor::ChannelMonitor
 * [`ChannelMonitor::block_connected`]: channelmonitor::ChannelMonitor::block_connected
 */
typedef struct MUST_USE_STRUCT LDKWatchedOutput {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWatchedOutput *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWatchedOutput;

/**
 * The `Filter` trait defines behavior for indicating chain activity of interest pertaining to
 * channels.
 *
 * This is useful in order to have a [`Watch`] implementation convey to a chain source which
 * transactions to be notified of. Notification may take the form of pre-filtering blocks or, in
 * the case of [BIP 157]/[BIP 158], only fetching a block if the compact filter matches. If
 * receiving full blocks from a chain source, any further filtering is unnecessary.
 *
 * After an output has been registered, subsequent block retrievals from the chain source must not
 * exclude any transactions matching the new criteria nor any in-block descendants of such
 * transactions.
 *
 * Note that use as part of a [`Watch`] implementation involves reentrancy. Therefore, the `Filter`
 * should not block on I/O. Implementations should instead queue the newly monitored data to be
 * processed later. Then, in order to block until the data has been processed, any [`Watch`]
 * invocation that has called the `Filter` must return [`InProgress`].
 *
 * [`InProgress`]: ChannelMonitorUpdateStatus::InProgress
 * [BIP 157]: https://github.com/bitcoin/bips/blob/master/bip-0157.mediawiki
 * [BIP 158]: https://github.com/bitcoin/bips/blob/master/bip-0158.mediawiki
 */
typedef struct LDKFilter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Registers interest in a transaction with `txid` and having an output with `script_pubkey` as
    * a spending condition.
    */
   void (*register_tx)(const void *this_arg, const uint8_t (*txid)[32], struct LDKu8slice script_pubkey);
   /**
    * Registers interest in spends of a transaction output.
    *
    * Note that this method might be called during processing of a new block. You therefore need
    * to ensure that also dependent output spents within an already connected block are correctly
    * handled, e.g., by re-scanning the block in question whenever new outputs have been
    * registered mid-processing.
    */
   void (*register_output)(const void *this_arg, struct LDKWatchedOutput output);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFilter;

/**
 * An enum which can either contain a crate::lightning::chain::Filter or not
 */
typedef enum LDKCOption_FilterZ_Tag {
   /**
    * When we're in this state, this COption_FilterZ contains a crate::lightning::chain::Filter
    */
   LDKCOption_FilterZ_Some,
   /**
    * When we're in this state, this COption_FilterZ contains nothing
    */
   LDKCOption_FilterZ_None,
   /**
    * Must be last for serialization purposes
    */
   LDKCOption_FilterZ_Sentinel,
} LDKCOption_FilterZ_Tag;

typedef struct LDKCOption_FilterZ {
   LDKCOption_FilterZ_Tag tag;
   union {
      struct {
         struct LDKFilter some;
      };
   };
} LDKCOption_FilterZ;



/**
 * A read-only reference to a current ChannelMonitor.
 *
 * Note that this holds a mutex in [`ChainMonitor`] and may block other events until it is
 * released.
 */
typedef struct MUST_USE_STRUCT LDKLockedChannelMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeLockedChannelMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKLockedChannelMonitor;

/**
 * The contents of CResult_LockedChannelMonitorNoneZ
 */
typedef union LDKCResult_LockedChannelMonitorNoneZPtr {
   /**
    * A pointer to the contents in the success state.
    * Reading from this pointer when `result_ok` is not set is undefined.
    */
   struct LDKLockedChannelMonitor *result;
   /**
    * Note that this value is always NULL, as there are no contents in the Err variant
    */
   void *err;
} LDKCResult_LockedChannelMonitorNoneZPtr;

/**
 * A CResult_LockedChannelMonitorNoneZ represents the result of a fallible operation,
 * containing a crate::lightning::chain::chainmonitor::LockedChannelMonitor on success and a () on failure.
 * `result_ok` indicates the overall state, and the contents are provided via `contents`.
 */
typedef struct LDKCResult_LockedChannelMonitorNoneZ {
   /**
    * The contents of this CResult_LockedChannelMonitorNoneZ, accessible via either
    * `err` or `result` depending on the state of `result_ok`.
    */
   union LDKCResult_LockedChannelMonitorNoneZPtr contents;
   /**
    * Whether this CResult_LockedChannelMonitorNoneZ represents a success state.
    */
   bool result_ok;
} LDKCResult_LockedChannelMonitorNoneZ;

/**
 * A dynamically-allocated array of crate::lightning::chain::transaction::OutPoints of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_OutPointZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKOutPoint *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_OutPointZ;



/**
 * An opaque identifier describing a specific [`Persist`] method call.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdateId {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdateId *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdateId;

/**
 * A dynamically-allocated array of crate::lightning::chain::chainmonitor::MonitorUpdateIds of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_MonitorUpdateIdZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKMonitorUpdateId *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_MonitorUpdateIdZ;

/**
 * A tuple of 2 elements. See the individual fields for the types contained.
 */
typedef struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ {
   /**
    * The element at position 0
    */
   struct LDKOutPoint a;
   /**
    * The element at position 1
    */
   struct LDKCVec_MonitorUpdateIdZ b;
} LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ;

/**
 * A dynamically-allocated array of crate::c_types::derived::C2Tuple_OutPointCVec_MonitorUpdateIdZZs of arbitrary size.
 * This corresponds to std::vector in C++
 */
typedef struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ {
   /**
    * The elements in the array.
    * If datalen is non-0 this must be a valid, non-NULL pointer allocated by malloc().
    */
   struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *data;
   /**
    * The number of elements pointed to by `data`.
    */
   uintptr_t datalen;
} LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ;

/**
 * Provides an interface that allows storage and retrieval of persisted values that are associated
 * with given keys.
 *
 * In order to avoid collisions the key space is segmented based on the given `primary_namespace`s
 * and `secondary_namespace`s. Implementations of this trait are free to handle them in different
 * ways, as long as per-namespace key uniqueness is asserted.
 *
 * Keys and namespaces are required to be valid ASCII strings in the range of
 * [`KVSTORE_NAMESPACE_KEY_ALPHABET`] and no longer than [`KVSTORE_NAMESPACE_KEY_MAX_LEN`]. Empty
 * primary namespaces and secondary namespaces (`\"\"`) are assumed to be a valid, however, if
 * `primary_namespace` is empty, `secondary_namespace` is required to be empty, too. This means
 * that concerns should always be separated by primary namespace first, before secondary
 * namespaces are used. While the number of primary namespaces will be relatively small and is
 * determined at compile time, there may be many secondary namespaces per primary namespace. Note
 * that per-namespace uniqueness needs to also hold for keys *and* namespaces in any given
 * namespace, i.e., conflicts between keys and equally named
 * primary namespaces/secondary namespaces must be avoided.
 *
 * **Note:** Users migrating custom persistence backends from the pre-v0.0.117 `KVStorePersister`
 * interface can use a concatenation of `[{primary_namespace}/[{secondary_namespace}/]]{key}` to
 * recover a `key` compatible with the data model previously assumed by `KVStorePersister::persist`.
 */
typedef struct LDKKVStore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns the data stored for the given `primary_namespace`, `secondary_namespace`, and
    * `key`.
    *
    * Returns an [`ErrorKind::NotFound`] if the given `key` could not be found in the given
    * `primary_namespace` and `secondary_namespace`.
    *
    * [`ErrorKind::NotFound`]: io::ErrorKind::NotFound
    */
   struct LDKCResult_CVec_u8ZIOErrorZ (*read)(const void *this_arg, struct LDKStr primary_namespace, struct LDKStr secondary_namespace, struct LDKStr key);
   /**
    * Persists the given data under the given `key`.
    *
    * Will create the given `primary_namespace` and `secondary_namespace` if not already present
    * in the store.
    */
   struct LDKCResult_NoneIOErrorZ (*write)(const void *this_arg, struct LDKStr primary_namespace, struct LDKStr secondary_namespace, struct LDKStr key, struct LDKu8slice buf);
   /**
    * Removes any data that had previously been persisted under the given `key`.
    *
    * If the `lazy` flag is set to `true`, the backend implementation might choose to lazily
    * remove the given `key` at some point in time after the method returns, e.g., as part of an
    * eventual batch deletion of multiple keys. As a consequence, subsequent calls to
    * [`KVStore::list`] might include the removed key until the changes are actually persisted.
    *
    * Note that while setting the `lazy` flag reduces the I/O burden of multiple subsequent
    * `remove` calls, it also influences the atomicity guarantees as lazy `remove`s could
    * potentially get lost on crash after the method returns. Therefore, this flag should only be
    * set for `remove` operations that can be safely replayed at a later time.
    *
    * Returns successfully if no data will be stored for the given `primary_namespace`,
    * `secondary_namespace`, and `key`, independently of whether it was present before its
    * invokation or not.
    */
   struct LDKCResult_NoneIOErrorZ (*remove)(const void *this_arg, struct LDKStr primary_namespace, struct LDKStr secondary_namespace, struct LDKStr key, bool lazy);
   /**
    * Returns a list of keys that are stored under the given `secondary_namespace` in
    * `primary_namespace`.
    *
    * Returns the keys in arbitrary order, so users requiring a particular order need to sort the
    * returned keys. Returns an empty list if `primary_namespace` or `secondary_namespace` is unknown.
    */
   struct LDKCResult_CVec_StrZIOErrorZ (*list)(const void *this_arg, struct LDKStr primary_namespace, struct LDKStr secondary_namespace);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKKVStore;

/**
 * Trait that handles persisting a [`ChannelManager`], [`NetworkGraph`], and [`WriteableScore`] to disk.
 */
typedef struct LDKPersister {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist the given ['ChannelManager'] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneIOErrorZ (*persist_manager)(const void *this_arg, const struct LDKChannelManager *NONNULL_PTR channel_manager);
   /**
    * Persist the given [`NetworkGraph`] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneIOErrorZ (*persist_graph)(const void *this_arg, const struct LDKNetworkGraph *NONNULL_PTR network_graph);
   /**
    * Persist the given [`WriteableScore`] to disk, returning an error if persistence failed.
    */
   struct LDKCResult_NoneIOErrorZ (*persist_scorer)(const void *this_arg, const struct LDKWriteableScore *NONNULL_PTR scorer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersister;



/**
 * Implements [`Persist`] in a way that writes and reads both [`ChannelMonitor`]s and
 * [`ChannelMonitorUpdate`]s.
 *
 * # Overview
 *
 * The main benefit this provides over the [`KVStore`]'s [`Persist`] implementation is decreased
 * I/O bandwidth and storage churn, at the expense of more IOPS (including listing, reading, and
 * deleting) and complexity. This is because it writes channel monitor differential updates,
 * whereas the other (default) implementation rewrites the entire monitor on each update. For
 * routing nodes, updates can happen many times per second to a channel, and monitors can be tens
 * of megabytes (or more). Updates can be as small as a few hundred bytes.
 *
 * Note that monitors written with `MonitorUpdatingPersister` are _not_ backward-compatible with
 * the default [`KVStore`]'s [`Persist`] implementation. They have a prepended byte sequence,
 * [`MONITOR_UPDATING_PERSISTER_PREPEND_SENTINEL`], applied to prevent deserialization with other
 * persisters. This is because monitors written by this struct _may_ have unapplied updates. In
 * order to downgrade, you must ensure that all updates are applied to the monitor, and remove the
 * sentinel bytes.
 *
 * # Storing monitors
 *
 * Monitors are stored by implementing the [`Persist`] trait, which has two functions:
 *
 *   - [`Persist::persist_new_channel`], which persists whole [`ChannelMonitor`]s.
 *   - [`Persist::update_persisted_channel`], which persists only a [`ChannelMonitorUpdate`]
 *
 * Whole [`ChannelMonitor`]s are stored in the [`CHANNEL_MONITOR_PERSISTENCE_PRIMARY_NAMESPACE`],
 * using the familiar encoding of an [`OutPoint`] (for example, `[SOME-64-CHAR-HEX-STRING]_1`).
 *
 * Each [`ChannelMonitorUpdate`] is stored in a dynamic secondary namespace, as follows:
 *
 *   - primary namespace: [`CHANNEL_MONITOR_UPDATE_PERSISTENCE_PRIMARY_NAMESPACE`]
 *   - secondary namespace: [the monitor's encoded outpoint name]
 *
 * Under that secondary namespace, each update is stored with a number string, like `21`, which
 * represents its `update_id` value.
 *
 * For example, consider this channel, named for its transaction ID and index, or [`OutPoint`]:
 *
 *   - Transaction ID: `deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef`
 *   - Index: `1`
 *
 * Full channel monitors would be stored at a single key:
 *
 * `[CHANNEL_MONITOR_PERSISTENCE_PRIMARY_NAMESPACE]/deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef_1`
 *
 * Updates would be stored as follows (with `/` delimiting primary_namespace/secondary_namespace/key):
 *
 * ```text
 * [CHANNEL_MONITOR_UPDATE_PERSISTENCE_PRIMARY_NAMESPACE]/deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef_1/1
 * [CHANNEL_MONITOR_UPDATE_PERSISTENCE_PRIMARY_NAMESPACE]/deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef_1/2
 * [CHANNEL_MONITOR_UPDATE_PERSISTENCE_PRIMARY_NAMESPACE]/deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef_1/3
 * ```
 * ... and so on.
 *
 * # Reading channel state from storage
 *
 * Channel state can be reconstructed by calling
 * [`MonitorUpdatingPersister::read_all_channel_monitors_with_updates`]. Alternatively, users can
 * list channel monitors themselves and load channels individually using
 * [`MonitorUpdatingPersister::read_channel_monitor_with_updates`].
 *
 * ## EXTREMELY IMPORTANT
 *
 * It is extremely important that your [`KVStore::read`] implementation uses the
 * [`io::ErrorKind::NotFound`] variant correctly: that is, when a file is not found, and _only_ in
 * that circumstance (not when there is really a permissions error, for example). This is because
 * neither channel monitor reading function lists updates. Instead, either reads the monitor, and
 * using its stored `update_id`, synthesizes update storage keys, and tries them in sequence until
 * one is not found. All _other_ errors will be bubbled up in the function's [`Result`].
 *
 * # Pruning stale channel updates
 *
 * Stale updates are pruned when a full monitor is written. The old monitor is first read, and if
 * that succeeds, updates in the range between the old and new monitors are deleted. The `lazy`
 * flag is used on the [`KVStore::remove`] method, so there are no guarantees that the deletions
 * will complete. However, stale updates are not a problem for data integrity, since updates are
 * only read that are higher than the stored [`ChannelMonitor`]'s `update_id`.
 *
 * If you have many stale updates stored (such as after a crash with pending lazy deletes), and
 * would like to get rid of them, consider using the
 * [`MonitorUpdatingPersister::cleanup_stale_updates`] function.
 */
typedef struct MUST_USE_STRUCT LDKMonitorUpdatingPersister {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMonitorUpdatingPersister *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMonitorUpdatingPersister;

/**
 * `Persist` defines behavior for persisting channel monitors: this could mean
 * writing once to disk, and/or uploading to one or more backup services.
 *
 * Persistence can happen in one of two ways - synchronously completing before the trait method
 * calls return or asynchronously in the background.
 *
 * # For those implementing synchronous persistence
 *
 *  * If persistence completes fully (including any relevant `fsync()` calls), the implementation
 *    should return [`ChannelMonitorUpdateStatus::Completed`], indicating normal channel operation
 *    should continue.
 *
 *  * If persistence fails for some reason, implementations should consider returning
 *    [`ChannelMonitorUpdateStatus::InProgress`] and retry all pending persistence operations in
 *    the background with [`ChainMonitor::list_pending_monitor_updates`] and
 *    [`ChainMonitor::get_monitor`].
 *
 *    Once a full [`ChannelMonitor`] has been persisted, all pending updates for that channel can
 *    be marked as complete via [`ChainMonitor::channel_monitor_updated`].
 *
 *    If at some point no further progress can be made towards persisting the pending updates, the
 *    node should simply shut down.
 *
 *  * If the persistence has failed and cannot be retried further (e.g. because of an outage),
 *    [`ChannelMonitorUpdateStatus::UnrecoverableError`] can be used, though this will result in
 *    an immediate panic and future operations in LDK generally failing.
 *
 * # For those implementing asynchronous persistence
 *
 *  All calls should generally spawn a background task and immediately return
 *  [`ChannelMonitorUpdateStatus::InProgress`]. Once the update completes,
 *  [`ChainMonitor::channel_monitor_updated`] should be called with the corresponding
 *  [`MonitorUpdateId`].
 *
 *  Note that unlike the direct [`chain::Watch`] interface,
 *  [`ChainMonitor::channel_monitor_updated`] must be called once for *each* update which occurs.
 *
 *  If at some point no further progress can be made towards persisting a pending update, the node
 *  should simply shut down. Until then, the background task should either loop indefinitely, or
 *  persistence should be regularly retried with [`ChainMonitor::list_pending_monitor_updates`]
 *  and [`ChainMonitor::get_monitor`] (note that if a full monitor is persisted all pending
 *  monitor updates may be marked completed).
 *
 * # Using remote watchtowers
 *
 * Watchtowers may be updated as a part of an implementation of this trait, utilizing the async
 * update process described above while the watchtower is being updated. The following methods are
 * provided for bulding transactions for a watchtower:
 * [`ChannelMonitor::initial_counterparty_commitment_tx`],
 * [`ChannelMonitor::counterparty_commitment_txs_from_update`],
 * [`ChannelMonitor::sign_to_local_justice_tx`], [`TrustedCommitmentTransaction::revokeable_output_index`],
 * [`TrustedCommitmentTransaction::build_to_local_justice_tx`].
 *
 * [`TrustedCommitmentTransaction::revokeable_output_index`]: crate::ln::chan_utils::TrustedCommitmentTransaction::revokeable_output_index
 * [`TrustedCommitmentTransaction::build_to_local_justice_tx`]: crate::ln::chan_utils::TrustedCommitmentTransaction::build_to_local_justice_tx
 */
typedef struct LDKPersist {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Persist a new channel's data in response to a [`chain::Watch::watch_channel`] call. This is
    * called by [`ChannelManager`] for new channels, or may be called directly, e.g. on startup.
    *
    * The data can be stored any way you want, but the identifier provided by LDK is the
    * channel's outpoint (and it is up to you to maintain a correct mapping between the outpoint
    * and the stored channel data). Note that you **must** persist every new monitor to disk.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateStatus::InProgress`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`
    * and [`ChannelMonitorUpdateStatus`] for requirements when returning errors.
    *
    * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    */
   enum LDKChannelMonitorUpdateStatus (*persist_new_channel)(const void *this_arg, struct LDKOutPoint channel_id, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Update one channel's data. The provided [`ChannelMonitor`] has already applied the given
    * update.
    *
    * Note that on every update, you **must** persist either the [`ChannelMonitorUpdate`] or the
    * updated monitor itself to disk/backups. See the [`Persist`] trait documentation for more
    * details.
    *
    * During blockchain synchronization operations, and in some rare cases, this may be called with
    * no [`ChannelMonitorUpdate`], in which case the full [`ChannelMonitor`] needs to be persisted.
    * Note that after the full [`ChannelMonitor`] is persisted any previous
    * [`ChannelMonitorUpdate`]s which were persisted should be discarded - they can no longer be
    * applied to the persisted [`ChannelMonitor`] as they were already applied.
    *
    * If an implementer chooses to persist the updates only, they need to make
    * sure that all the updates are applied to the `ChannelMonitors` *before*
    * the set of channel monitors is given to the `ChannelManager`
    * deserialization routine. See [`ChannelMonitor::update_monitor`] for
    * applying a monitor update to a monitor. If full `ChannelMonitors` are
    * persisted, then there is no need to persist individual updates.
    *
    * Note that there could be a performance tradeoff between persisting complete
    * channel monitors on every update vs. persisting only updates and applying
    * them in batches. The size of each monitor grows `O(number of state updates)`
    * whereas updates are small and `O(1)`.
    *
    * The `update_id` is used to identify this call to [`ChainMonitor::channel_monitor_updated`],
    * if you return [`ChannelMonitorUpdateStatus::InProgress`].
    *
    * See [`Writeable::write`] on [`ChannelMonitor`] for writing out a `ChannelMonitor`,
    * [`Writeable::write`] on [`ChannelMonitorUpdate`] for writing out an update, and
    * [`ChannelMonitorUpdateStatus`] for requirements when returning errors.
    *
    * [`Writeable::write`]: crate::util::ser::Writeable::write
    *
    * Note that update (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   enum LDKChannelMonitorUpdateStatus (*update_persisted_channel)(const void *this_arg, struct LDKOutPoint channel_id, struct LDKChannelMonitorUpdate update, const struct LDKChannelMonitor *NONNULL_PTR data, struct LDKMonitorUpdateId update_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKPersist;



/**
 * A string that displays only printable characters, replacing control characters with
 * [`core::char::REPLACEMENT_CHARACTER`].
 */
typedef struct MUST_USE_STRUCT LDKPrintableString {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePrintableString *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPrintableString;

/**
 * A callback which is called when a [`Future`] completes.
 *
 * Note that this MUST NOT call back into LDK directly, it must instead schedule actions to be
 * taken later. Rust users should use the [`std::future::Future`] implementation for [`Future`]
 * instead.
 *
 * Note that the [`std::future::Future`] implementation may only work for runtimes which schedule
 * futures when they receive a wake, rather than immediately executing them.
 */
typedef struct LDKFutureCallback {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * The method which is called.
    */
   void (*call)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKFutureCallback;



/**
 * A struct which can be used to select across many [`Future`]s at once without relying on a full
 * async context.
 */
typedef struct MUST_USE_STRUCT LDKSleeper {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSleeper *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSleeper;



/**
 * Configuration we set when applicable.
 *
 * Default::default() provides sane defaults.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeConfig;



/**
 * Optional channel limits which are applied during channel creation.
 *
 * These limits are only applied to our counterparty's limits, not our own.
 *
 * Use 0/`<type>::max_value()` as appropriate to skip checking.
 *
 * Provides sane defaults for most configurations.
 *
 * Most additional limits are disabled except those with which specify a default in individual
 * field documentation. Note that this may result in barely-usable channels, but since they
 * are applied mostly only to incoming channels that's not much of a problem.
 */
typedef struct MUST_USE_STRUCT LDKChannelHandshakeLimits {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelHandshakeLimits *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelHandshakeLimits;



/**
 * A parallel struct to [`ChannelConfig`] to define partial updates.
 */
typedef struct MUST_USE_STRUCT LDKChannelConfigUpdate {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelConfigUpdate *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelConfigUpdate;



/**
 * Top-level config which holds ChannelHandshakeLimits and ChannelConfig.
 *
 * Default::default() provides sane defaults for most configurations
 * (but currently with 0 relay fees!)
 */
typedef struct MUST_USE_STRUCT LDKUserConfig {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeUserConfig *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKUserConfig;



/**
 * The best known block as identified by its hash and height.
 */
typedef struct MUST_USE_STRUCT LDKBestBlock {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBestBlock *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBestBlock;

/**
 * The `Listen` trait is used to notify when blocks have been connected or disconnected from the
 * chain.
 *
 * Useful when needing to replay chain data upon startup or as new chain events occur. Clients
 * sourcing chain data using a block-oriented API should prefer this interface over [`Confirm`].
 * Such clients fetch the entire header chain whereas clients using [`Confirm`] only fetch headers
 * when needed.
 *
 * By using [`Listen::filtered_block_connected`] this interface supports clients fetching the
 * entire header chain and only blocks with matching transaction data using BIP 157 filters or
 * other similar filtering.
 */
typedef struct LDKListen {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies the listener that a block was added at the given height, with the transaction data
    * possibly filtered.
    */
   void (*filtered_block_connected)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Notifies the listener that a block was added at the given height.
    */
   void (*block_connected)(const void *this_arg, struct LDKu8slice block, uint32_t height);
   /**
    * Notifies the listener that a block was removed at the given height.
    */
   void (*block_disconnected)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKListen;

/**
 * The `Confirm` trait is used to notify LDK when relevant transactions have been confirmed on
 * chain or unconfirmed during a chain reorganization.
 *
 * Clients sourcing chain data using a transaction-oriented API should prefer this interface over
 * [`Listen`]. For instance, an Electrum-based transaction sync implementation may implement
 * [`Filter`] to subscribe to relevant transactions and unspent outputs it should monitor for
 * on-chain activity. Then, it needs to notify LDK via this interface upon observing any changes
 * with reference to the confirmation status of the monitored objects.
 *
 * # Use
 * The intended use is as follows:
 * - Call [`transactions_confirmed`] to notify LDK whenever any of the registered transactions or
 *   outputs are, respectively, confirmed or spent on chain.
 * - Call [`transaction_unconfirmed`] to notify LDK whenever any transaction returned by
 *   [`get_relevant_txids`] is no longer confirmed in the block with the given block hash.
 * - Call [`best_block_updated`] to notify LDK whenever a new chain tip becomes available.
 *
 * # Order
 *
 * Clients must call these methods in chain order. Specifically:
 * - Transactions which are confirmed in a particular block must be given before transactions
 *   confirmed in a later block.
 * - Dependent transactions within the same block must be given in topological order, possibly in
 *   separate calls.
 * - All unconfirmed transactions must be given after the original confirmations and before *any*
 *   reconfirmations, i.e., [`transactions_confirmed`] and [`transaction_unconfirmed`] calls should
 *   never be interleaved, but always conduced *en bloc*.
 * - Any reconfirmed transactions need to be explicitly unconfirmed before they are reconfirmed
 *   in regard to the new block.
 *
 * See individual method documentation for further details.
 *
 * [`transactions_confirmed`]: Self::transactions_confirmed
 * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
 * [`best_block_updated`]: Self::best_block_updated
 * [`get_relevant_txids`]: Self::get_relevant_txids
 */
typedef struct LDKConfirm {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Notifies LDK of transactions confirmed in a block with a given header and height.
    *
    * Must be called for any transactions registered by [`Filter::register_tx`] or any
    * transactions spending an output registered by [`Filter::register_output`]. Such transactions
    * appearing in the same block do not need to be included in the same call; instead, multiple
    * calls with additional transactions may be made so long as they are made in [chain order].
    *
    * May be called before or after [`best_block_updated`] for the corresponding block. However,
    * in the event of a chain reorganization, it must not be called with a `header` that is no
    * longer in the chain as of the last call to [`best_block_updated`].
    *
    * [chain order]: Confirm#order
    * [`best_block_updated`]: Self::best_block_updated
    */
   void (*transactions_confirmed)(const void *this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height);
   /**
    * Notifies LDK of a transaction that is no longer confirmed as result of a chain reorganization.
    *
    * Must be called for any transaction returned by [`get_relevant_txids`] if it has been
    * reorganized out of the best chain or if it is no longer confirmed in the block with the
    * given block hash. Once called, the given transaction will not be returned
    * by [`get_relevant_txids`], unless it has been reconfirmed via [`transactions_confirmed`].
    *
    * [`get_relevant_txids`]: Self::get_relevant_txids
    * [`transactions_confirmed`]: Self::transactions_confirmed
    */
   void (*transaction_unconfirmed)(const void *this_arg, const uint8_t (*txid)[32]);
   /**
    * Notifies LDK of an update to the best header connected at the given height.
    *
    * Must be called whenever a new chain tip becomes available. May be skipped for intermediary
    * blocks.
    */
   void (*best_block_updated)(const void *this_arg, const uint8_t (*header)[80], uint32_t height);
   /**
    * Returns transactions that must be monitored for reorganization out of the chain along
    * with the hash of the block as part of which it had been previously confirmed.
    *
    * Note that the returned `Option<BlockHash>` might be `None` for channels created with LDK
    * 0.0.112 and prior, in which case you need to manually track previous confirmations.
    *
    * Will include any transactions passed to [`transactions_confirmed`] that have insufficient
    * confirmations to be safe from a chain reorganization. Will not include any transactions
    * passed to [`transaction_unconfirmed`], unless later reconfirmed.
    *
    * Must be called to determine the subset of transactions that must be monitored for
    * reorganization. Will be idempotent between calls but may change as a result of calls to the
    * other interface methods. Thus, this is useful to determine which transactions must be
    * given to [`transaction_unconfirmed`].
    *
    * If any of the returned transactions are confirmed in a block other than the one with the
    * given hash, they need to be unconfirmed and reconfirmed via [`transaction_unconfirmed`] and
    * [`transactions_confirmed`], respectively.
    *
    * [`transactions_confirmed`]: Self::transactions_confirmed
    * [`transaction_unconfirmed`]: Self::transaction_unconfirmed
    */
   struct LDKCVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ (*get_relevant_txids)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKConfirm;



/**
 * An implementation of [`chain::Watch`] for monitoring channels.
 *
 * Connected and disconnected blocks must be provided to `ChainMonitor` as documented by
 * [`chain::Watch`]. May be used in conjunction with [`ChannelManager`] to monitor channels locally
 * or used independently to monitor channels remotely. See the [module-level documentation] for
 * details.
 *
 * Note that `ChainMonitor` should regularly trigger rebroadcasts/fee bumps of pending claims from
 * a force-closed channel. This is crucial in preventing certain classes of pinning attacks,
 * detecting substantial mempool feerate changes between blocks, and ensuring reliability if
 * broadcasting fails. We recommend invoking this every 30 seconds, or lower if running in an
 * environment with spotty connections, like on mobile.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [module-level documentation]: crate::chain::chainmonitor
 * [`rebroadcast_pending_claims`]: Self::rebroadcast_pending_claims
 */
typedef struct MUST_USE_STRUCT LDKChainMonitor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainMonitor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainMonitor;

/**
 * A trait implemented for objects handling events from [`EventsProvider`].
 *
 * An async variation also exists for implementations of [`EventsProvider`] that support async
 * event handling. The async event handler should satisfy the generic bounds: `F:
 * core::future::Future, H: Fn(Event) -> F`.
 */
typedef struct LDKEventHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given [`Event`].
    *
    * See [`EventsProvider`] for details that must be considered when implementing this method.
    */
   void (*handle_event)(const void *this_arg, struct LDKEvent event);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventHandler;

/**
 * A trait indicating an object may generate events.
 *
 * Events are processed by passing an [`EventHandler`] to [`process_pending_events`].
 *
 * Implementations of this trait may also feature an async version of event handling, as shown with
 * [`ChannelManager::process_pending_events_async`] and
 * [`ChainMonitor::process_pending_events_async`].
 *
 * # Requirements
 *
 * When using this trait, [`process_pending_events`] will call [`handle_event`] for each pending
 * event since the last invocation.
 *
 * In order to ensure no [`Event`]s are lost, implementors of this trait will persist [`Event`]s
 * and replay any unhandled events on startup. An [`Event`] is considered handled when
 * [`process_pending_events`] returns, thus handlers MUST fully handle [`Event`]s and persist any
 * relevant changes to disk *before* returning.
 *
 * Further, because an application may crash between an [`Event`] being handled and the
 * implementor of this trait being re-serialized, [`Event`] handling must be idempotent - in
 * effect, [`Event`]s may be replayed.
 *
 * Note, handlers may call back into the provider and thus deadlocking must be avoided. Be sure to
 * consult the provider's documentation on the implication of processing events and how a handler
 * may safely use the provider (e.g., see [`ChannelManager::process_pending_events`] and
 * [`ChainMonitor::process_pending_events`]).
 *
 * (C-not implementable) As there is likely no reason for a user to implement this trait on their
 * own type(s).
 *
 * [`process_pending_events`]: Self::process_pending_events
 * [`handle_event`]: EventHandler::handle_event
 * [`ChannelManager::process_pending_events`]: crate::ln::channelmanager::ChannelManager#method.process_pending_events
 * [`ChainMonitor::process_pending_events`]: crate::chain::chainmonitor::ChainMonitor#method.process_pending_events
 * [`ChannelManager::process_pending_events_async`]: crate::ln::channelmanager::ChannelManager::process_pending_events_async
 * [`ChainMonitor::process_pending_events_async`]: crate::chain::chainmonitor::ChainMonitor::process_pending_events_async
 */
typedef struct LDKEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Processes any events generated since the last call using the given event handler.
    *
    * See the trait-level documentation for requirements.
    */
   void (*process_pending_events)(const void *this_arg, struct LDKEventHandler handler);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKEventsProvider;

/**
 * This enum is used to specify which error data to send to peers when failing back an HTLC
 * using [`ChannelManager::fail_htlc_backwards_with_reason`].
 *
 * For more info on failure codes, see <https://github.com/lightning/bolts/blob/master/04-onion-routing.md#failure-messages>.
 */
typedef enum LDKFailureCode_Tag {
   /**
    * We had a temporary error processing the payment. Useful if no other error codes fit
    * and you want to indicate that the payer may want to retry.
    */
   LDKFailureCode_TemporaryNodeFailure,
   /**
    * We have a required feature which was not in this onion. For example, you may require
    * some additional metadata that was not provided with this payment.
    */
   LDKFailureCode_RequiredNodeFeatureMissing,
   /**
    * You may wish to use this when a `payment_preimage` is unknown, or the CLTV expiry of
    * the HTLC is too close to the current block height for safe handling.
    * Using this failure code in [`ChannelManager::fail_htlc_backwards_with_reason`] is
    * equivalent to calling [`ChannelManager::fail_htlc_backwards`].
    */
   LDKFailureCode_IncorrectOrUnknownPaymentDetails,
   /**
    * We failed to process the payload after the onion was decrypted. You may wish to
    * use this when receiving custom HTLC TLVs with even type numbers that you don't recognize.
    *
    * If available, the tuple data may include the type number and byte offset in the
    * decrypted byte stream where the failure occurred.
    */
   LDKFailureCode_InvalidOnionPayload,
   /**
    * Must be last for serialization purposes
    */
   LDKFailureCode_Sentinel,
} LDKFailureCode_Tag;

typedef struct MUST_USE_STRUCT LDKFailureCode {
   LDKFailureCode_Tag tag;
   union {
      struct {
         struct LDKCOption_C2Tuple_u64u16ZZ invalid_onion_payload;
      };
   };
} LDKFailureCode;



/**
 * Chain-related parameters used to construct a new `ChannelManager`.
 *
 * Typically, the block-specific parameters are derived from the best block hash for the network,
 * as a newly constructed `ChannelManager` will not have created any channels yet. These parameters
 * are not needed when deserializing a previously constructed `ChannelManager`.
 */
typedef struct MUST_USE_STRUCT LDKChainParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChainParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChainParameters;

/**
 * A trait indicating an object may generate message send events
 */
typedef struct LDKMessageSendEventsProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the list of pending events which were generated by previous actions, clearing the list
    * in the process.
    */
   struct LDKCVec_MessageSendEventZ (*get_and_clear_pending_msg_events)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageSendEventsProvider;

/**
 * A trait to describe an object which can receive channel messages.
 *
 * Messages MAY be called in parallel when they originate from different `their_node_ids`, however
 * they MUST NOT be called in parallel when the two calls have the same `their_node_id`.
 */
typedef struct LDKChannelMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming `open_channel` message from the given peer.
    */
   void (*handle_open_channel)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKOpenChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming `open_channel2` message from the given peer.
    */
   void (*handle_open_channel_v2)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKOpenChannelV2 *NONNULL_PTR msg);
   /**
    * Handle an incoming `accept_channel` message from the given peer.
    */
   void (*handle_accept_channel)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAcceptChannel *NONNULL_PTR msg);
   /**
    * Handle an incoming `accept_channel2` message from the given peer.
    */
   void (*handle_accept_channel_v2)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAcceptChannelV2 *NONNULL_PTR msg);
   /**
    * Handle an incoming `funding_created` message from the given peer.
    */
   void (*handle_funding_created)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingCreated *NONNULL_PTR msg);
   /**
    * Handle an incoming `funding_signed` message from the given peer.
    */
   void (*handle_funding_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKFundingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming `channel_ready` message from the given peer.
    */
   void (*handle_channel_ready)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReady *NONNULL_PTR msg);
   /**
    * Handle an incoming `shutdown` message from the given peer.
    */
   void (*handle_shutdown)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKShutdown *NONNULL_PTR msg);
   /**
    * Handle an incoming `closing_signed` message from the given peer.
    */
   void (*handle_closing_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKClosingSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_add_input message` from the given peer.
    */
   void (*handle_tx_add_input)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAddInput *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_add_output` message from the given peer.
    */
   void (*handle_tx_add_output)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAddOutput *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_remove_input` message from the given peer.
    */
   void (*handle_tx_remove_input)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxRemoveInput *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_remove_output` message from the given peer.
    */
   void (*handle_tx_remove_output)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxRemoveOutput *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_complete message` from the given peer.
    */
   void (*handle_tx_complete)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxComplete *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_signatures` message from the given peer.
    */
   void (*handle_tx_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxSignatures *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_init_rbf` message from the given peer.
    */
   void (*handle_tx_init_rbf)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxInitRbf *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_ack_rbf` message from the given peer.
    */
   void (*handle_tx_ack_rbf)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAckRbf *NONNULL_PTR msg);
   /**
    * Handle an incoming `tx_abort message` from the given peer.
    */
   void (*handle_tx_abort)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKTxAbort *NONNULL_PTR msg);
   /**
    * Handle an incoming `update_add_htlc` message from the given peer.
    */
   void (*handle_update_add_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateAddHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming `update_fulfill_htlc` message from the given peer.
    */
   void (*handle_update_fulfill_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFulfillHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming `update_fail_htlc` message from the given peer.
    */
   void (*handle_update_fail_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming `update_fail_malformed_htlc` message from the given peer.
    */
   void (*handle_update_fail_malformed_htlc)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR msg);
   /**
    * Handle an incoming `commitment_signed` message from the given peer.
    */
   void (*handle_commitment_signed)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKCommitmentSigned *NONNULL_PTR msg);
   /**
    * Handle an incoming `revoke_and_ack` message from the given peer.
    */
   void (*handle_revoke_and_ack)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKRevokeAndACK *NONNULL_PTR msg);
   /**
    * Handle an incoming `update_fee` message from the given peer.
    */
   void (*handle_update_fee)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKUpdateFee *NONNULL_PTR msg);
   /**
    * Handle an incoming `announcement_signatures` message from the given peer.
    */
   void (*handle_announcement_signatures)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKAnnouncementSignatures *NONNULL_PTR msg);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost.
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Handle a peer reconnecting, possibly generating `channel_reestablish` message(s).
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR msg, bool inbound);
   /**
    * Handle an incoming `channel_reestablish` message from the given peer.
    */
   void (*handle_channel_reestablish)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelReestablish *NONNULL_PTR msg);
   /**
    * Handle an incoming `channel_update` message from the given peer.
    */
   void (*handle_channel_update)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Handle an incoming `error` message from the given peer.
    */
   void (*handle_error)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKErrorMessage *NONNULL_PTR msg);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Gets the genesis hashes for this `ChannelMessageHandler` indicating which chains it supports.
    *
    * If it's `None`, then no particular network chain hash compatibility will be enforced when
    * connecting to peers.
    */
   struct LDKCOption_CVec_ThirtyTwoBytesZZ (*get_genesis_hashes)(const void *this_arg);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKChannelMessageHandler;



/**
 * Arguments for the creation of a ChannelManager that are not deserialized.
 *
 * At a high-level, the process for deserializing a ChannelManager and resuming normal operation
 * is:
 * 1) Deserialize all stored [`ChannelMonitor`]s.
 * 2) Deserialize the [`ChannelManager`] by filling in this struct and calling:
 *    `<(BlockHash, ChannelManager)>::read(reader, args)`
 *    This may result in closing some channels if the [`ChannelMonitor`] is newer than the stored
 *    [`ChannelManager`] state to ensure no loss of funds. Thus, transactions may be broadcasted.
 * 3) If you are not fetching full blocks, register all relevant [`ChannelMonitor`] outpoints the
 *    same way you would handle a [`chain::Filter`] call using
 *    [`ChannelMonitor::get_outputs_to_watch`] and [`ChannelMonitor::get_funding_txo`].
 * 4) Reconnect blocks on your [`ChannelMonitor`]s.
 * 5) Disconnect/connect blocks on the [`ChannelManager`].
 * 6) Re-persist the [`ChannelMonitor`]s to ensure the latest state is on disk.
 *    Note that if you're using a [`ChainMonitor`] for your [`chain::Watch`] implementation, you
 *    will likely accomplish this as a side-effect of calling [`chain::Watch::watch_channel`] in
 *    the next step.
 * 7) Move the [`ChannelMonitor`]s into your local [`chain::Watch`]. If you're using a
 *    [`ChainMonitor`], this is done by calling [`chain::Watch::watch_channel`].
 *
 * Note that the ordering of #4-7 is not of importance, however all four must occur before you
 * call any other methods on the newly-deserialized [`ChannelManager`].
 *
 * Note that because some channels may be closed during deserialization, it is critical that you
 * always deserialize only the latest version of a ChannelManager and ChannelMonitors available to
 * you. If you deserialize an old ChannelManager (during which force-closure transactions may be
 * broadcast), and then later deserialize a newer version of the same ChannelManager (which will
 * not force-close the same channels but consider them live), you may end up revoking a state for
 * which you've already broadcasted the transaction.
 *
 * [`ChainMonitor`]: crate::chain::chainmonitor::ChainMonitor
 */
typedef struct MUST_USE_STRUCT LDKChannelManagerReadArgs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeChannelManagerReadArgs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKChannelManagerReadArgs;



/**
 * A set of keys that were HKDF-expanded from an initial call to
 * [`NodeSigner::get_inbound_payment_key_material`].
 *
 * [`NodeSigner::get_inbound_payment_key_material`]: crate::sign::NodeSigner::get_inbound_payment_key_material
 */
typedef struct MUST_USE_STRUCT LDKExpandedKey {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpandedKey *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpandedKey;



/**
 * Packet of hop data for next peer
 */
typedef struct MUST_USE_STRUCT LDKPacket {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePacket *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPacket;

/**
 * A 3-byte byte array.
 */
typedef struct LDKThreeBytes {
   /**
    * The three bytes
    */
   uint8_t data[3];
} LDKThreeBytes;

/**
 * A trait to describe an object which can receive routing messages.
 *
 * # Implementor DoS Warnings
 *
 * For messages enabled with the `gossip_queries` feature there are potential DoS vectors when
 * handling inbound queries. Implementors using an on-disk network graph should be aware of
 * repeated disk I/O for queries accessing different parts of the network graph.
 */
typedef struct LDKRoutingMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming `node_announcement` message, returning `true` if it should be forwarded on,
    * `false` or returning an `Err` otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_node_announcement)(const void *this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);
   /**
    * Handle a `channel_announcement` message, returning `true` if it should be forwarded on, `false`
    * or returning an `Err` otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_announcement)(const void *this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);
   /**
    * Handle an incoming `channel_update` message, returning true if it should be forwarded on,
    * `false` or returning an `Err` otherwise.
    */
   struct LDKCResult_boolLightningErrorZ (*handle_channel_update)(const void *this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);
   /**
    * Gets channel announcements and updates required to dump our routing table to a remote node,
    * starting at the `short_channel_id` indicated by `starting_point` and including announcements
    * for a single channel.
    */
   struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ (*get_next_channel_announcement)(const void *this_arg, uint64_t starting_point);
   /**
    * Gets a node announcement required to dump our routing table to a remote node, starting at
    * the node *after* the provided pubkey and including up to one announcement immediately
    * higher (as defined by `<PublicKey as Ord>::cmp`) than `starting_point`.
    * If `None` is provided for `starting_point`, we start at the first node.
    *
    * Note that starting_point (or a relevant inner pointer) may be NULL or all-0s to represent None
    * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKNodeAnnouncement (*get_next_node_announcement)(const void *this_arg, struct LDKNodeId starting_point);
   /**
    * Called when a connection is established with a peer. This can be used to
    * perform routing table synchronization using a strategy defined by the
    * implementor.
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init, bool inbound);
   /**
    * Handles the reply of a query we initiated to learn about channels
    * for a given range of blocks. We can expect to receive one or more
    * replies to a single query.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyChannelRange msg);
   /**
    * Handles the reply of a query we initiated asking for routing gossip
    * messages for a list of channels. We should receive this message when
    * a node has completed its best effort to send us the pertaining routing
    * gossip messages.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_reply_short_channel_ids_end)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKReplyShortChannelIdsEnd msg);
   /**
    * Handles when a peer asks us to send a list of `short_channel_id`s
    * for the requested range of blocks.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_channel_range)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryChannelRange msg);
   /**
    * Handles when a peer asks us to send routing gossip messages for a
    * list of `short_channel_id`s.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_query_short_channel_ids)(const void *this_arg, struct LDKPublicKey their_node_id, struct LDKQueryShortChannelIds msg);
   /**
    * Indicates that there are a large number of [`ChannelAnnouncement`] (or other) messages
    * pending some async action. While there is no guarantee of the rate of future messages, the
    * caller should seek to reduce the rate of new gossip messages handled, especially
    * [`ChannelAnnouncement`]s.
    */
   bool (*processing_queue_high)(const void *this_arg);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of MessageSendEventsProvider for this object.
    */
   struct LDKMessageSendEventsProvider MessageSendEventsProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKRoutingMessageHandler;

/**
 * A trait indicating an object may generate onion messages to send
 */
typedef struct LDKOnionMessageProvider {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Gets the next pending onion message for the peer with the given node id.
    *
    * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKOnionMessage (*next_onion_message_for_peer)(const void *this_arg, struct LDKPublicKey peer_node_id);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKOnionMessageProvider;

/**
 * A trait to describe an object that can receive onion messages.
 */
typedef struct LDKOnionMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handle an incoming `onion_message` message from the given peer.
    */
   void (*handle_onion_message)(const void *this_arg, struct LDKPublicKey peer_node_id, const struct LDKOnionMessage *NONNULL_PTR msg);
   /**
    * Called when a connection is established with a peer. Can be used to track which peers
    * advertise onion message support and are online.
    *
    * May return an `Err(())` if the features the peer supports are not sufficient to communicate
    * with us. Implementors should be somewhat conservative about doing so, however, as other
    * message handlers may still wish to communicate with this peer.
    */
   struct LDKCResult_NoneNoneZ (*peer_connected)(const void *this_arg, struct LDKPublicKey their_node_id, const struct LDKInit *NONNULL_PTR init, bool inbound);
   /**
    * Indicates a connection to the peer failed/an existing connection was lost. Allows handlers to
    * drop and refuse to forward onion messages to this peer.
    */
   void (*peer_disconnected)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * Note that this method is called before [`Self::peer_connected`].
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of OnionMessageProvider for this object.
    */
   struct LDKOnionMessageProvider OnionMessageProvider;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKOnionMessageHandler;

/**
 * Trait to be implemented by custom message (unrelated to the channel/gossip LN layers)
 * decoders.
 */
typedef struct LDKCustomMessageReader {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Decodes a custom message to `CustomMessageType`. If the given message type is known to the
    * implementation and the message could be decoded, must return `Ok(Some(message))`. If the
    * message type is unknown to the implementation, must return `Ok(None)`. If a decoding error
    * occur, must return `Err(DecodeError::X)` where `X` details the encountered error.
    */
   struct LDKCResult_COption_TypeZDecodeErrorZ (*read)(const void *this_arg, uint16_t message_type, struct LDKu8slice buffer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageReader;

/**
 * A handler provided to [`PeerManager`] for reading and handling custom messages.
 *
 * [BOLT 1] specifies a custom message type range for use with experimental or application-specific
 * messages. `CustomMessageHandler` allows for user-defined handling of such types. See the
 * [`lightning_custom_message`] crate for tools useful in composing more than one custom handler.
 *
 * [BOLT 1]: https://github.com/lightning/bolts/blob/master/01-messaging.md
 * [`lightning_custom_message`]: https://docs.rs/lightning_custom_message/latest/lightning_custom_message
 */
typedef struct LDKCustomMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given message sent from `sender_node_id`, possibly producing messages for
    * [`CustomMessageHandler::get_and_clear_pending_msg`] to return and thus for [`PeerManager`]
    * to send.
    */
   struct LDKCResult_NoneLightningErrorZ (*handle_custom_message)(const void *this_arg, struct LDKType msg, struct LDKPublicKey sender_node_id);
   /**
    * Returns the list of pending messages that were generated by the handler, clearing the list
    * in the process. Each message is paired with the node id of the intended recipient. If no
    * connection to the node exists, then the message is simply not sent.
    */
   struct LDKCVec_C2Tuple_PublicKeyTypeZZ (*get_and_clear_pending_msg)(const void *this_arg);
   /**
    * Gets the node feature flags which this handler itself supports. All available handlers are
    * queried similarly and their feature flags are OR'd together to form the [`NodeFeatures`]
    * which are broadcasted in our [`NodeAnnouncement`] message.
    *
    * [`NodeAnnouncement`]: crate::ln::msgs::NodeAnnouncement
    */
   struct LDKNodeFeatures (*provided_node_features)(const void *this_arg);
   /**
    * Gets the init feature flags which should be sent to the given peer. All available handlers
    * are queried similarly and their feature flags are OR'd together to form the [`InitFeatures`]
    * which are sent in our [`Init`] message.
    *
    * [`Init`]: crate::ln::msgs::Init
    */
   struct LDKInitFeatures (*provided_init_features)(const void *this_arg, struct LDKPublicKey their_node_id);
   /**
    * Implementation of CustomMessageReader for this object.
    */
   struct LDKCustomMessageReader CustomMessageReader;
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomMessageHandler;



/**
 * A dummy struct which implements `RoutingMessageHandler` without storing any routing information
 * or doing any processing. You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKIgnoringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeIgnoringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKIgnoringMessageHandler;

/**
 * A handler for an [`OnionMessage`] containing a BOLT 12 Offers message as its payload.
 *
 * [`OnionMessage`]: crate::ln::msgs::OnionMessage
 */
typedef struct LDKOffersMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Handles the given message by either responding with an [`Bolt12Invoice`], sending a payment,
    * or replying with an error.
    */
   struct LDKCOption_OffersMessageZ (*handle_message)(const void *this_arg, struct LDKOffersMessage message);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKOffersMessageHandler;

/**
 * Handler for custom onion messages. If you are using [`SimpleArcOnionMessenger`],
 * [`SimpleRefOnionMessenger`], or prefer to ignore inbound custom onion messages,
 * [`IgnoringMessageHandler`] must be provided to [`OnionMessenger::new`]. Otherwise, a custom
 * implementation of this trait must be provided, with [`CustomMessage`] specifying the supported
 * message types.
 *
 * See [`OnionMessenger`] for example usage.
 *
 * [`IgnoringMessageHandler`]: crate::ln::peer_handler::IgnoringMessageHandler
 * [`CustomMessage`]: Self::CustomMessage
 */
typedef struct LDKCustomOnionMessageHandler {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Called with the custom message that was received, returning a response to send, if any.
    */
   struct LDKCOption_CustomOnionMessageContentsZ (*handle_custom_message)(const void *this_arg, struct LDKCustomOnionMessageContents msg);
   /**
    * Read a custom message of type `message_type` from `buffer`, returning `Ok(None)` if the
    * message type is unknown.
    */
   struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ (*read_custom_message)(const void *this_arg, uint64_t message_type, struct LDKu8slice buffer);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCustomOnionMessageHandler;



/**
 * A dummy struct which implements `ChannelMessageHandler` without having any channels.
 * You can provide one of these as the route_handler in a MessageHandler.
 */
typedef struct MUST_USE_STRUCT LDKErroringMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroringMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroringMessageHandler;



/**
 * Provides references to trait impls which handle different types of messages.
 */
typedef struct MUST_USE_STRUCT LDKMessageHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMessageHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMessageHandler;

/**
 * Provides an object which can be used to send data to and which uniquely identifies a connection
 * to a remote host. You will need to be able to generate multiple of these which meet Eq and
 * implement Hash to meet the PeerManager API.
 *
 * For efficiency, [`Clone`] should be relatively cheap for this type.
 *
 * Two descriptors may compare equal (by [`cmp::Eq`] and [`hash::Hash`]) as long as the original
 * has been disconnected, the [`PeerManager`] has been informed of the disconnection (either by it
 * having triggered the disconnection or a call to [`PeerManager::socket_disconnected`]), and no
 * further calls to the [`PeerManager`] related to the original socket occur. This allows you to
 * use a file descriptor for your SocketDescriptor directly, however for simplicity you may wish
 * to simply use another value which is guaranteed to be globally unique instead.
 */
typedef struct LDKSocketDescriptor {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Attempts to send some data from the given slice to the peer.
    *
    * Returns the amount of data which was sent, possibly 0 if the socket has since disconnected.
    * Note that in the disconnected case, [`PeerManager::socket_disconnected`] must still be
    * called and further write attempts may occur until that time.
    *
    * If the returned size is smaller than `data.len()`, a
    * [`PeerManager::write_buffer_space_avail`] call must be made the next time more data can be
    * written. Additionally, until a `send_data` event completes fully, no further
    * [`PeerManager::read_event`] calls should be made for the same peer! Because this is to
    * prevent denial-of-service issues, you should not read or buffer any data from the socket
    * until then.
    *
    * If a [`PeerManager::read_event`] call on this descriptor had previously returned true
    * (indicating that read events should be paused to prevent DoS in the send buffer),
    * `resume_read` may be set indicating that read events on this descriptor should resume. A
    * `resume_read` of false carries no meaning, and should not cause any action.
    */
   uintptr_t (*send_data)(void *this_arg, struct LDKu8slice data, bool resume_read);
   /**
    * Disconnect the socket pointed to by this SocketDescriptor.
    *
    * You do *not* need to call [`PeerManager::socket_disconnected`] with this socket after this
    * call (doing so is a noop).
    */
   void (*disconnect_socket)(void *this_arg);
   /**
    * Checks if two objects are equal given this object's this_arg pointer and another object.
    */
   bool (*eq)(const void *this_arg, const struct LDKSocketDescriptor *NONNULL_PTR other_arg);
   /**
    * Calculate a succinct non-cryptographic hash for an object given its this_arg pointer.
    * This is used, for example, for inclusion of this object in a hash map.
    */
   uint64_t (*hash)(const void *this_arg);
   /**
    * Called, if set, after this SocketDescriptor has been cloned into a duplicate object.
    * The new SocketDescriptor is provided, and should be mutated as needed to perform a
    * deep copy of the object pointed to by this_arg or avoid any double-freeing.
    */
   void (*cloned)(struct LDKSocketDescriptor *NONNULL_PTR new_SocketDescriptor);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKSocketDescriptor;



/**
 * A PeerManager manages a set of peers, described by their [`SocketDescriptor`] and marshalls
 * socket events into messages which it passes on to its [`MessageHandler`].
 *
 * Locks are taken internally, so you must never assume that reentrancy from a
 * [`SocketDescriptor`] call back into [`PeerManager`] methods will not deadlock.
 *
 * Calls to [`read_event`] will decode relevant messages and pass them to the
 * [`ChannelMessageHandler`], likely doing message processing in-line. Thus, the primary form of
 * parallelism in Rust-Lightning is in calls to [`read_event`]. Note, however, that calls to any
 * [`PeerManager`] functions related to the same connection must occur only in serial, making new
 * calls only after previous ones have returned.
 *
 * Rather than using a plain [`PeerManager`], it is preferable to use either a [`SimpleArcPeerManager`]
 * a [`SimpleRefPeerManager`], for conciseness. See their documentation for more details, but
 * essentially you should default to using a [`SimpleRefPeerManager`], and use a
 * [`SimpleArcPeerManager`] when you require a `PeerManager` with a static lifetime, such as when
 * you're using lightning-net-tokio.
 *
 * [`read_event`]: PeerManager::read_event
 */
typedef struct MUST_USE_STRUCT LDKPeerManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePeerManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPeerManager;



/**
 * Static channel fields used to build transactions given per-commitment fields, organized by
 * broadcaster/countersignatory.
 *
 * This is derived from the holder/counterparty-organized ChannelTransactionParameters via the
 * as_holder_broadcastable and as_counterparty_broadcastable functions.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelTransactionParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelTransactionParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelTransactionParameters;



/**
 * Features used within an `offer`.
 */
typedef struct MUST_USE_STRUCT LDKOfferFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOfferFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOfferFeatures;



/**
 * Features used within an `invoice_request`.
 */
typedef struct MUST_USE_STRUCT LDKInvoiceRequestFeatures {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeInvoiceRequestFeatures *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKInvoiceRequestFeatures;

/**
 * Integer in the range `0..=16`
 */
typedef struct LDKWitnessVersion {
   uint8_t _0;
} LDKWitnessVersion;



/**
 * The minimum amount required for an item in an [`Offer`], denominated in either bitcoin or
 * another currency.
 */
typedef struct MUST_USE_STRUCT LDKAmount {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeAmount *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKAmount;



/**
 * Quantity of items supported by an [`Offer`].
 */
typedef struct MUST_USE_STRUCT LDKQuantity {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeQuantity *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKQuantity;



/**
 * A hash for use in a specific context by tweaking with a context-dependent tag as per [BIP 340]
 * and computed over the merkle root of a TLV stream to sign as defined in [BOLT 12].
 *
 * [BIP 340]: https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
 * [BOLT 12]: https://github.com/rustyrussell/lightning-rfc/blob/guilt/offers/12-offer-encoding.md#signature-calculation
 */
typedef struct MUST_USE_STRUCT LDKTaggedHash {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeTaggedHash *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKTaggedHash;



/**
 * The field in the [`InvoiceRequest`] or the [`Bolt12Invoice`] that contained an error.
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 */
typedef struct MUST_USE_STRUCT LDKErroneousField {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeErroneousField *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKErroneousField;



/**
 * Receives and validates network updates from peers,
 * stores authentic and relevant data as a network graph.
 * This network graph is then used for routing payments.
 * Provides interface to help with initial routing sync by
 * serving historical announcements.
 */
typedef struct MUST_USE_STRUCT LDKP2PGossipSync {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeP2PGossipSync *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKP2PGossipSync;



/**
 * A read-only view of [`NetworkGraph`].
 */
typedef struct MUST_USE_STRUCT LDKReadOnlyNetworkGraph {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeReadOnlyNetworkGraph *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKReadOnlyNetworkGraph;



/**
 * A wrapper around [`ChannelInfo`] representing information about the channel as directed from a
 * source node to a target node.
 */
typedef struct MUST_USE_STRUCT LDKDirectedChannelInfo {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDirectedChannelInfo *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDirectedChannelInfo;

/**
 * The effective capacity of a channel for routing purposes.
 *
 * While this may be smaller than the actual channel capacity, amounts greater than
 * [`Self::as_msat`] should not be routed through the channel.
 */
typedef enum LDKEffectiveCapacity_Tag {
   /**
    * The available liquidity in the channel known from being a channel counterparty, and thus a
    * direct hop.
    */
   LDKEffectiveCapacity_ExactLiquidity,
   /**
    * The maximum HTLC amount in one direction as advertised on the gossip network.
    */
   LDKEffectiveCapacity_AdvertisedMaxHTLC,
   /**
    * The total capacity of the channel as determined by the funding transaction.
    */
   LDKEffectiveCapacity_Total,
   /**
    * A capacity sufficient to route any payment, typically used for private channels provided by
    * an invoice.
    */
   LDKEffectiveCapacity_Infinite,
   /**
    * The maximum HTLC amount as provided by an invoice route hint.
    */
   LDKEffectiveCapacity_HintMaxHTLC,
   /**
    * A capacity that is unknown possibly because either the chain state is unavailable to know
    * the total capacity or the `htlc_maximum_msat` was not advertised on the gossip network.
    */
   LDKEffectiveCapacity_Unknown,
   /**
    * Must be last for serialization purposes
    */
   LDKEffectiveCapacity_Sentinel,
} LDKEffectiveCapacity_Tag;

typedef struct LDKEffectiveCapacity_LDKExactLiquidity_Body {
   /**
    * Either the inbound or outbound liquidity depending on the direction, denominated in
    * millisatoshi.
    */
   uint64_t liquidity_msat;
} LDKEffectiveCapacity_LDKExactLiquidity_Body;

typedef struct LDKEffectiveCapacity_LDKAdvertisedMaxHTLC_Body {
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t amount_msat;
} LDKEffectiveCapacity_LDKAdvertisedMaxHTLC_Body;

typedef struct LDKEffectiveCapacity_LDKTotal_Body {
   /**
    * The funding amount denominated in millisatoshi.
    */
   uint64_t capacity_msat;
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t htlc_maximum_msat;
} LDKEffectiveCapacity_LDKTotal_Body;

typedef struct LDKEffectiveCapacity_LDKHintMaxHTLC_Body {
   /**
    * The maximum HTLC amount denominated in millisatoshi.
    */
   uint64_t amount_msat;
} LDKEffectiveCapacity_LDKHintMaxHTLC_Body;

typedef struct MUST_USE_STRUCT LDKEffectiveCapacity {
   LDKEffectiveCapacity_Tag tag;
   union {
      LDKEffectiveCapacity_LDKExactLiquidity_Body exact_liquidity;
      LDKEffectiveCapacity_LDKAdvertisedMaxHTLC_Body advertised_max_htlc;
      LDKEffectiveCapacity_LDKTotal_Body total;
      LDKEffectiveCapacity_LDKHintMaxHTLC_Body hint_max_htlc;
   };
} LDKEffectiveCapacity;



/**
 * A [`Router`] implemented using [`find_route`].
 */
typedef struct MUST_USE_STRUCT LDKDefaultRouter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDefaultRouter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDefaultRouter;



/**
 * [`ScoreLookUp`] implementation that factors in in-flight HTLC liquidity.
 *
 * Useful for custom [`Router`] implementations to wrap their [`ScoreLookUp`] on-the-fly when calling
 * [`find_route`].
 *
 * [`ScoreLookUp`]: crate::routing::scoring::ScoreLookUp
 */
typedef struct MUST_USE_STRUCT LDKScorerAccountingForInFlightHtlcs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeScorerAccountingForInFlightHtlcs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKScorerAccountingForInFlightHtlcs;

/**
 * The recipient of a payment, differing based on whether they've hidden their identity with route
 * blinding.
 */
typedef enum LDKPayee_Tag {
   /**
    * The recipient provided blinded paths and payinfo to reach them. The blinded paths themselves
    * will be included in the final [`Route`].
    */
   LDKPayee_Blinded,
   /**
    * The recipient included these route hints in their BOLT11 invoice.
    */
   LDKPayee_Clear,
   /**
    * Must be last for serialization purposes
    */
   LDKPayee_Sentinel,
} LDKPayee_Tag;

typedef struct LDKPayee_LDKBlinded_Body {
   /**
    * Aggregated routing info and blinded paths, for routing to the payee without knowing their
    * node id.
    */
   struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ route_hints;
   /**
    * Features supported by the payee.
    *
    * May be set from the payee's invoice. May be `None` if the invoice does not contain any
    * features.
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKBolt12InvoiceFeatures features;
} LDKPayee_LDKBlinded_Body;

typedef struct LDKPayee_LDKClear_Body {
   /**
    * The node id of the payee.
    */
   struct LDKPublicKey node_id;
   /**
    * Hints for routing to the payee, containing channels connecting the payee to public nodes.
    */
   struct LDKCVec_RouteHintZ route_hints;
   /**
    * Features supported by the payee.
    *
    * May be set from the payee's invoice or via [`for_keysend`]. May be `None` if the invoice
    * does not contain any features.
    *
    * [`for_keysend`]: PaymentParameters::for_keysend
    *
    * Note that this (or a relevant inner pointer) may be NULL or all-0s to represent None
    */
   struct LDKBolt11InvoiceFeatures features;
   /**
    * The minimum CLTV delta at the end of the route. This value must not be zero.
    */
   uint32_t final_cltv_expiry_delta;
} LDKPayee_LDKClear_Body;

typedef struct MUST_USE_STRUCT LDKPayee {
   LDKPayee_Tag tag;
   union {
      LDKPayee_LDKBlinded_Body blinded;
      LDKPayee_LDKClear_Body clear;
   };
} LDKPayee;

/**
 * A trait which can both lookup and update routing channel penalty scores.
 *
 * This is used in places where both bounds are required and implemented for all types which
 * implement [`ScoreLookUp`] and [`ScoreUpdate`].
 *
 * Bindings users may need to manually implement this for their custom scoring implementations.
 */
typedef struct LDKScore {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Implementation of ScoreLookUp for this object.
    */
   struct LDKScoreLookUp ScoreLookUp;
   /**
    * Implementation of ScoreUpdate for this object.
    */
   struct LDKScoreUpdate ScoreUpdate;
   /**
    * Serialize the object into a byte array
    */
   struct LDKCVec_u8Z (*write)(const void *this_arg);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKScore;



/**
 * A concrete implementation of [`LockableScore`] which supports multi-threading.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedLockableScore {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedLockableScore *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedLockableScore;



/**
 * A locked `MultiThreadedLockableScore`.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedScoreLockRead {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedScoreLockRead *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedScoreLockRead;



/**
 * A locked `MultiThreadedLockableScore`.
 */
typedef struct MUST_USE_STRUCT LDKMultiThreadedScoreLockWrite {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMultiThreadedScoreLockWrite *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMultiThreadedScoreLockWrite;



/**
 * Parameters for configuring [`ProbabilisticScorer`].
 *
 * Used to configure decay parameters that are static throughout the lifetime of the scorer.
 * these decay parameters affect the score of the channel penalty and are not changed on a
 * per-route penalty cost call.
 */
typedef struct MUST_USE_STRUCT LDKProbabilisticScoringDecayParameters {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeProbabilisticScoringDecayParameters *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKProbabilisticScoringDecayParameters;



/**
 * Simple implementation of [`EntropySource`], [`NodeSigner`], and [`SignerProvider`] that takes a
 * 32-byte seed for use as a BIP 32 extended key and derives keys from that.
 *
 * Your `node_id` is seed/0'.
 * Unilateral closes may use seed/1'.
 * Cooperative closes may use seed/2'.
 * The two close keys may be needed to claim on-chain funds!
 *
 * This struct cannot be used for nodes that wish to support receiving phantom payments;
 * [`PhantomKeysManager`] must be used instead.
 *
 * Note that switching between this struct and [`PhantomKeysManager`] will invalidate any
 * previously issued invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKKeysManager;



/**
 * Similar to [`KeysManager`], but allows the node using this struct to receive phantom node
 * payments.
 *
 * A phantom node payment is a payment made to a phantom invoice, which is an invoice that can be
 * paid to one of multiple nodes. This works because we encode the invoice route hints such that
 * LDK will recognize an incoming payment as destined for a phantom node, and collect the payment
 * itself without ever needing to forward to this fake node.
 *
 * Phantom node payments are useful for load balancing between multiple LDK nodes. They also
 * provide some fault tolerance, because payers will automatically retry paying other provided
 * nodes in the case that one node goes down.
 *
 * Note that multi-path payments are not supported in phantom invoices for security reasons.
 * Switching between this struct and [`KeysManager`] will invalidate any previously issued
 * invoices and attempts to pay previous invoices will fail.
 */
typedef struct MUST_USE_STRUCT LDKPhantomKeysManager {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativePhantomKeysManager *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKPhantomKeysManager;

/**
 * The destination of an onion message.
 */
typedef enum LDKDestination_Tag {
   /**
    * We're sending this onion message to a node.
    */
   LDKDestination_Node,
   /**
    * We're sending this onion message to a blinded path.
    */
   LDKDestination_BlindedPath,
   /**
    * Must be last for serialization purposes
    */
   LDKDestination_Sentinel,
} LDKDestination_Tag;

typedef struct MUST_USE_STRUCT LDKDestination {
   LDKDestination_Tag tag;
   union {
      struct {
         struct LDKPublicKey node;
      };
      struct {
         struct LDKBlindedPath blinded_path;
      };
   };
} LDKDestination;

/**
 * A trait defining behavior for routing an [`OnionMessage`].
 *
 * [`OnionMessage`]: msgs::OnionMessage
 */
typedef struct LDKMessageRouter {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns a route for sending an [`OnionMessage`] to the given [`Destination`].
    *
    * [`OnionMessage`]: msgs::OnionMessage
    */
   struct LDKCResult_OnionMessagePathNoneZ (*find_path)(const void *this_arg, struct LDKPublicKey sender, struct LDKCVec_PublicKeyZ peers, struct LDKDestination destination);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKMessageRouter;



/**
 * A sender, receiver and forwarder of onion messages. In upcoming releases, this object will be
 * used to retrieve invoices and fulfill invoice requests from [offers]. Currently, only sending
 * and receiving custom onion messages is supported.
 *
 * # Example
 *
 * ```
 * # extern crate bitcoin;
 * # use bitcoin::hashes::_export::_core::time::Duration;
 * # use bitcoin::secp256k1::{PublicKey, Secp256k1, SecretKey};
 * # use lightning::blinded_path::BlindedPath;
 * # use lightning::sign::KeysManager;
 * # use lightning::ln::peer_handler::IgnoringMessageHandler;
 * # use lightning::onion_message::messenger::{Destination, MessageRouter, OnionMessenger, OnionMessagePath};
 * # use lightning::onion_message::packet::{CustomOnionMessageContents, OnionMessageContents};
 * # use lightning::util::logger::{Logger, Record};
 * # use lightning::util::ser::{Writeable, Writer};
 * # use lightning::io;
 * # use std::sync::Arc;
 * # struct FakeLogger;
 * # impl Logger for FakeLogger {
 * #     fn log(&self, record: &Record) { unimplemented!() }
 * # }
 * # struct FakeMessageRouter {}
 * # impl MessageRouter for FakeMessageRouter {
 * #     fn find_path(&self, sender: PublicKey, peers: Vec<PublicKey>, destination: Destination) -> Result<OnionMessagePath, ()> {
 * #         unimplemented!()
 * #     }
 * # }
 * # let seed = [42u8; 32];
 * # let time = Duration::from_secs(123456);
 * # let keys_manager = KeysManager::new(&seed, time.as_secs(), time.subsec_nanos());
 * # let logger = Arc::new(FakeLogger {});
 * # let node_secret = SecretKey::from_slice(&hex::decode(\"0101010101010101010101010101010101010101010101010101010101010101\").unwrap()[..]).unwrap();
 * # let secp_ctx = Secp256k1::new();
 * # let hop_node_id1 = PublicKey::from_secret_key(&secp_ctx, &node_secret);
 * # let (hop_node_id2, hop_node_id3, hop_node_id4) = (hop_node_id1, hop_node_id1, hop_node_id1);
 * # let destination_node_id = hop_node_id1;
 * # let message_router = Arc::new(FakeMessageRouter {});
 * # let custom_message_handler = IgnoringMessageHandler {};
 * # let offers_message_handler = IgnoringMessageHandler {};
 * // Create the onion messenger. This must use the same `keys_manager` as is passed to your
 * // ChannelManager.
 * let onion_messenger = OnionMessenger::new(
 *     &keys_manager, &keys_manager, logger, message_router, &offers_message_handler,
 *     &custom_message_handler
 * );
 *
 * # #[derive(Clone)]
 * # struct YourCustomMessage {}
 * impl Writeable for YourCustomMessage {
 * \tfn write<W: Writer>(&self, w: &mut W) -> Result<(), io::Error> {
 * \t\t# Ok(())
 * \t\t// Write your custom onion message to `w`
 * \t}
 * }
 * impl CustomOnionMessageContents for YourCustomMessage {
 * \tfn tlv_type(&self) -> u64 {
 * \t\t# let your_custom_message_type = 42;
 * \t\tyour_custom_message_type
 * \t}
 * }
 * // Send a custom onion message to a node id.
 * let path = OnionMessagePath {
 * \tintermediate_nodes: vec![hop_node_id1, hop_node_id2],
 * \tdestination: Destination::Node(destination_node_id),
 * };
 * let reply_path = None;
 * # let your_custom_message = YourCustomMessage {};
 * let message = OnionMessageContents::Custom(your_custom_message);
 * onion_messenger.send_onion_message(path, message, reply_path);
 *
 * // Create a blinded path to yourself, for someone to send an onion message to.
 * # let your_node_id = hop_node_id1;
 * let hops = [hop_node_id3, hop_node_id4, your_node_id];
 * let blinded_path = BlindedPath::new_for_message(&hops, &keys_manager, &secp_ctx).unwrap();
 *
 * // Send a custom onion message to a blinded path.
 * let path = OnionMessagePath {
 * \tintermediate_nodes: vec![hop_node_id1, hop_node_id2],
 * \tdestination: Destination::BlindedPath(blinded_path),
 * };
 * let reply_path = None;
 * # let your_custom_message = YourCustomMessage {};
 * let message = OnionMessageContents::Custom(your_custom_message);
 * onion_messenger.send_onion_message(path, message, reply_path);
 * ```
 *
 * [offers]: <https://github.com/lightning/bolts/pull/798>
 * [`OnionMessenger`]: crate::onion_message::OnionMessenger
 */
typedef struct MUST_USE_STRUCT LDKOnionMessenger {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeOnionMessenger *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKOnionMessenger;



/**
 * A [`MessageRouter`] that always fails.
 */
typedef struct MUST_USE_STRUCT LDKDefaultMessageRouter {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeDefaultMessageRouter *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKDefaultMessageRouter;

/**
 * The contents of an onion message. In the context of offers, this would be the invoice, invoice
 * request, or invoice error.
 */
typedef enum LDKOnionMessageContents_Tag {
   /**
    * A message related to BOLT 12 Offers.
    */
   LDKOnionMessageContents_Offers,
   /**
    * A custom onion message specified by the user.
    */
   LDKOnionMessageContents_Custom,
   /**
    * Must be last for serialization purposes
    */
   LDKOnionMessageContents_Sentinel,
} LDKOnionMessageContents_Tag;

typedef struct MUST_USE_STRUCT LDKOnionMessageContents {
   LDKOnionMessageContents_Tag tag;
   union {
      struct {
         struct LDKOffersMessage offers;
      };
      struct {
         struct LDKCustomOnionMessageContents custom;
      };
   };
} LDKOnionMessageContents;



/**
 * An intermediate node, its outbound channel, and relay parameters.
 */
typedef struct MUST_USE_STRUCT LDKForwardNode {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeForwardNode *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKForwardNode;



/**
 * Data to construct a [`BlindedHop`] for forwarding a payment.
 */
typedef struct MUST_USE_STRUCT LDKForwardTlvs {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeForwardTlvs *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKForwardTlvs;

/**
 * An abstraction over a bitcoin wallet that can perform coin selection over a set of UTXOs and can
 * sign for them. The coin selection method aims to mimic Bitcoin Core's `fundrawtransaction` RPC,
 * which most wallets should be able to satisfy. Otherwise, consider implementing [`WalletSource`],
 * which can provide a default implementation of this trait when used with [`Wallet`].
 */
typedef struct LDKCoinSelectionSource {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Performs coin selection of a set of UTXOs, with at least 1 confirmation each, that are
    * available to spend. Implementations are free to pick their coin selection algorithm of
    * choice, as long as the following requirements are met:
    *
    * 1. `must_spend` contains a set of [`Input`]s that must be included in the transaction
    *    throughout coin selection, but must not be returned as part of the result.
    * 2. `must_pay_to` contains a set of [`TxOut`]s that must be included in the transaction
    *    throughout coin selection. In some cases, like when funding an anchor transaction, this
    *    set is empty. Implementations should ensure they handle this correctly on their end,
    *    e.g., Bitcoin Core's `fundrawtransaction` RPC requires at least one output to be
    *    provided, in which case a zero-value empty OP_RETURN output can be used instead.
    * 3. Enough inputs must be selected/contributed for the resulting transaction (including the
    *    inputs and outputs noted above) to meet `target_feerate_sat_per_1000_weight`.
    *
    * Implementations must take note that [`Input::satisfaction_weight`] only tracks the weight of
    * the input's `script_sig` and `witness`. Some wallets, like Bitcoin Core's, may require
    * providing the full input weight. Failing to do so may lead to underestimating fee bumps and
    * delaying block inclusion.
    *
    * The `claim_id` must map to the set of external UTXOs assigned to the claim, such that they
    * can be re-used within new fee-bumped iterations of the original claiming transaction,
    * ensuring that claims don't double spend each other. If a specific `claim_id` has never had a
    * transaction associated with it, and all of the available UTXOs have already been assigned to
    * other claims, implementations must be willing to double spend their UTXOs. The choice of
    * which UTXOs to double spend is left to the implementation, but it must strive to keep the
    * set of other claims being double spent to a minimum.
    */
   struct LDKCResult_CoinSelectionNoneZ (*select_confirmed_utxos)(const void *this_arg, struct LDKThirtyTwoBytes claim_id, struct LDKCVec_InputZ must_spend, struct LDKCVec_TxOutZ must_pay_to, uint32_t target_feerate_sat_per_1000_weight);
   /**
    * Signs and provides the full witness for all inputs within the transaction known to the
    * trait (i.e., any provided via [`CoinSelectionSource::select_confirmed_utxos`]).
    */
   struct LDKCResult_TransactionNoneZ (*sign_tx)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKCoinSelectionSource;

/**
 * An alternative to [`CoinSelectionSource`] that can be implemented and used along [`Wallet`] to
 * provide a default implementation to [`CoinSelectionSource`].
 */
typedef struct LDKWalletSource {
   /**
    * An opaque pointer which is passed to your function implementations as an argument.
    * This has no meaning in the LDK, and can be NULL or any other value.
    */
   void *this_arg;
   /**
    * Returns all UTXOs, with at least 1 confirmation each, that are available to spend.
    */
   struct LDKCResult_CVec_UtxoZNoneZ (*list_confirmed_utxos)(const void *this_arg);
   /**
    * Returns a script to use for change above dust resulting from a successful coin selection
    * attempt.
    */
   struct LDKCResult_CVec_u8ZNoneZ (*get_change_script)(const void *this_arg);
   /**
    * Signs and provides the full [`TxIn::script_sig`] and [`TxIn::witness`] for all inputs within
    * the transaction known to the wallet (i.e., any provided via
    * [`WalletSource::list_confirmed_utxos`]).
    */
   struct LDKCResult_TransactionNoneZ (*sign_tx)(const void *this_arg, struct LDKTransaction tx);
   /**
    * Frees any resources associated with this object given its this_arg pointer.
    * Does not need to free the outer struct containing function pointers and may be NULL is no resources need to be freed.
    */
   void (*free)(void *this_arg);
} LDKWalletSource;



/**
 * A wrapper over [`WalletSource`] that implements [`CoinSelection`] by preferring UTXOs that would
 * avoid conflicting double spends. If not enough UTXOs are available to do so, conflicting double
 * spends may happen.
 */
typedef struct MUST_USE_STRUCT LDKWallet {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeWallet *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKWallet;



/**
 * A handler for [`Event::BumpTransaction`] events that sources confirmed UTXOs from a
 * [`CoinSelectionSource`] to fee bump transactions via Child-Pays-For-Parent (CPFP) or
 * Replace-By-Fee (RBF).
 *
 * [`Event::BumpTransaction`]: crate::events::Event::BumpTransaction
 */
typedef struct MUST_USE_STRUCT LDKBumpTransactionEventHandler {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBumpTransactionEventHandler *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBumpTransactionEventHandler;



/**
 * A [`KVStore`] implementation that writes to and reads from the file system.
 */
typedef struct MUST_USE_STRUCT LDKFilesystemStore {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeFilesystemStore *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKFilesystemStore;



/**
 * `BackgroundProcessor` takes care of tasks that (1) need to happen periodically to keep
 * Rust-Lightning running properly, and (2) either can or should be run in the background. Its
 * responsibilities are:
 * * Processing [`Event`]s with a user-provided [`EventHandler`].
 * * Monitoring whether the [`ChannelManager`] needs to be re-persisted to disk, and if so,
 *   writing it to disk/backups by invoking the callback given to it at startup.
 *   [`ChannelManager`] persistence should be done in the background.
 * * Calling [`ChannelManager::timer_tick_occurred`], [`ChainMonitor::rebroadcast_pending_claims`]
 *   and [`PeerManager::timer_tick_occurred`] at the appropriate intervals.
 * * Calling [`NetworkGraph::remove_stale_channels_and_tracking`] (if a [`GossipSync`] with a
 *   [`NetworkGraph`] is provided to [`BackgroundProcessor::start`]).
 *
 * It will also call [`PeerManager::process_events`] periodically though this shouldn't be relied
 * upon as doing so may result in high latency.
 *
 * # Note
 *
 * If [`ChannelManager`] persistence fails and the persisted manager becomes out-of-date, then
 * there is a risk of channels force-closing on startup when the manager realizes it's outdated.
 * However, as long as [`ChannelMonitor`] backups are sound, no funds besides those used for
 * unilateral chain closure fees are at risk.
 *
 * [`ChannelMonitor`]: lightning::chain::channelmonitor::ChannelMonitor
 * [`Event`]: lightning::events::Event
 * [`PeerManager::timer_tick_occurred`]: lightning::ln::peer_handler::PeerManager::timer_tick_occurred
 * [`PeerManager::process_events`]: lightning::ln::peer_handler::PeerManager::process_events
 *BackgroundProcessor will immediately stop on drop. It should be stored until shutdown.
 */
typedef struct MUST_USE_STRUCT LDKBackgroundProcessor {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeBackgroundProcessor *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKBackgroundProcessor;



/**
 * The main Rapid Gossip Sync object.
 *
 * See [crate-level documentation] for usage.
 *
 * [crate-level documentation]: crate
 */
typedef struct MUST_USE_STRUCT LDKRapidGossipSync {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRapidGossipSync *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRapidGossipSync;

/**
 * Either [`P2PGossipSync`] or [`RapidGossipSync`].
 */
typedef enum LDKGossipSync_Tag {
   /**
    * Gossip sync via the lightning peer-to-peer network as defined by BOLT 7.
    */
   LDKGossipSync_P2P,
   /**
    * Rapid gossip sync from a trusted server.
    */
   LDKGossipSync_Rapid,
   /**
    * No gossip sync.
    */
   LDKGossipSync_None,
   /**
    * Must be last for serialization purposes
    */
   LDKGossipSync_Sentinel,
} LDKGossipSync_Tag;

typedef struct MUST_USE_STRUCT LDKGossipSync {
   LDKGossipSync_Tag tag;
   union {
      struct {
         /**
          * Note that this field is expected to be a reference.
          */
         struct LDKP2PGossipSync p2p;
      };
      struct {
         /**
          * Note that this field is expected to be a reference.
          */
         struct LDKRapidGossipSync rapid;
      };
   };
} LDKGossipSync;



/**
 * Data of the [`RawBolt11Invoice`] that is encoded in the data part
 */
typedef struct MUST_USE_STRUCT LDKRawDataPart {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeRawDataPart *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKRawDataPart;



/**
 * SHA-256 hash
 */
typedef struct MUST_USE_STRUCT LDKSha256 {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeSha256 *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKSha256;



/**
 * Positive duration that defines when (relatively to the timestamp) in the future the invoice
 * expires
 */
typedef struct MUST_USE_STRUCT LDKExpiryTime {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeExpiryTime *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKExpiryTime;



/**
 * `min_final_cltv_expiry_delta` to use for the last HTLC in the route
 */
typedef struct MUST_USE_STRUCT LDKMinFinalCltvExpiryDelta {
   /**
    * A pointer to the opaque Rust object.
    * Nearly everywhere, inner must be non-null, however in places where
    * the Rust equivalent takes an Option, it may be set to null to indicate None.
    */
   LDKnativeMinFinalCltvExpiryDelta *inner;
   /**
    * Indicates that this is the only struct which contains the same pointer.
    * Rust functions which take ownership of an object provided via an argument require
    * this to be true and invalidate the object pointed to by inner.
    */
   bool is_owned;
} LDKMinFinalCltvExpiryDelta;

/**
 * A 20-byte byte array.
 */
typedef struct LDKTwentyBytes {
   /**
    * The twenty bytes
    */
   uint8_t data[20];
} LDKTwentyBytes;

/**
 * Fallback address in case no LN payment is possible
 */
typedef enum LDKFallback_Tag {
   LDKFallback_SegWitProgram,
   LDKFallback_PubKeyHash,
   LDKFallback_ScriptHash,
   /**
    * Must be last for serialization purposes
    */
   LDKFallback_Sentinel,
} LDKFallback_Tag;

typedef struct LDKFallback_LDKSegWitProgram_Body {
   struct LDKWitnessVersion version;
   struct LDKCVec_u8Z program;
} LDKFallback_LDKSegWitProgram_Body;

typedef struct MUST_USE_STRUCT LDKFallback {
   LDKFallback_Tag tag;
   union {
      LDKFallback_LDKSegWitProgram_Body seg_wit_program;
      struct {
         struct LDKTwentyBytes pub_key_hash;
      };
      struct {
         struct LDKTwentyBytes script_hash;
      };
   };
} LDKFallback;

extern const uintptr_t MAX_BUF_SIZE;

extern const uintptr_t KVSTORE_NAMESPACE_KEY_MAX_LEN;

extern const uint64_t MIN_RELAY_FEE_SAT_PER_1000_WEIGHT;

extern const uint32_t FEERATE_FLOOR_SATS_PER_KW;

extern const uint64_t CLOSED_CHANNEL_UPDATE_ID;

extern const uint32_t ANTI_REORG_DELAY;

extern const uint16_t BREAKDOWN_TIMEOUT;

extern const uint16_t MIN_CLTV_EXPIRY_DELTA;

extern const uint16_t MIN_FINAL_CLTV_EXPIRY_DELTA;

extern const uint16_t MAX_HTLCS;

extern const uintptr_t OFFERED_HTLC_SCRIPT_WEIGHT;

extern const uintptr_t OFFERED_HTLC_SCRIPT_WEIGHT_ANCHORS;

extern const uintptr_t MAX_ACCEPTED_HTLC_SCRIPT_WEIGHT;

extern const uint64_t ANCHOR_INPUT_WITNESS_WEIGHT;

extern const uint64_t HTLC_TIMEOUT_INPUT_ANCHOR_WITNESS_WEIGHT;

extern const uint64_t HTLC_SUCCESS_INPUT_ANCHOR_WITNESS_WEIGHT;

extern const uintptr_t REVOKEABLE_REDEEMSCRIPT_MAX_LENGTH;

extern const uint64_t UNKNOWN_CHANNEL_CAPACITY_MSAT;

extern const uint32_t DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA;

extern const uint8_t DEFAULT_MAX_PATH_COUNT;

extern const uint64_t MAX_TIMESTAMP;

extern const uint64_t DEFAULT_EXPIRY_TIME;

extern const uint64_t DEFAULT_MIN_FINAL_CLTV_EXPIRY_DELTA;

extern const uint8_t TAG_PAYMENT_HASH;

extern const uint8_t TAG_DESCRIPTION;

extern const uint8_t TAG_PAYEE_PUB_KEY;

extern const uint8_t TAG_DESCRIPTION_HASH;

extern const uint8_t TAG_EXPIRY_TIME;

extern const uint8_t TAG_MIN_FINAL_CLTV_EXPIRY_DELTA;

extern const uint8_t TAG_FALLBACK;

extern const uint8_t TAG_PRIVATE_ROUTE;

extern const uint8_t TAG_PAYMENT_SECRET;

extern const uint8_t TAG_PAYMENT_METADATA;

extern const uint8_t TAG_FEATURES;

struct LDKStr _ldk_get_compiled_version(void);

struct LDKStr _ldk_c_bindings_get_compiled_version(void);

/**
 * Gets the 128-bit integer, as 16 little-endian bytes
 */
struct LDKSixteenBytes U128_le_bytes(struct LDKU128 val);

/**
 * Constructs a new U128 from 16 little-endian bytes
 */
struct LDKU128 U128_new(struct LDKSixteenBytes le_bytes);

/**
 * Convenience function for constructing a new BigEndianScalar
 */
struct LDKBigEndianScalar BigEndianScalar_new(struct LDKThirtyTwoBytes big_endian_bytes);

/**
 * Creates a new Bech32Error which has the same data as `orig`
 */
struct LDKBech32Error Bech32Error_clone(const struct LDKBech32Error *NONNULL_PTR orig);

/**
 * Releases any memory held by the given `Bech32Error` (which is currently none)
 */
void Bech32Error_free(struct LDKBech32Error o);

/**
 * Frees the data buffer, if data_is_owned is set and datalen > 0.
 */
void Transaction_free(struct LDKTransaction _res);

/**
 * Creates a new Witness which has the same data as `orig` but with a new buffer.
 */
struct LDKWitness Witness_clone(const struct LDKWitness *NONNULL_PTR orig);

/**
 * Frees the data pointed to by data
 */
void Witness_free(struct LDKWitness _res);

/**
 * Frees the witness and script_sig in a TxIn
 */
void TxIn_free(struct LDKTxIn _res);

/**
 * Convenience function for constructing a new TxIn
 */
struct LDKTxIn TxIn_new(struct LDKWitness witness, struct LDKCVec_u8Z script_sig, uint32_t sequence, struct LDKThirtyTwoBytes previous_txid, uint32_t previous_vout);

/**
 * Convenience function for constructing a new TxOut
 */
struct LDKTxOut TxOut_new(struct LDKCVec_u8Z script_pubkey, uint64_t value);

/**
 * Frees the data pointed to by script_pubkey.
 */
void TxOut_free(struct LDKTxOut _res);

/**
 * Creates a new TxOut which has the same data as `orig` but with a new script buffer.
 */
struct LDKTxOut TxOut_clone(const struct LDKTxOut *NONNULL_PTR orig);

/**
 * Frees the data buffer, if chars_is_owned is set and len > 0.
 */
void Str_free(struct LDKStr _res);

#if defined(LDK_DEBUG_BUILD)
/**
 * This function exists for memory safety testing purposes. It should never be used in production
 * code
 */
const void *__unmangle_inner_ptr(const void *ptr);
#endif

/**
 * Constructs a new COption_u64Z containing a u64
 */
struct LDKCOption_u64Z COption_u64Z_some(uint64_t o);

/**
 * Constructs a new COption_u64Z containing nothing
 */
struct LDKCOption_u64Z COption_u64Z_none(void);

/**
 * Frees any resources associated with the u64, if we are in the Some state
 */
void COption_u64Z_free(struct LDKCOption_u64Z _res);

/**
 * Creates a new COption_u64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u64Z COption_u64Z_clone(const struct LDKCOption_u64Z *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_BlindedPathZ_free(struct LDKCVec_BlindedPathZ _res);

/**
 * Creates a new CResult_RefundBolt12ParseErrorZ in the success state.
 */
struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_ok(struct LDKRefund o);

/**
 * Creates a new CResult_RefundBolt12ParseErrorZ in the error state.
 */
struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_err(struct LDKBolt12ParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RefundBolt12ParseErrorZ_is_ok(const struct LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RefundBolt12ParseErrorZ.
 */
void CResult_RefundBolt12ParseErrorZ_free(struct LDKCResult_RefundBolt12ParseErrorZ _res);

/**
 * Creates a new CResult_RefundBolt12ParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RefundBolt12ParseErrorZ CResult_RefundBolt12ParseErrorZ_clone(const struct LDKCResult_RefundBolt12ParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RetryDecodeErrorZ in the success state.
 */
struct LDKCResult_RetryDecodeErrorZ CResult_RetryDecodeErrorZ_ok(struct LDKRetry o);

/**
 * Creates a new CResult_RetryDecodeErrorZ in the error state.
 */
struct LDKCResult_RetryDecodeErrorZ CResult_RetryDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RetryDecodeErrorZ_is_ok(const struct LDKCResult_RetryDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RetryDecodeErrorZ.
 */
void CResult_RetryDecodeErrorZ_free(struct LDKCResult_RetryDecodeErrorZ _res);

/**
 * Creates a new CResult_RetryDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RetryDecodeErrorZ CResult_RetryDecodeErrorZ_clone(const struct LDKCResult_RetryDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneAPIErrorZ in the success state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_ok(void);

/**
 * Creates a new CResult_NoneAPIErrorZ in the error state.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneAPIErrorZ_is_ok(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneAPIErrorZ.
 */
void CResult_NoneAPIErrorZ_free(struct LDKCResult_NoneAPIErrorZ _res);

/**
 * Creates a new CResult_NoneAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneAPIErrorZ CResult_NoneAPIErrorZ_clone(const struct LDKCResult_NoneAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CResult_NoneAPIErrorZZ_free(struct LDKCVec_CResult_NoneAPIErrorZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_APIErrorZ_free(struct LDKCVec_APIErrorZ _res);

/**
 * Constructs a new COption_ThirtyTwoBytesZ containing a crate::c_types::ThirtyTwoBytes
 */
struct LDKCOption_ThirtyTwoBytesZ COption_ThirtyTwoBytesZ_some(struct LDKThirtyTwoBytes o);

/**
 * Constructs a new COption_ThirtyTwoBytesZ containing nothing
 */
struct LDKCOption_ThirtyTwoBytesZ COption_ThirtyTwoBytesZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::ThirtyTwoBytes, if we are in the Some state
 */
void COption_ThirtyTwoBytesZ_free(struct LDKCOption_ThirtyTwoBytesZ _res);

/**
 * Creates a new COption_ThirtyTwoBytesZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_ThirtyTwoBytesZ COption_ThirtyTwoBytesZ_clone(const struct LDKCOption_ThirtyTwoBytesZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u8Z_free(struct LDKCVec_u8Z _res);

/**
 * Constructs a new COption_CVec_u8ZZ containing a crate::c_types::derived::CVec_u8Z
 */
struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_some(struct LDKCVec_u8Z o);

/**
 * Constructs a new COption_CVec_u8ZZ containing nothing
 */
struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::CVec_u8Z, if we are in the Some state
 */
void COption_CVec_u8ZZ_free(struct LDKCOption_CVec_u8ZZ _res);

/**
 * Creates a new COption_CVec_u8ZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CVec_u8ZZ COption_CVec_u8ZZ_clone(const struct LDKCOption_CVec_u8ZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the success state.
 */
struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_ok(struct LDKRecipientOnionFields o);

/**
 * Creates a new CResult_RecipientOnionFieldsDecodeErrorZ in the error state.
 */
struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RecipientOnionFieldsDecodeErrorZ_is_ok(const struct LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RecipientOnionFieldsDecodeErrorZ.
 */
void CResult_RecipientOnionFieldsDecodeErrorZ_free(struct LDKCResult_RecipientOnionFieldsDecodeErrorZ _res);

/**
 * Creates a new CResult_RecipientOnionFieldsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecipientOnionFieldsDecodeErrorZ CResult_RecipientOnionFieldsDecodeErrorZ_clone(const struct LDKCResult_RecipientOnionFieldsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u64CVec_u8ZZ C2Tuple_u64CVec_u8ZZ_clone(const struct LDKC2Tuple_u64CVec_u8ZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u64CVec_u8ZZ from the contained elements.
 */
struct LDKC2Tuple_u64CVec_u8ZZ C2Tuple_u64CVec_u8ZZ_new(uint64_t a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_u64CVec_u8ZZ.
 */
void C2Tuple_u64CVec_u8ZZ_free(struct LDKC2Tuple_u64CVec_u8ZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u64CVec_u8ZZZ_free(struct LDKCVec_C2Tuple_u64CVec_u8ZZZ _res);

/**
 * Creates a new CResult_RecipientOnionFieldsNoneZ in the success state.
 */
struct LDKCResult_RecipientOnionFieldsNoneZ CResult_RecipientOnionFieldsNoneZ_ok(struct LDKRecipientOnionFields o);

/**
 * Creates a new CResult_RecipientOnionFieldsNoneZ in the error state.
 */
struct LDKCResult_RecipientOnionFieldsNoneZ CResult_RecipientOnionFieldsNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RecipientOnionFieldsNoneZ_is_ok(const struct LDKCResult_RecipientOnionFieldsNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RecipientOnionFieldsNoneZ.
 */
void CResult_RecipientOnionFieldsNoneZ_free(struct LDKCResult_RecipientOnionFieldsNoneZ _res);

/**
 * Creates a new CResult_RecipientOnionFieldsNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecipientOnionFieldsNoneZ CResult_RecipientOnionFieldsNoneZ_clone(const struct LDKCResult_RecipientOnionFieldsNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ThirtyTwoBytesZ_free(struct LDKCVec_ThirtyTwoBytesZ _res);

/**
 * Constructs a new COption_CVec_ThirtyTwoBytesZZ containing a crate::c_types::derived::CVec_ThirtyTwoBytesZ
 */
struct LDKCOption_CVec_ThirtyTwoBytesZZ COption_CVec_ThirtyTwoBytesZZ_some(struct LDKCVec_ThirtyTwoBytesZ o);

/**
 * Constructs a new COption_CVec_ThirtyTwoBytesZZ containing nothing
 */
struct LDKCOption_CVec_ThirtyTwoBytesZZ COption_CVec_ThirtyTwoBytesZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::CVec_ThirtyTwoBytesZ, if we are in the Some state
 */
void COption_CVec_ThirtyTwoBytesZZ_free(struct LDKCOption_CVec_ThirtyTwoBytesZZ _res);

/**
 * Creates a new COption_CVec_ThirtyTwoBytesZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CVec_ThirtyTwoBytesZZ COption_CVec_ThirtyTwoBytesZZ_clone(const struct LDKCOption_CVec_ThirtyTwoBytesZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ThirtyTwoBytesNoneZ in the success state.
 */
struct LDKCResult_ThirtyTwoBytesNoneZ CResult_ThirtyTwoBytesNoneZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_ThirtyTwoBytesNoneZ in the error state.
 */
struct LDKCResult_ThirtyTwoBytesNoneZ CResult_ThirtyTwoBytesNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ThirtyTwoBytesNoneZ_is_ok(const struct LDKCResult_ThirtyTwoBytesNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ThirtyTwoBytesNoneZ.
 */
void CResult_ThirtyTwoBytesNoneZ_free(struct LDKCResult_ThirtyTwoBytesNoneZ _res);

/**
 * Creates a new CResult_ThirtyTwoBytesNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ThirtyTwoBytesNoneZ CResult_ThirtyTwoBytesNoneZ_clone(const struct LDKCResult_ThirtyTwoBytesNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedPayInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_ok(struct LDKBlindedPayInfo o);

/**
 * Creates a new CResult_BlindedPayInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedPayInfoDecodeErrorZ_is_ok(const struct LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedPayInfoDecodeErrorZ.
 */
void CResult_BlindedPayInfoDecodeErrorZ_free(struct LDKCResult_BlindedPayInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedPayInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedPayInfoDecodeErrorZ CResult_BlindedPayInfoDecodeErrorZ_clone(const struct LDKCResult_BlindedPayInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKDelayedPaymentOutputDescriptor o);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DelayedPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_DelayedPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ CResult_DelayedPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_ok(struct LDKStaticPaymentOutputDescriptor o);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StaticPaymentOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StaticPaymentOutputDescriptorDecodeErrorZ.
 */
void CResult_StaticPaymentOutputDescriptorDecodeErrorZ_free(struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_StaticPaymentOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ CResult_StaticPaymentOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_ok(struct LDKSpendableOutputDescriptor o);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SpendableOutputDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SpendableOutputDescriptorDecodeErrorZ.
 */
void CResult_SpendableOutputDescriptorDecodeErrorZ_free(struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_SpendableOutputDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ CResult_SpendableOutputDescriptorDecodeErrorZ_clone(const struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SpendableOutputDescriptorZ_free(struct LDKCVec_SpendableOutputDescriptorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TxOutZ_free(struct LDKCVec_TxOutZ _res);

/**
 * Constructs a new COption_u32Z containing a u32
 */
struct LDKCOption_u32Z COption_u32Z_some(uint32_t o);

/**
 * Constructs a new COption_u32Z containing nothing
 */
struct LDKCOption_u32Z COption_u32Z_none(void);

/**
 * Frees any resources associated with the u32, if we are in the Some state
 */
void COption_u32Z_free(struct LDKCOption_u32Z _res);

/**
 * Creates a new COption_u32Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u32Z COption_u32Z_clone(const struct LDKCOption_u32Z *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_CVec_u8ZusizeZ C2Tuple_CVec_u8ZusizeZ_clone(const struct LDKC2Tuple_CVec_u8ZusizeZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_CVec_u8ZusizeZ from the contained elements.
 */
struct LDKC2Tuple_CVec_u8ZusizeZ C2Tuple_CVec_u8ZusizeZ_new(struct LDKCVec_u8Z a, uintptr_t b);

/**
 * Frees any resources used by the C2Tuple_CVec_u8ZusizeZ.
 */
void C2Tuple_CVec_u8ZusizeZ_free(struct LDKC2Tuple_CVec_u8ZusizeZ _res);

/**
 * Creates a new CResult_C2Tuple_CVec_u8ZusizeZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ CResult_C2Tuple_CVec_u8ZusizeZNoneZ_ok(struct LDKC2Tuple_CVec_u8ZusizeZ o);

/**
 * Creates a new CResult_C2Tuple_CVec_u8ZusizeZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ CResult_C2Tuple_CVec_u8ZusizeZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_CVec_u8ZusizeZNoneZ_is_ok(const struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_CVec_u8ZusizeZNoneZ.
 */
void CResult_C2Tuple_CVec_u8ZusizeZNoneZ_free(struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_CVec_u8ZusizeZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ CResult_C2Tuple_CVec_u8ZusizeZNoneZ_clone(const struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneNoneZ in the success state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_ok(void);

/**
 * Creates a new CResult_NoneNoneZ in the error state.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneNoneZ_is_ok(const struct LDKCResult_NoneNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneNoneZ.
 */
void CResult_NoneNoneZ_free(struct LDKCResult_NoneNoneZ _res);

/**
 * Creates a new CResult_NoneNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneNoneZ CResult_NoneNoneZ_clone(const struct LDKCResult_NoneNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ECDSASignatureZ_free(struct LDKCVec_ECDSASignatureZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_clone(const struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ from the contained elements.
 */
struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_new(struct LDKECDSASignature a, struct LDKCVec_ECDSASignatureZ b);

/**
 * Frees any resources used by the C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ.
 */
void C2Tuple_ECDSASignatureCVec_ECDSASignatureZZ_free(struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ _res);

/**
 * Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_ok(struct LDKC2Tuple_ECDSASignatureCVec_ECDSASignatureZZ o);

/**
 * Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_is_ok(const struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ.
 */
void CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_free(struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ CResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ_clone(const struct LDKCResult_C2Tuple_ECDSASignatureCVec_ECDSASignatureZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ECDSASignatureNoneZ in the success state.
 */
struct LDKCResult_ECDSASignatureNoneZ CResult_ECDSASignatureNoneZ_ok(struct LDKECDSASignature o);

/**
 * Creates a new CResult_ECDSASignatureNoneZ in the error state.
 */
struct LDKCResult_ECDSASignatureNoneZ CResult_ECDSASignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ECDSASignatureNoneZ_is_ok(const struct LDKCResult_ECDSASignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ECDSASignatureNoneZ.
 */
void CResult_ECDSASignatureNoneZ_free(struct LDKCResult_ECDSASignatureNoneZ _res);

/**
 * Creates a new CResult_ECDSASignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ECDSASignatureNoneZ CResult_ECDSASignatureNoneZ_clone(const struct LDKCResult_ECDSASignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PublicKeyNoneZ in the success state.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeyNoneZ in the error state.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PublicKeyNoneZ_is_ok(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PublicKeyNoneZ.
 */
void CResult_PublicKeyNoneZ_free(struct LDKCResult_PublicKeyNoneZ _res);

/**
 * Creates a new CResult_PublicKeyNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeyNoneZ CResult_PublicKeyNoneZ_clone(const struct LDKCResult_PublicKeyNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_BigEndianScalarZ containing a crate::c_types::BigEndianScalar
 */
struct LDKCOption_BigEndianScalarZ COption_BigEndianScalarZ_some(struct LDKBigEndianScalar o);

/**
 * Constructs a new COption_BigEndianScalarZ containing nothing
 */
struct LDKCOption_BigEndianScalarZ COption_BigEndianScalarZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::BigEndianScalar, if we are in the Some state
 */
void COption_BigEndianScalarZ_free(struct LDKCOption_BigEndianScalarZ _res);

/**
 * Creates a new COption_BigEndianScalarZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_BigEndianScalarZ COption_BigEndianScalarZ_clone(const struct LDKCOption_BigEndianScalarZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_U5Z_free(struct LDKCVec_U5Z _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the success state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_ok(struct LDKRecoverableSignature o);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ in the error state.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RecoverableSignatureNoneZ_is_ok(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RecoverableSignatureNoneZ.
 */
void CResult_RecoverableSignatureNoneZ_free(struct LDKCResult_RecoverableSignatureNoneZ _res);

/**
 * Creates a new CResult_RecoverableSignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RecoverableSignatureNoneZ CResult_RecoverableSignatureNoneZ_clone(const struct LDKCResult_RecoverableSignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SchnorrSignatureNoneZ in the success state.
 */
struct LDKCResult_SchnorrSignatureNoneZ CResult_SchnorrSignatureNoneZ_ok(struct LDKSchnorrSignature o);

/**
 * Creates a new CResult_SchnorrSignatureNoneZ in the error state.
 */
struct LDKCResult_SchnorrSignatureNoneZ CResult_SchnorrSignatureNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SchnorrSignatureNoneZ_is_ok(const struct LDKCResult_SchnorrSignatureNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SchnorrSignatureNoneZ.
 */
void CResult_SchnorrSignatureNoneZ_free(struct LDKCResult_SchnorrSignatureNoneZ _res);

/**
 * Creates a new CResult_SchnorrSignatureNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SchnorrSignatureNoneZ CResult_SchnorrSignatureNoneZ_clone(const struct LDKCResult_SchnorrSignatureNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ in the success state.
 */
struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_ok(struct LDKWriteableEcdsaChannelSigner o);

/**
 * Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ in the error state.
 */
struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_WriteableEcdsaChannelSignerDecodeErrorZ_is_ok(const struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_WriteableEcdsaChannelSignerDecodeErrorZ.
 */
void CResult_WriteableEcdsaChannelSignerDecodeErrorZ_free(struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ _res);

/**
 * Creates a new CResult_WriteableEcdsaChannelSignerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ CResult_WriteableEcdsaChannelSignerDecodeErrorZ_clone(const struct LDKCResult_WriteableEcdsaChannelSignerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CVec_u8ZNoneZ in the success state.
 */
struct LDKCResult_CVec_u8ZNoneZ CResult_CVec_u8ZNoneZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZNoneZ in the error state.
 */
struct LDKCResult_CVec_u8ZNoneZ CResult_CVec_u8ZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_u8ZNoneZ_is_ok(const struct LDKCResult_CVec_u8ZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_u8ZNoneZ.
 */
void CResult_CVec_u8ZNoneZ_free(struct LDKCResult_CVec_u8ZNoneZ _res);

/**
 * Creates a new CResult_CVec_u8ZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZNoneZ CResult_CVec_u8ZNoneZ_clone(const struct LDKCResult_CVec_u8ZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptNoneZ in the success state.
 */
struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptNoneZ in the error state.
 */
struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptNoneZ_is_ok(const struct LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptNoneZ.
 */
void CResult_ShutdownScriptNoneZ_free(struct LDKCResult_ShutdownScriptNoneZ _res);

/**
 * Creates a new CResult_ShutdownScriptNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptNoneZ CResult_ShutdownScriptNoneZ_clone(const struct LDKCResult_ShutdownScriptNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_u16Z containing a u16
 */
struct LDKCOption_u16Z COption_u16Z_some(uint16_t o);

/**
 * Constructs a new COption_u16Z containing nothing
 */
struct LDKCOption_u16Z COption_u16Z_none(void);

/**
 * Frees any resources associated with the u16, if we are in the Some state
 */
void COption_u16Z_free(struct LDKCOption_u16Z _res);

/**
 * Creates a new COption_u16Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_u16Z COption_u16Z_clone(const struct LDKCOption_u16Z *NONNULL_PTR orig);

/**
 * Constructs a new COption_boolZ containing a bool
 */
struct LDKCOption_boolZ COption_boolZ_some(bool o);

/**
 * Constructs a new COption_boolZ containing nothing
 */
struct LDKCOption_boolZ COption_boolZ_none(void);

/**
 * Frees any resources associated with the bool, if we are in the Some state
 */
void COption_boolZ_free(struct LDKCOption_boolZ _res);

/**
 * Creates a new COption_boolZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_boolZ COption_boolZ_clone(const struct LDKCOption_boolZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CVec_u8ZZ_free(struct LDKCVec_CVec_u8ZZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the success state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_ok(struct LDKCVec_CVec_u8ZZ o);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ in the error state.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_CVec_u8ZZNoneZ_is_ok(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_CVec_u8ZZNoneZ.
 */
void CResult_CVec_CVec_u8ZZNoneZ_free(struct LDKCResult_CVec_CVec_u8ZZNoneZ _res);

/**
 * Creates a new CResult_CVec_CVec_u8ZZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_CVec_u8ZZNoneZ CResult_CVec_CVec_u8ZZNoneZ_clone(const struct LDKCResult_CVec_CVec_u8ZZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the success state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_ok(struct LDKInMemorySigner o);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ in the error state.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InMemorySignerDecodeErrorZ_is_ok(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InMemorySignerDecodeErrorZ.
 */
void CResult_InMemorySignerDecodeErrorZ_free(struct LDKCResult_InMemorySignerDecodeErrorZ _res);

/**
 * Creates a new CResult_InMemorySignerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InMemorySignerDecodeErrorZ CResult_InMemorySignerDecodeErrorZ_clone(const struct LDKCResult_InMemorySignerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TransactionNoneZ in the success state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_ok(struct LDKTransaction o);

/**
 * Creates a new CResult_TransactionNoneZ in the error state.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TransactionNoneZ_is_ok(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TransactionNoneZ.
 */
void CResult_TransactionNoneZ_free(struct LDKCResult_TransactionNoneZ _res);

/**
 * Creates a new CResult_TransactionNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionNoneZ CResult_TransactionNoneZ_clone(const struct LDKCResult_TransactionNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_WriteableScoreZ containing a crate::lightning::routing::scoring::WriteableScore
 */
struct LDKCOption_WriteableScoreZ COption_WriteableScoreZ_some(struct LDKWriteableScore o);

/**
 * Constructs a new COption_WriteableScoreZ containing nothing
 */
struct LDKCOption_WriteableScoreZ COption_WriteableScoreZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::scoring::WriteableScore, if we are in the Some state
 */
void COption_WriteableScoreZ_free(struct LDKCOption_WriteableScoreZ _res);

/**
 * Creates a new CResult_NoneIOErrorZ in the success state.
 */
struct LDKCResult_NoneIOErrorZ CResult_NoneIOErrorZ_ok(void);

/**
 * Creates a new CResult_NoneIOErrorZ in the error state.
 */
struct LDKCResult_NoneIOErrorZ CResult_NoneIOErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneIOErrorZ_is_ok(const struct LDKCResult_NoneIOErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneIOErrorZ.
 */
void CResult_NoneIOErrorZ_free(struct LDKCResult_NoneIOErrorZ _res);

/**
 * Creates a new CResult_NoneIOErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneIOErrorZ CResult_NoneIOErrorZ_clone(const struct LDKCResult_NoneIOErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelDetailsZ_free(struct LDKCVec_ChannelDetailsZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ in the success state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteLightningErrorZ in the error state.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteLightningErrorZ_is_ok(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteLightningErrorZ.
 */
void CResult_RouteLightningErrorZ_free(struct LDKCResult_RouteLightningErrorZ _res);

/**
 * Creates a new CResult_RouteLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteLightningErrorZ CResult_RouteLightningErrorZ_clone(const struct LDKCResult_RouteLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ in the success state.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_ok(struct LDKInFlightHtlcs o);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ in the error state.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InFlightHtlcsDecodeErrorZ_is_ok(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InFlightHtlcsDecodeErrorZ.
 */
void CResult_InFlightHtlcsDecodeErrorZ_free(struct LDKCResult_InFlightHtlcsDecodeErrorZ _res);

/**
 * Creates a new CResult_InFlightHtlcsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ CResult_InFlightHtlcsDecodeErrorZ_clone(const struct LDKCResult_InFlightHtlcsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_ok(struct LDKRouteHop o);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHopDecodeErrorZ.
 */
void CResult_RouteHopDecodeErrorZ_free(struct LDKCResult_RouteHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHopDecodeErrorZ CResult_RouteHopDecodeErrorZ_clone(const struct LDKCResult_RouteHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_BlindedHopZ_free(struct LDKCVec_BlindedHopZ _res);

/**
 * Creates a new CResult_BlindedTailDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_ok(struct LDKBlindedTail o);

/**
 * Creates a new CResult_BlindedTailDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedTailDecodeErrorZ_is_ok(const struct LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedTailDecodeErrorZ.
 */
void CResult_BlindedTailDecodeErrorZ_free(struct LDKCResult_BlindedTailDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedTailDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedTailDecodeErrorZ CResult_BlindedTailDecodeErrorZ_clone(const struct LDKCResult_BlindedTailDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHopZ_free(struct LDKCVec_RouteHopZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PathZ_free(struct LDKCVec_PathZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_ok(struct LDKRoute o);

/**
 * Creates a new CResult_RouteDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteDecodeErrorZ_is_ok(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteDecodeErrorZ.
 */
void CResult_RouteDecodeErrorZ_free(struct LDKCResult_RouteDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteDecodeErrorZ CResult_RouteDecodeErrorZ_clone(const struct LDKCResult_RouteDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_ok(struct LDKRouteParameters o);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteParametersDecodeErrorZ_is_ok(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteParametersDecodeErrorZ.
 */
void CResult_RouteParametersDecodeErrorZ_free(struct LDKCResult_RouteParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteParametersDecodeErrorZ CResult_RouteParametersDecodeErrorZ_clone(const struct LDKCResult_RouteParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_u64Z_free(struct LDKCVec_u64Z _res);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_ok(struct LDKPaymentParameters o);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentParametersDecodeErrorZ_is_ok(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentParametersDecodeErrorZ.
 */
void CResult_PaymentParametersDecodeErrorZ_free(struct LDKCResult_PaymentParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentParametersDecodeErrorZ CResult_PaymentParametersDecodeErrorZ_clone(const struct LDKCResult_PaymentParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_BlindedPayInfoBlindedPathZ C2Tuple_BlindedPayInfoBlindedPathZ_clone(const struct LDKC2Tuple_BlindedPayInfoBlindedPathZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_BlindedPayInfoBlindedPathZ from the contained elements.
 */
struct LDKC2Tuple_BlindedPayInfoBlindedPathZ C2Tuple_BlindedPayInfoBlindedPathZ_new(struct LDKBlindedPayInfo a, struct LDKBlindedPath b);

/**
 * Frees any resources used by the C2Tuple_BlindedPayInfoBlindedPathZ.
 */
void C2Tuple_BlindedPayInfoBlindedPathZ_free(struct LDKC2Tuple_BlindedPayInfoBlindedPathZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_BlindedPayInfoBlindedPathZZ_free(struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintZ_free(struct LDKCVec_RouteHintZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RouteHintHopZ_free(struct LDKCVec_RouteHintHopZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_ok(struct LDKRouteHint o);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintDecodeErrorZ.
 */
void CResult_RouteHintDecodeErrorZ_free(struct LDKCResult_RouteHintDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintDecodeErrorZ CResult_RouteHintDecodeErrorZ_clone(const struct LDKCResult_RouteHintDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the success state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_ok(struct LDKRouteHintHop o);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ in the error state.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RouteHintHopDecodeErrorZ_is_ok(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RouteHintHopDecodeErrorZ.
 */
void CResult_RouteHintHopDecodeErrorZ_free(struct LDKCResult_RouteHintHopDecodeErrorZ _res);

/**
 * Creates a new CResult_RouteHintHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RouteHintHopDecodeErrorZ CResult_RouteHintHopDecodeErrorZ_clone(const struct LDKCResult_RouteHintHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PublicKeyZ_free(struct LDKCVec_PublicKeyZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_ok(struct LDKFixedPenaltyScorer o);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FixedPenaltyScorerDecodeErrorZ_is_ok(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FixedPenaltyScorerDecodeErrorZ.
 */
void CResult_FixedPenaltyScorerDecodeErrorZ_free(struct LDKCResult_FixedPenaltyScorerDecodeErrorZ _res);

/**
 * Creates a new CResult_FixedPenaltyScorerDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ CResult_FixedPenaltyScorerDecodeErrorZ_clone(const struct LDKCResult_FixedPenaltyScorerDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_NodeIdZ_free(struct LDKCVec_NodeIdZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_clone(const struct LDKC2Tuple_u64u64Z *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u64u64Z from the contained elements.
 */
struct LDKC2Tuple_u64u64Z C2Tuple_u64u64Z_new(uint64_t a, uint64_t b);

/**
 * Frees any resources used by the C2Tuple_u64u64Z.
 */
void C2Tuple_u64u64Z_free(struct LDKC2Tuple_u64u64Z _res);

/**
 * Constructs a new COption_C2Tuple_u64u64ZZ containing a crate::c_types::derived::C2Tuple_u64u64Z
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_some(struct LDKC2Tuple_u64u64Z o);

/**
 * Constructs a new COption_C2Tuple_u64u64ZZ containing nothing
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u64Z, if we are in the Some state
 */
void COption_C2Tuple_u64u64ZZ_free(struct LDKCOption_C2Tuple_u64u64ZZ _res);

/**
 * Creates a new COption_C2Tuple_u64u64ZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C2Tuple_u64u64ZZ COption_C2Tuple_u64u64ZZ_clone(const struct LDKCOption_C2Tuple_u64u64ZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_Z from the contained elements.
 */
struct LDKC2Tuple_Z C2Tuple_Z_new(struct LDKThirtyTwoU16s a, struct LDKThirtyTwoU16s b);

/**
 * Frees any resources used by the C2Tuple_Z.
 */
void C2Tuple_Z_free(struct LDKC2Tuple_Z _res);

/**
 * Creates a new C2Tuple__u1632_u1632Z from the contained elements.
 */
struct LDKC2Tuple__u1632_u1632Z C2Tuple__u1632_u1632Z_new(struct LDKThirtyTwoU16s a, struct LDKThirtyTwoU16s b);

/**
 * Frees any resources used by the C2Tuple__u1632_u1632Z.
 */
void C2Tuple__u1632_u1632Z_free(struct LDKC2Tuple__u1632_u1632Z _res);

/**
 * Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing a crate::c_types::derived::C2Tuple__u1632_u1632Z
 */
struct LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_some(struct LDKC2Tuple__u1632_u1632Z o);

/**
 * Constructs a new COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ containing nothing
 */
struct LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple__u1632_u1632Z, if we are in the Some state
 */
void COption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ_free(struct LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ _res);

/**
 * Constructs a new COption_f64Z containing a f64
 */
struct LDKCOption_f64Z COption_f64Z_some(double o);

/**
 * Constructs a new COption_f64Z containing nothing
 */
struct LDKCOption_f64Z COption_f64Z_none(void);

/**
 * Frees any resources associated with the f64, if we are in the Some state
 */
void COption_f64Z_free(struct LDKCOption_f64Z _res);

/**
 * Creates a new COption_f64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_f64Z COption_f64Z_clone(const struct LDKCOption_f64Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the success state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_ok(struct LDKProbabilisticScorer o);

/**
 * Creates a new CResult_ProbabilisticScorerDecodeErrorZ in the error state.
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ CResult_ProbabilisticScorerDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ProbabilisticScorerDecodeErrorZ_is_ok(const struct LDKCResult_ProbabilisticScorerDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ProbabilisticScorerDecodeErrorZ.
 */
void CResult_ProbabilisticScorerDecodeErrorZ_free(struct LDKCResult_ProbabilisticScorerDecodeErrorZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_clone(const struct LDKC2Tuple_usizeTransactionZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_usizeTransactionZ from the contained elements.
 */
struct LDKC2Tuple_usizeTransactionZ C2Tuple_usizeTransactionZ_new(uintptr_t a, struct LDKTransaction b);

/**
 * Frees any resources used by the C2Tuple_usizeTransactionZ.
 */
void C2Tuple_usizeTransactionZ_free(struct LDKC2Tuple_usizeTransactionZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_usizeTransactionZZ_free(struct LDKCVec_C2Tuple_usizeTransactionZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ_new(struct LDKThirtyTwoBytes a, struct LDKCOption_ThirtyTwoBytesZ b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ.
 */
void C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ_free(struct LDKC2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ_free(struct LDKCVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the success state.
 */
struct LDKCResult_ChannelMonitorUpdateStatusNoneZ CResult_ChannelMonitorUpdateStatusNoneZ_ok(enum LDKChannelMonitorUpdateStatus o);

/**
 * Creates a new CResult_ChannelMonitorUpdateStatusNoneZ in the error state.
 */
struct LDKCResult_ChannelMonitorUpdateStatusNoneZ CResult_ChannelMonitorUpdateStatusNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelMonitorUpdateStatusNoneZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateStatusNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelMonitorUpdateStatusNoneZ.
 */
void CResult_ChannelMonitorUpdateStatusNoneZ_free(struct LDKCResult_ChannelMonitorUpdateStatusNoneZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateStatusNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelMonitorUpdateStatusNoneZ CResult_ChannelMonitorUpdateStatusNoneZ_clone(const struct LDKCResult_ChannelMonitorUpdateStatusNoneZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorEventZ_free(struct LDKCVec_MonitorEventZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_clone(const struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ from the contained elements.
 */
struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorEventZ b, struct LDKPublicKey c);

/**
 * Frees any resources used by the C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ.
 */
void C3Tuple_OutPointCVec_MonitorEventZPublicKeyZ_free(struct LDKC3Tuple_OutPointCVec_MonitorEventZPublicKeyZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ_free(struct LDKCVec_C3Tuple_OutPointCVec_MonitorEventZPublicKeyZZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_ok(struct LDKInitFeatures o);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitFeaturesDecodeErrorZ.
 */
void CResult_InitFeaturesDecodeErrorZ_free(struct LDKCResult_InitFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_InitFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitFeaturesDecodeErrorZ CResult_InitFeaturesDecodeErrorZ_clone(const struct LDKCResult_InitFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_ok(struct LDKChannelFeatures o);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelFeaturesDecodeErrorZ.
 */
void CResult_ChannelFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ CResult_ChannelFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_ok(struct LDKNodeFeatures o);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeFeaturesDecodeErrorZ.
 */
void CResult_NodeFeaturesDecodeErrorZ_free(struct LDKCResult_NodeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ CResult_NodeFeaturesDecodeErrorZ_clone(const struct LDKCResult_NodeFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_ok(struct LDKBolt11InvoiceFeatures o);

/**
 * Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_Bolt11InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_Bolt11InvoiceFeaturesDecodeErrorZ.
 */
void CResult_Bolt11InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_Bolt11InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ CResult_Bolt11InvoiceFeaturesDecodeErrorZ_clone(const struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_ok(struct LDKBolt12InvoiceFeatures o);

/**
 * Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_Bolt12InvoiceFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_Bolt12InvoiceFeaturesDecodeErrorZ.
 */
void CResult_Bolt12InvoiceFeaturesDecodeErrorZ_free(struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_Bolt12InvoiceFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ CResult_Bolt12InvoiceFeaturesDecodeErrorZ_clone(const struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_ok(struct LDKBlindedHopFeatures o);

/**
 * Creates a new CResult_BlindedHopFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedHopFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedHopFeaturesDecodeErrorZ.
 */
void CResult_BlindedHopFeaturesDecodeErrorZ_free(struct LDKCResult_BlindedHopFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedHopFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedHopFeaturesDecodeErrorZ CResult_BlindedHopFeaturesDecodeErrorZ_clone(const struct LDKCResult_BlindedHopFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_ok(struct LDKChannelTypeFeatures o);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTypeFeaturesDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTypeFeaturesDecodeErrorZ.
 */
void CResult_ChannelTypeFeaturesDecodeErrorZ_free(struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTypeFeaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ CResult_ChannelTypeFeaturesDecodeErrorZ_clone(const struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OfferBolt12ParseErrorZ in the success state.
 */
struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_ok(struct LDKOffer o);

/**
 * Creates a new CResult_OfferBolt12ParseErrorZ in the error state.
 */
struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_err(struct LDKBolt12ParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OfferBolt12ParseErrorZ_is_ok(const struct LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OfferBolt12ParseErrorZ.
 */
void CResult_OfferBolt12ParseErrorZ_free(struct LDKCResult_OfferBolt12ParseErrorZ _res);

/**
 * Creates a new CResult_OfferBolt12ParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OfferBolt12ParseErrorZ CResult_OfferBolt12ParseErrorZ_clone(const struct LDKCResult_OfferBolt12ParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PublicKeySecp256k1ErrorZ in the success state.
 */
struct LDKCResult_PublicKeySecp256k1ErrorZ CResult_PublicKeySecp256k1ErrorZ_ok(struct LDKPublicKey o);

/**
 * Creates a new CResult_PublicKeySecp256k1ErrorZ in the error state.
 */
struct LDKCResult_PublicKeySecp256k1ErrorZ CResult_PublicKeySecp256k1ErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PublicKeySecp256k1ErrorZ_is_ok(const struct LDKCResult_PublicKeySecp256k1ErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PublicKeySecp256k1ErrorZ.
 */
void CResult_PublicKeySecp256k1ErrorZ_free(struct LDKCResult_PublicKeySecp256k1ErrorZ _res);

/**
 * Creates a new CResult_PublicKeySecp256k1ErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PublicKeySecp256k1ErrorZ CResult_PublicKeySecp256k1ErrorZ_clone(const struct LDKCResult_PublicKeySecp256k1ErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_ok(struct LDKNodeId o);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeIdDecodeErrorZ_is_ok(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeIdDecodeErrorZ.
 */
void CResult_NodeIdDecodeErrorZ_free(struct LDKCResult_NodeIdDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeIdDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeIdDecodeErrorZ CResult_NodeIdDecodeErrorZ_clone(const struct LDKCResult_NodeIdDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NetworkUpdateZ containing a crate::lightning::routing::gossip::NetworkUpdate
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_some(struct LDKNetworkUpdate o);

/**
 * Constructs a new COption_NetworkUpdateZ containing nothing
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::gossip::NetworkUpdate, if we are in the Some state
 */
void COption_NetworkUpdateZ_free(struct LDKCOption_NetworkUpdateZ _res);

/**
 * Creates a new COption_NetworkUpdateZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_NetworkUpdateZ COption_NetworkUpdateZ_clone(const struct LDKCOption_NetworkUpdateZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_ok(struct LDKCOption_NetworkUpdateZ o);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_NetworkUpdateZDecodeErrorZ_is_ok(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_NetworkUpdateZDecodeErrorZ.
 */
void CResult_COption_NetworkUpdateZDecodeErrorZ_free(struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_NetworkUpdateZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ CResult_COption_NetworkUpdateZDecodeErrorZ_clone(const struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_UtxoLookupZ containing a crate::lightning::routing::utxo::UtxoLookup
 */
struct LDKCOption_UtxoLookupZ COption_UtxoLookupZ_some(struct LDKUtxoLookup o);

/**
 * Constructs a new COption_UtxoLookupZ containing nothing
 */
struct LDKCOption_UtxoLookupZ COption_UtxoLookupZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::routing::utxo::UtxoLookup, if we are in the Some state
 */
void COption_UtxoLookupZ_free(struct LDKCOption_UtxoLookupZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ in the success state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_ok(void);

/**
 * Creates a new CResult_NoneLightningErrorZ in the error state.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneLightningErrorZ_is_ok(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneLightningErrorZ.
 */
void CResult_NoneLightningErrorZ_free(struct LDKCResult_NoneLightningErrorZ _res);

/**
 * Creates a new CResult_NoneLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneLightningErrorZ CResult_NoneLightningErrorZ_clone(const struct LDKCResult_NoneLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_boolLightningErrorZ in the success state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolLightningErrorZ in the error state.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_err(struct LDKLightningError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolLightningErrorZ_is_ok(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolLightningErrorZ.
 */
void CResult_boolLightningErrorZ_free(struct LDKCResult_boolLightningErrorZ _res);

/**
 * Creates a new CResult_boolLightningErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolLightningErrorZ CResult_boolLightningErrorZ_clone(const struct LDKCResult_boolLightningErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_clone(const struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ from the contained elements.
 */
struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_new(struct LDKChannelAnnouncement a, struct LDKChannelUpdate b, struct LDKChannelUpdate c);

/**
 * Frees any resources used by the C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ.
 */
void C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ_free(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ _res);

/**
 * Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing a crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_some(struct LDKC3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ o);

/**
 * Constructs a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ containing nothing
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZ, if we are in the Some state
 */
void COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_free(struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ _res);

/**
 * Creates a new COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ COption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ_clone(const struct LDKCOption_C3Tuple_ChannelAnnouncementChannelUpdateChannelUpdateZZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MessageSendEventZ_free(struct LDKCVec_MessageSendEventZ _res);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_ok(struct LDKChannelUpdateInfo o);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateInfoDecodeErrorZ.
 */
void CResult_ChannelUpdateInfoDecodeErrorZ_free(struct LDKCResult_ChannelUpdateInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ CResult_ChannelUpdateInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_ok(struct LDKChannelInfo o);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelInfoDecodeErrorZ_is_ok(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelInfoDecodeErrorZ.
 */
void CResult_ChannelInfoDecodeErrorZ_free(struct LDKCResult_ChannelInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelInfoDecodeErrorZ CResult_ChannelInfoDecodeErrorZ_clone(const struct LDKCResult_ChannelInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the success state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_ok(struct LDKRoutingFees o);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ in the error state.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RoutingFeesDecodeErrorZ_is_ok(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RoutingFeesDecodeErrorZ.
 */
void CResult_RoutingFeesDecodeErrorZ_free(struct LDKCResult_RoutingFeesDecodeErrorZ _res);

/**
 * Creates a new CResult_RoutingFeesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RoutingFeesDecodeErrorZ CResult_RoutingFeesDecodeErrorZ_clone(const struct LDKCResult_RoutingFeesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_SocketAddressZ_free(struct LDKCVec_SocketAddressZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_ok(struct LDKNodeAnnouncementInfo o);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementInfoDecodeErrorZ.
 */
void CResult_NodeAnnouncementInfoDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ CResult_NodeAnnouncementInfoDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_ok(struct LDKNodeAlias o);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAliasDecodeErrorZ_is_ok(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAliasDecodeErrorZ.
 */
void CResult_NodeAliasDecodeErrorZ_free(struct LDKCResult_NodeAliasDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAliasDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAliasDecodeErrorZ CResult_NodeAliasDecodeErrorZ_clone(const struct LDKCResult_NodeAliasDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_ok(struct LDKNodeInfo o);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeInfoDecodeErrorZ_is_ok(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeInfoDecodeErrorZ.
 */
void CResult_NodeInfoDecodeErrorZ_free(struct LDKCResult_NodeInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeInfoDecodeErrorZ CResult_NodeInfoDecodeErrorZ_clone(const struct LDKCResult_NodeInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the success state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_ok(struct LDKNetworkGraph o);

/**
 * Creates a new CResult_NetworkGraphDecodeErrorZ in the error state.
 */
struct LDKCResult_NetworkGraphDecodeErrorZ CResult_NetworkGraphDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NetworkGraphDecodeErrorZ_is_ok(const struct LDKCResult_NetworkGraphDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NetworkGraphDecodeErrorZ.
 */
void CResult_NetworkGraphDecodeErrorZ_free(struct LDKCResult_NetworkGraphDecodeErrorZ _res);

/**
 * Constructs a new COption_CVec_SocketAddressZZ containing a crate::c_types::derived::CVec_SocketAddressZ
 */
struct LDKCOption_CVec_SocketAddressZZ COption_CVec_SocketAddressZZ_some(struct LDKCVec_SocketAddressZ o);

/**
 * Constructs a new COption_CVec_SocketAddressZZ containing nothing
 */
struct LDKCOption_CVec_SocketAddressZZ COption_CVec_SocketAddressZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::CVec_SocketAddressZ, if we are in the Some state
 */
void COption_CVec_SocketAddressZZ_free(struct LDKCOption_CVec_SocketAddressZZ _res);

/**
 * Creates a new COption_CVec_SocketAddressZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CVec_SocketAddressZZ COption_CVec_SocketAddressZZ_clone(const struct LDKCOption_CVec_SocketAddressZZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelDerivationParametersDecodeErrorZ CResult_ChannelDerivationParametersDecodeErrorZ_ok(struct LDKChannelDerivationParameters o);

/**
 * Creates a new CResult_ChannelDerivationParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelDerivationParametersDecodeErrorZ CResult_ChannelDerivationParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelDerivationParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDerivationParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelDerivationParametersDecodeErrorZ.
 */
void CResult_ChannelDerivationParametersDecodeErrorZ_free(struct LDKCResult_ChannelDerivationParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelDerivationParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelDerivationParametersDecodeErrorZ CResult_ChannelDerivationParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelDerivationParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCDescriptorDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCDescriptorDecodeErrorZ CResult_HTLCDescriptorDecodeErrorZ_ok(struct LDKHTLCDescriptor o);

/**
 * Creates a new CResult_HTLCDescriptorDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCDescriptorDecodeErrorZ CResult_HTLCDescriptorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCDescriptorDecodeErrorZ_is_ok(const struct LDKCResult_HTLCDescriptorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCDescriptorDecodeErrorZ.
 */
void CResult_HTLCDescriptorDecodeErrorZ_free(struct LDKCResult_HTLCDescriptorDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCDescriptorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCDescriptorDecodeErrorZ CResult_HTLCDescriptorDecodeErrorZ_clone(const struct LDKCResult_HTLCDescriptorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_HTLCOutputInCommitmentZ_free(struct LDKCVec_HTLCOutputInCommitmentZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_HTLCDescriptorZ_free(struct LDKCVec_HTLCDescriptorZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UtxoZ_free(struct LDKCVec_UtxoZ _res);

/**
 * Constructs a new COption_TxOutZ containing a crate::c_types::TxOut
 */
struct LDKCOption_TxOutZ COption_TxOutZ_some(struct LDKTxOut o);

/**
 * Constructs a new COption_TxOutZ containing nothing
 */
struct LDKCOption_TxOutZ COption_TxOutZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::TxOut, if we are in the Some state
 */
void COption_TxOutZ_free(struct LDKCOption_TxOutZ _res);

/**
 * Creates a new COption_TxOutZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_TxOutZ COption_TxOutZ_clone(const struct LDKCOption_TxOutZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_InputZ_free(struct LDKCVec_InputZ _res);

/**
 * Creates a new CResult_CoinSelectionNoneZ in the success state.
 */
struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_ok(struct LDKCoinSelection o);

/**
 * Creates a new CResult_CoinSelectionNoneZ in the error state.
 */
struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CoinSelectionNoneZ_is_ok(const struct LDKCResult_CoinSelectionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CoinSelectionNoneZ.
 */
void CResult_CoinSelectionNoneZ_free(struct LDKCResult_CoinSelectionNoneZ _res);

/**
 * Creates a new CResult_CoinSelectionNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CoinSelectionNoneZ CResult_CoinSelectionNoneZ_clone(const struct LDKCResult_CoinSelectionNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CVec_UtxoZNoneZ in the success state.
 */
struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_ok(struct LDKCVec_UtxoZ o);

/**
 * Creates a new CResult_CVec_UtxoZNoneZ in the error state.
 */
struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_UtxoZNoneZ_is_ok(const struct LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_UtxoZNoneZ.
 */
void CResult_CVec_UtxoZNoneZ_free(struct LDKCResult_CVec_UtxoZNoneZ _res);

/**
 * Creates a new CResult_CVec_UtxoZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_UtxoZNoneZ CResult_CVec_UtxoZNoneZ_clone(const struct LDKCResult_CVec_UtxoZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u64u16Z C2Tuple_u64u16Z_clone(const struct LDKC2Tuple_u64u16Z *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u64u16Z from the contained elements.
 */
struct LDKC2Tuple_u64u16Z C2Tuple_u64u16Z_new(uint64_t a, uint16_t b);

/**
 * Frees any resources used by the C2Tuple_u64u16Z.
 */
void C2Tuple_u64u16Z_free(struct LDKC2Tuple_u64u16Z _res);

/**
 * Constructs a new COption_C2Tuple_u64u16ZZ containing a crate::c_types::derived::C2Tuple_u64u16Z
 */
struct LDKCOption_C2Tuple_u64u16ZZ COption_C2Tuple_u64u16ZZ_some(struct LDKC2Tuple_u64u16Z o);

/**
 * Constructs a new COption_C2Tuple_u64u16ZZ containing nothing
 */
struct LDKCOption_C2Tuple_u64u16ZZ COption_C2Tuple_u64u16ZZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::derived::C2Tuple_u64u16Z, if we are in the Some state
 */
void COption_C2Tuple_u64u16ZZ_free(struct LDKCOption_C2Tuple_u64u16ZZ _res);

/**
 * Creates a new COption_C2Tuple_u64u16ZZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_C2Tuple_u64u16ZZ COption_C2Tuple_u64u16ZZ_clone(const struct LDKCOption_C2Tuple_u64u16ZZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_ChannelShutdownStateZ containing a crate::lightning::ln::channelmanager::ChannelShutdownState
 */
struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_some(enum LDKChannelShutdownState o);

/**
 * Constructs a new COption_ChannelShutdownStateZ containing nothing
 */
struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::channelmanager::ChannelShutdownState, if we are in the Some state
 */
void COption_ChannelShutdownStateZ_free(struct LDKCOption_ChannelShutdownStateZ _res);

/**
 * Creates a new COption_ChannelShutdownStateZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_ChannelShutdownStateZ COption_ChannelShutdownStateZ_clone(const struct LDKCOption_ChannelShutdownStateZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the success state.
 */
struct LDKCResult_ThirtyTwoBytesAPIErrorZ CResult_ThirtyTwoBytesAPIErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_ThirtyTwoBytesAPIErrorZ in the error state.
 */
struct LDKCResult_ThirtyTwoBytesAPIErrorZ CResult_ThirtyTwoBytesAPIErrorZ_err(struct LDKAPIError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ThirtyTwoBytesAPIErrorZ_is_ok(const struct LDKCResult_ThirtyTwoBytesAPIErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ThirtyTwoBytesAPIErrorZ.
 */
void CResult_ThirtyTwoBytesAPIErrorZ_free(struct LDKCResult_ThirtyTwoBytesAPIErrorZ _res);

/**
 * Creates a new CResult_ThirtyTwoBytesAPIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ThirtyTwoBytesAPIErrorZ CResult_ThirtyTwoBytesAPIErrorZ_clone(const struct LDKCResult_ThirtyTwoBytesAPIErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_RecentPaymentDetailsZ_free(struct LDKCVec_RecentPaymentDetailsZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the success state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_ok(void);

/**
 * Creates a new CResult_NonePaymentSendFailureZ in the error state.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePaymentSendFailureZ_is_ok(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePaymentSendFailureZ.
 */
void CResult_NonePaymentSendFailureZ_free(struct LDKCResult_NonePaymentSendFailureZ _res);

/**
 * Creates a new CResult_NonePaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentSendFailureZ CResult_NonePaymentSendFailureZ_clone(const struct LDKCResult_NonePaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneRetryableSendFailureZ in the success state.
 */
struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_ok(void);

/**
 * Creates a new CResult_NoneRetryableSendFailureZ in the error state.
 */
struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_err(enum LDKRetryableSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneRetryableSendFailureZ_is_ok(const struct LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneRetryableSendFailureZ.
 */
void CResult_NoneRetryableSendFailureZ_free(struct LDKCResult_NoneRetryableSendFailureZ _res);

/**
 * Creates a new CResult_NoneRetryableSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneRetryableSendFailureZ CResult_NoneRetryableSendFailureZ_clone(const struct LDKCResult_NoneRetryableSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ in the success state.
 */
struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ CResult_ThirtyTwoBytesPaymentSendFailureZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ in the error state.
 */
struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ CResult_ThirtyTwoBytesPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ThirtyTwoBytesPaymentSendFailureZ_is_ok(const struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ThirtyTwoBytesPaymentSendFailureZ.
 */
void CResult_ThirtyTwoBytesPaymentSendFailureZ_free(struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ _res);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ CResult_ThirtyTwoBytesPaymentSendFailureZ_clone(const struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the success state.
 */
struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ CResult_ThirtyTwoBytesRetryableSendFailureZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ in the error state.
 */
struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ CResult_ThirtyTwoBytesRetryableSendFailureZ_err(enum LDKRetryableSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ThirtyTwoBytesRetryableSendFailureZ_is_ok(const struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ThirtyTwoBytesRetryableSendFailureZ.
 */
void CResult_ThirtyTwoBytesRetryableSendFailureZ_free(struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ _res);

/**
 * Creates a new CResult_ThirtyTwoBytesRetryableSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ CResult_ThirtyTwoBytesRetryableSendFailureZ_clone(const struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_new(struct LDKThirtyTwoBytes a, struct LDKThirtyTwoBytes b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ.
 */
void C2Tuple_ThirtyTwoBytesThirtyTwoBytesZ_free(struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ in the success state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_ok(struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ o);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ in the error state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_err(struct LDKPaymentSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_is_ok(const struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ.
 */
void CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_free(struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ_clone(const struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ_free(struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_ok(struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_err(struct LDKProbeSendFailure e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_is_ok(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ.
 */
void CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_free(struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ_clone(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ C2Tuple_ThirtyTwoBytesPublicKeyZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesPublicKeyZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ C2Tuple_ThirtyTwoBytesPublicKeyZ_new(struct LDKThirtyTwoBytes a, struct LDKPublicKey b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesPublicKeyZ.
 */
void C2Tuple_ThirtyTwoBytesPublicKeyZ_free(struct LDKC2Tuple_ThirtyTwoBytesPublicKeyZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ_free(struct LDKCVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_ok(struct LDKC2Tuple_ThirtyTwoBytesThirtyTwoBytesZ o);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_is_ok(const struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ.
 */
void CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_free(struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ CResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ_clone(const struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_ok(struct LDKCounterpartyForwardingInfo o);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyForwardingInfoDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyForwardingInfoDecodeErrorZ.
 */
void CResult_CounterpartyForwardingInfoDecodeErrorZ_free(struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyForwardingInfoDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CResult_CounterpartyForwardingInfoDecodeErrorZ_clone(const struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_ok(struct LDKChannelCounterparty o);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelCounterpartyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelCounterpartyDecodeErrorZ.
 */
void CResult_ChannelCounterpartyDecodeErrorZ_free(struct LDKCResult_ChannelCounterpartyDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelCounterpartyDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ CResult_ChannelCounterpartyDecodeErrorZ_clone(const struct LDKCResult_ChannelCounterpartyDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_ok(struct LDKChannelDetails o);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelDetailsDecodeErrorZ_is_ok(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelDetailsDecodeErrorZ.
 */
void CResult_ChannelDetailsDecodeErrorZ_free(struct LDKCResult_ChannelDetailsDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelDetailsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ CResult_ChannelDetailsDecodeErrorZ_clone(const struct LDKCResult_ChannelDetailsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the success state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_ok(struct LDKPhantomRouteHints o);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ in the error state.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PhantomRouteHintsDecodeErrorZ_is_ok(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PhantomRouteHintsDecodeErrorZ.
 */
void CResult_PhantomRouteHintsDecodeErrorZ_free(struct LDKCResult_PhantomRouteHintsDecodeErrorZ _res);

/**
 * Creates a new CResult_PhantomRouteHintsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ CResult_PhantomRouteHintsDecodeErrorZ_clone(const struct LDKCResult_PhantomRouteHintsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_ok(enum LDKChannelShutdownState o);

/**
 * Creates a new CResult_ChannelShutdownStateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelShutdownStateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelShutdownStateDecodeErrorZ.
 */
void CResult_ChannelShutdownStateDecodeErrorZ_free(struct LDKCResult_ChannelShutdownStateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelShutdownStateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelShutdownStateDecodeErrorZ CResult_ChannelShutdownStateDecodeErrorZ_clone(const struct LDKCResult_ChannelShutdownStateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ChannelMonitorZ_free(struct LDKCVec_ChannelMonitorZ _res);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesChannelManagerZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesChannelManagerZ C2Tuple_ThirtyTwoBytesChannelManagerZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelManager b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelManagerZ.
 */
void C2Tuple_ThirtyTwoBytesChannelManagerZ_free(struct LDKC2Tuple_ThirtyTwoBytesChannelManagerZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_ok(struct LDKC2Tuple_ThirtyTwoBytesChannelManagerZ o);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ.
 */
void CResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ_free(struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ _res);

/**
 * Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the success state.
 */
struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_ok(struct LDKMaxDustHTLCExposure o);

/**
 * Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ in the error state.
 */
struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_MaxDustHTLCExposureDecodeErrorZ_is_ok(const struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_MaxDustHTLCExposureDecodeErrorZ.
 */
void CResult_MaxDustHTLCExposureDecodeErrorZ_free(struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ _res);

/**
 * Creates a new CResult_MaxDustHTLCExposureDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ CResult_MaxDustHTLCExposureDecodeErrorZ_clone(const struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_ok(struct LDKChannelConfig o);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelConfigDecodeErrorZ_is_ok(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelConfigDecodeErrorZ.
 */
void CResult_ChannelConfigDecodeErrorZ_free(struct LDKCResult_ChannelConfigDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelConfigDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelConfigDecodeErrorZ CResult_ChannelConfigDecodeErrorZ_clone(const struct LDKCResult_ChannelConfigDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_MaxDustHTLCExposureZ containing a crate::lightning::util::config::MaxDustHTLCExposure
 */
struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_some(struct LDKMaxDustHTLCExposure o);

/**
 * Constructs a new COption_MaxDustHTLCExposureZ containing nothing
 */
struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::config::MaxDustHTLCExposure, if we are in the Some state
 */
void COption_MaxDustHTLCExposureZ_free(struct LDKCOption_MaxDustHTLCExposureZ _res);

/**
 * Creates a new COption_MaxDustHTLCExposureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_MaxDustHTLCExposureZ COption_MaxDustHTLCExposureZ_clone(const struct LDKCOption_MaxDustHTLCExposureZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_APIErrorZ containing a crate::lightning::util::errors::APIError
 */
struct LDKCOption_APIErrorZ COption_APIErrorZ_some(struct LDKAPIError o);

/**
 * Constructs a new COption_APIErrorZ containing nothing
 */
struct LDKCOption_APIErrorZ COption_APIErrorZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::util::errors::APIError, if we are in the Some state
 */
void COption_APIErrorZ_free(struct LDKCOption_APIErrorZ _res);

/**
 * Creates a new COption_APIErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_APIErrorZ COption_APIErrorZ_clone(const struct LDKCOption_APIErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_APIErrorZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_ok(struct LDKCOption_APIErrorZ o);

/**
 * Creates a new CResult_COption_APIErrorZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_APIErrorZDecodeErrorZ_is_ok(const struct LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_APIErrorZDecodeErrorZ.
 */
void CResult_COption_APIErrorZDecodeErrorZ_free(struct LDKCResult_COption_APIErrorZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_APIErrorZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_APIErrorZDecodeErrorZ CResult_COption_APIErrorZDecodeErrorZ_clone(const struct LDKCResult_COption_APIErrorZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_ok(struct LDKChannelMonitorUpdate o);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelMonitorUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelMonitorUpdateDecodeErrorZ.
 */
void CResult_ChannelMonitorUpdateDecodeErrorZ_free(struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelMonitorUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ CResult_ChannelMonitorUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_MonitorEventZ containing a crate::lightning::chain::channelmonitor::MonitorEvent
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_some(struct LDKMonitorEvent o);

/**
 * Constructs a new COption_MonitorEventZ containing nothing
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::channelmonitor::MonitorEvent, if we are in the Some state
 */
void COption_MonitorEventZ_free(struct LDKCOption_MonitorEventZ _res);

/**
 * Creates a new COption_MonitorEventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_MonitorEventZ COption_MonitorEventZ_clone(const struct LDKCOption_MonitorEventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_ok(struct LDKCOption_MonitorEventZ o);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_MonitorEventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_MonitorEventZDecodeErrorZ.
 */
void CResult_COption_MonitorEventZDecodeErrorZ_free(struct LDKCResult_COption_MonitorEventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_MonitorEventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ CResult_COption_MonitorEventZDecodeErrorZ_clone(const struct LDKCResult_COption_MonitorEventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_ok(struct LDKHTLCUpdate o);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCUpdateDecodeErrorZ_is_ok(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCUpdateDecodeErrorZ.
 */
void CResult_HTLCUpdateDecodeErrorZ_free(struct LDKCResult_HTLCUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ CResult_HTLCUpdateDecodeErrorZ_clone(const struct LDKCResult_HTLCUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointCVec_u8ZZ C2Tuple_OutPointCVec_u8ZZ_clone(const struct LDKC2Tuple_OutPointCVec_u8ZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointCVec_u8ZZ from the contained elements.
 */
struct LDKC2Tuple_OutPointCVec_u8ZZ C2Tuple_OutPointCVec_u8ZZ_new(struct LDKOutPoint a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_OutPointCVec_u8ZZ.
 */
void C2Tuple_OutPointCVec_u8ZZ_free(struct LDKC2Tuple_OutPointCVec_u8ZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32CVec_u8ZZ C2Tuple_u32CVec_u8ZZ_clone(const struct LDKC2Tuple_u32CVec_u8ZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32CVec_u8ZZ from the contained elements.
 */
struct LDKC2Tuple_u32CVec_u8ZZ C2Tuple_u32CVec_u8ZZ_new(uint32_t a, struct LDKCVec_u8Z b);

/**
 * Frees any resources used by the C2Tuple_u32CVec_u8ZZ.
 */
void C2Tuple_u32CVec_u8ZZ_free(struct LDKC2Tuple_u32CVec_u8ZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32CVec_u8ZZZ_free(struct LDKCVec_C2Tuple_u32CVec_u8ZZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32CVec_u8ZZZ b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ.
 */
void C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ_free(struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ_free(struct LDKCVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_CommitmentTransactionZ_free(struct LDKCVec_CommitmentTransactionZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionZ_free(struct LDKCVec_TransactionZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_clone(const struct LDKC2Tuple_u32TxOutZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_u32TxOutZ from the contained elements.
 */
struct LDKC2Tuple_u32TxOutZ C2Tuple_u32TxOutZ_new(uint32_t a, struct LDKTxOut b);

/**
 * Frees any resources used by the C2Tuple_u32TxOutZ.
 */
void C2Tuple_u32TxOutZ_free(struct LDKC2Tuple_u32TxOutZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_u32TxOutZZ_free(struct LDKCVec_C2Tuple_u32TxOutZZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_new(struct LDKThirtyTwoBytes a, struct LDKCVec_C2Tuple_u32TxOutZZ b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ.
 */
void C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ_free(struct LDKC2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32TxOutZZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_TransactionOutputsZ_free(struct LDKCVec_TransactionOutputsZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_BalanceZ_free(struct LDKCVec_BalanceZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ C2Tuple_ThirtyTwoBytesChannelMonitorZ_clone(const struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_ThirtyTwoBytesChannelMonitorZ from the contained elements.
 */
struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ C2Tuple_ThirtyTwoBytesChannelMonitorZ_new(struct LDKThirtyTwoBytes a, struct LDKChannelMonitor b);

/**
 * Frees any resources used by the C2Tuple_ThirtyTwoBytesChannelMonitorZ.
 */
void C2Tuple_ThirtyTwoBytesChannelMonitorZ_free(struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_ok(struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ o);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_is_ok(const struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ.
 */
void CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_free(struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ_clone(const struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_clone(const struct LDKC2Tuple_PublicKeyTypeZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PublicKeyTypeZ from the contained elements.
 */
struct LDKC2Tuple_PublicKeyTypeZ C2Tuple_PublicKeyTypeZ_new(struct LDKPublicKey a, struct LDKType b);

/**
 * Frees any resources used by the C2Tuple_PublicKeyTypeZ.
 */
void C2Tuple_PublicKeyTypeZ_free(struct LDKC2Tuple_PublicKeyTypeZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_PublicKeyTypeZZ_free(struct LDKCVec_C2Tuple_PublicKeyTypeZZ _res);

/**
 * Constructs a new COption_OffersMessageZ containing a crate::lightning::onion_message::offers::OffersMessage
 */
struct LDKCOption_OffersMessageZ COption_OffersMessageZ_some(struct LDKOffersMessage o);

/**
 * Constructs a new COption_OffersMessageZ containing nothing
 */
struct LDKCOption_OffersMessageZ COption_OffersMessageZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::onion_message::offers::OffersMessage, if we are in the Some state
 */
void COption_OffersMessageZ_free(struct LDKCOption_OffersMessageZ _res);

/**
 * Creates a new COption_OffersMessageZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_OffersMessageZ COption_OffersMessageZ_clone(const struct LDKCOption_OffersMessageZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_CustomOnionMessageContentsZ containing a crate::lightning::onion_message::packet::CustomOnionMessageContents
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_some(struct LDKCustomOnionMessageContents o);

/**
 * Constructs a new COption_CustomOnionMessageContentsZ containing nothing
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::onion_message::packet::CustomOnionMessageContents, if we are in the Some state
 */
void COption_CustomOnionMessageContentsZ_free(struct LDKCOption_CustomOnionMessageContentsZ _res);

/**
 * Creates a new COption_CustomOnionMessageContentsZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_CustomOnionMessageContentsZ COption_CustomOnionMessageContentsZ_clone(const struct LDKCOption_CustomOnionMessageContentsZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_ok(struct LDKCOption_CustomOnionMessageContentsZ o);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_is_ok(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_CustomOnionMessageContentsZDecodeErrorZ.
 */
void CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_free(struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_CustomOnionMessageContentsZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ CResult_COption_CustomOnionMessageContentsZDecodeErrorZ_clone(const struct LDKCResult_COption_CustomOnionMessageContentsZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_TypeZ containing a crate::lightning::ln::wire::Type
 */
struct LDKCOption_TypeZ COption_TypeZ_some(struct LDKType o);

/**
 * Constructs a new COption_TypeZ containing nothing
 */
struct LDKCOption_TypeZ COption_TypeZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::wire::Type, if we are in the Some state
 */
void COption_TypeZ_free(struct LDKCOption_TypeZ _res);

/**
 * Creates a new COption_TypeZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_TypeZ COption_TypeZ_clone(const struct LDKCOption_TypeZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_ok(struct LDKCOption_TypeZ o);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_TypeZDecodeErrorZ_is_ok(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_TypeZDecodeErrorZ.
 */
void CResult_COption_TypeZDecodeErrorZ_free(struct LDKCResult_COption_TypeZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_TypeZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_TypeZDecodeErrorZ CResult_COption_TypeZDecodeErrorZ_clone(const struct LDKCResult_COption_TypeZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_SocketAddressZ containing a crate::lightning::ln::msgs::SocketAddress
 */
struct LDKCOption_SocketAddressZ COption_SocketAddressZ_some(struct LDKSocketAddress o);

/**
 * Constructs a new COption_SocketAddressZ containing nothing
 */
struct LDKCOption_SocketAddressZ COption_SocketAddressZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::msgs::SocketAddress, if we are in the Some state
 */
void COption_SocketAddressZ_free(struct LDKCOption_SocketAddressZ _res);

/**
 * Creates a new COption_SocketAddressZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_SocketAddressZ COption_SocketAddressZ_clone(const struct LDKCOption_SocketAddressZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ C2Tuple_PublicKeyCOption_SocketAddressZZ_clone(const struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PublicKeyCOption_SocketAddressZZ from the contained elements.
 */
struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ C2Tuple_PublicKeyCOption_SocketAddressZZ_new(struct LDKPublicKey a, struct LDKCOption_SocketAddressZ b);

/**
 * Frees any resources used by the C2Tuple_PublicKeyCOption_SocketAddressZZ.
 */
void C2Tuple_PublicKeyCOption_SocketAddressZZ_free(struct LDKC2Tuple_PublicKeyCOption_SocketAddressZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ_free(struct LDKCVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the success state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ in the error state.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_u8ZPeerHandleErrorZ_is_ok(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_u8ZPeerHandleErrorZ.
 */
void CResult_CVec_u8ZPeerHandleErrorZ_free(struct LDKCResult_CVec_u8ZPeerHandleErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZPeerHandleErrorZ CResult_CVec_u8ZPeerHandleErrorZ_clone(const struct LDKCResult_CVec_u8ZPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the success state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_ok(void);

/**
 * Creates a new CResult_NonePeerHandleErrorZ in the error state.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePeerHandleErrorZ_is_ok(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePeerHandleErrorZ.
 */
void CResult_NonePeerHandleErrorZ_free(struct LDKCResult_NonePeerHandleErrorZ _res);

/**
 * Creates a new CResult_NonePeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePeerHandleErrorZ CResult_NonePeerHandleErrorZ_clone(const struct LDKCResult_NonePeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the success state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_ok(bool o);

/**
 * Creates a new CResult_boolPeerHandleErrorZ in the error state.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_err(struct LDKPeerHandleError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_boolPeerHandleErrorZ_is_ok(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_boolPeerHandleErrorZ.
 */
void CResult_boolPeerHandleErrorZ_free(struct LDKCResult_boolPeerHandleErrorZ _res);

/**
 * Creates a new CResult_boolPeerHandleErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_boolPeerHandleErrorZ CResult_boolPeerHandleErrorZ_clone(const struct LDKCResult_boolPeerHandleErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_u32GraphSyncErrorZ in the success state.
 */
struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_ok(uint32_t o);

/**
 * Creates a new CResult_u32GraphSyncErrorZ in the error state.
 */
struct LDKCResult_u32GraphSyncErrorZ CResult_u32GraphSyncErrorZ_err(struct LDKGraphSyncError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_u32GraphSyncErrorZ_is_ok(const struct LDKCResult_u32GraphSyncErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_u32GraphSyncErrorZ.
 */
void CResult_u32GraphSyncErrorZ_free(struct LDKCResult_u32GraphSyncErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZIOErrorZ in the success state.
 */
struct LDKCResult_CVec_u8ZIOErrorZ CResult_CVec_u8ZIOErrorZ_ok(struct LDKCVec_u8Z o);

/**
 * Creates a new CResult_CVec_u8ZIOErrorZ in the error state.
 */
struct LDKCResult_CVec_u8ZIOErrorZ CResult_CVec_u8ZIOErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_u8ZIOErrorZ_is_ok(const struct LDKCResult_CVec_u8ZIOErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_u8ZIOErrorZ.
 */
void CResult_CVec_u8ZIOErrorZ_free(struct LDKCResult_CVec_u8ZIOErrorZ _res);

/**
 * Creates a new CResult_CVec_u8ZIOErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_u8ZIOErrorZ CResult_CVec_u8ZIOErrorZ_clone(const struct LDKCResult_CVec_u8ZIOErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_StrZ_free(struct LDKCVec_StrZ _res);

/**
 * Creates a new CResult_CVec_StrZIOErrorZ in the success state.
 */
struct LDKCResult_CVec_StrZIOErrorZ CResult_CVec_StrZIOErrorZ_ok(struct LDKCVec_StrZ o);

/**
 * Creates a new CResult_CVec_StrZIOErrorZ in the error state.
 */
struct LDKCResult_CVec_StrZIOErrorZ CResult_CVec_StrZIOErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_StrZIOErrorZ_is_ok(const struct LDKCResult_CVec_StrZIOErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_StrZIOErrorZ.
 */
void CResult_CVec_StrZIOErrorZ_free(struct LDKCResult_CVec_StrZIOErrorZ _res);

/**
 * Creates a new CResult_CVec_StrZIOErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_StrZIOErrorZ CResult_CVec_StrZIOErrorZ_clone(const struct LDKCResult_CVec_StrZIOErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ_free(struct LDKCVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_ok(struct LDKCVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_is_ok(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ.
 */
void CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_free(struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ_clone(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_ok(struct LDKC2Tuple_ThirtyTwoBytesChannelMonitorZ o);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_err(enum LDKIOError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_is_ok(const struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ.
 */
void CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_free(struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ _res);

/**
 * Creates a new CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ CResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ_clone(const struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_SecretKeyZ containing a crate::c_types::SecretKey
 */
struct LDKCOption_SecretKeyZ COption_SecretKeyZ_some(struct LDKSecretKey o);

/**
 * Constructs a new COption_SecretKeyZ containing nothing
 */
struct LDKCOption_SecretKeyZ COption_SecretKeyZ_none(void);

/**
 * Frees any resources associated with the crate::c_types::SecretKey, if we are in the Some state
 */
void COption_SecretKeyZ_free(struct LDKCOption_SecretKeyZ _res);

/**
 * Creates a new COption_SecretKeyZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_SecretKeyZ COption_SecretKeyZ_clone(const struct LDKCOption_SecretKeyZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_VerifiedInvoiceRequestNoneZ in the success state.
 */
struct LDKCResult_VerifiedInvoiceRequestNoneZ CResult_VerifiedInvoiceRequestNoneZ_ok(struct LDKVerifiedInvoiceRequest o);

/**
 * Creates a new CResult_VerifiedInvoiceRequestNoneZ in the error state.
 */
struct LDKCResult_VerifiedInvoiceRequestNoneZ CResult_VerifiedInvoiceRequestNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_VerifiedInvoiceRequestNoneZ_is_ok(const struct LDKCResult_VerifiedInvoiceRequestNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_VerifiedInvoiceRequestNoneZ.
 */
void CResult_VerifiedInvoiceRequestNoneZ_free(struct LDKCResult_VerifiedInvoiceRequestNoneZ _res);

/**
 * Creates a new CResult_VerifiedInvoiceRequestNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_VerifiedInvoiceRequestNoneZ CResult_VerifiedInvoiceRequestNoneZ_clone(const struct LDKCResult_VerifiedInvoiceRequestNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_NoneZ containing a
 */
enum LDKCOption_NoneZ COption_NoneZ_some(void);

/**
 * Constructs a new COption_NoneZ containing nothing
 */
enum LDKCOption_NoneZ COption_NoneZ_none(void);

/**
 * Frees any resources associated with the , if we are in the Some state
 */
void COption_NoneZ_free(enum LDKCOption_NoneZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_WitnessZ_free(struct LDKCVec_WitnessZ _res);

/**
 * Constructs a new COption_i64Z containing a i64
 */
struct LDKCOption_i64Z COption_i64Z_some(int64_t o);

/**
 * Constructs a new COption_i64Z containing nothing
 */
struct LDKCOption_i64Z COption_i64Z_none(void);

/**
 * Frees any resources associated with the i64, if we are in the Some state
 */
void COption_i64Z_free(struct LDKCOption_i64Z _res);

/**
 * Creates a new COption_i64Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_i64Z COption_i64Z_clone(const struct LDKCOption_i64Z *NONNULL_PTR orig);

/**
 * Creates a new CResult_SocketAddressDecodeErrorZ in the success state.
 */
struct LDKCResult_SocketAddressDecodeErrorZ CResult_SocketAddressDecodeErrorZ_ok(struct LDKSocketAddress o);

/**
 * Creates a new CResult_SocketAddressDecodeErrorZ in the error state.
 */
struct LDKCResult_SocketAddressDecodeErrorZ CResult_SocketAddressDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SocketAddressDecodeErrorZ_is_ok(const struct LDKCResult_SocketAddressDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SocketAddressDecodeErrorZ.
 */
void CResult_SocketAddressDecodeErrorZ_free(struct LDKCResult_SocketAddressDecodeErrorZ _res);

/**
 * Creates a new CResult_SocketAddressDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SocketAddressDecodeErrorZ CResult_SocketAddressDecodeErrorZ_clone(const struct LDKCResult_SocketAddressDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the success state.
 */
struct LDKCResult_SocketAddressSocketAddressParseErrorZ CResult_SocketAddressSocketAddressParseErrorZ_ok(struct LDKSocketAddress o);

/**
 * Creates a new CResult_SocketAddressSocketAddressParseErrorZ in the error state.
 */
struct LDKCResult_SocketAddressSocketAddressParseErrorZ CResult_SocketAddressSocketAddressParseErrorZ_err(enum LDKSocketAddressParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SocketAddressSocketAddressParseErrorZ_is_ok(const struct LDKCResult_SocketAddressSocketAddressParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SocketAddressSocketAddressParseErrorZ.
 */
void CResult_SocketAddressSocketAddressParseErrorZ_free(struct LDKCResult_SocketAddressSocketAddressParseErrorZ _res);

/**
 * Creates a new CResult_SocketAddressSocketAddressParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SocketAddressSocketAddressParseErrorZ CResult_SocketAddressSocketAddressParseErrorZ_clone(const struct LDKCResult_SocketAddressSocketAddressParseErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateAddHTLCZ_free(struct LDKCVec_UpdateAddHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFulfillHTLCZ_free(struct LDKCVec_UpdateFulfillHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailHTLCZ_free(struct LDKCVec_UpdateFailHTLCZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_UpdateFailMalformedHTLCZ_free(struct LDKCVec_UpdateFailMalformedHTLCZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_ok(struct LDKAcceptChannel o);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AcceptChannelDecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AcceptChannelDecodeErrorZ.
 */
void CResult_AcceptChannelDecodeErrorZ_free(struct LDKCResult_AcceptChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_AcceptChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AcceptChannelDecodeErrorZ CResult_AcceptChannelDecodeErrorZ_clone(const struct LDKCResult_AcceptChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_AcceptChannelV2DecodeErrorZ in the success state.
 */
struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_ok(struct LDKAcceptChannelV2 o);

/**
 * Creates a new CResult_AcceptChannelV2DecodeErrorZ in the error state.
 */
struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AcceptChannelV2DecodeErrorZ_is_ok(const struct LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AcceptChannelV2DecodeErrorZ.
 */
void CResult_AcceptChannelV2DecodeErrorZ_free(struct LDKCResult_AcceptChannelV2DecodeErrorZ _res);

/**
 * Creates a new CResult_AcceptChannelV2DecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AcceptChannelV2DecodeErrorZ CResult_AcceptChannelV2DecodeErrorZ_clone(const struct LDKCResult_AcceptChannelV2DecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxAddInputDecodeErrorZ in the success state.
 */
struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_ok(struct LDKTxAddInput o);

/**
 * Creates a new CResult_TxAddInputDecodeErrorZ in the error state.
 */
struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxAddInputDecodeErrorZ_is_ok(const struct LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxAddInputDecodeErrorZ.
 */
void CResult_TxAddInputDecodeErrorZ_free(struct LDKCResult_TxAddInputDecodeErrorZ _res);

/**
 * Creates a new CResult_TxAddInputDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxAddInputDecodeErrorZ CResult_TxAddInputDecodeErrorZ_clone(const struct LDKCResult_TxAddInputDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxAddOutputDecodeErrorZ in the success state.
 */
struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_ok(struct LDKTxAddOutput o);

/**
 * Creates a new CResult_TxAddOutputDecodeErrorZ in the error state.
 */
struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxAddOutputDecodeErrorZ_is_ok(const struct LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxAddOutputDecodeErrorZ.
 */
void CResult_TxAddOutputDecodeErrorZ_free(struct LDKCResult_TxAddOutputDecodeErrorZ _res);

/**
 * Creates a new CResult_TxAddOutputDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxAddOutputDecodeErrorZ CResult_TxAddOutputDecodeErrorZ_clone(const struct LDKCResult_TxAddOutputDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxRemoveInputDecodeErrorZ in the success state.
 */
struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_ok(struct LDKTxRemoveInput o);

/**
 * Creates a new CResult_TxRemoveInputDecodeErrorZ in the error state.
 */
struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxRemoveInputDecodeErrorZ_is_ok(const struct LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxRemoveInputDecodeErrorZ.
 */
void CResult_TxRemoveInputDecodeErrorZ_free(struct LDKCResult_TxRemoveInputDecodeErrorZ _res);

/**
 * Creates a new CResult_TxRemoveInputDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxRemoveInputDecodeErrorZ CResult_TxRemoveInputDecodeErrorZ_clone(const struct LDKCResult_TxRemoveInputDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxRemoveOutputDecodeErrorZ in the success state.
 */
struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_ok(struct LDKTxRemoveOutput o);

/**
 * Creates a new CResult_TxRemoveOutputDecodeErrorZ in the error state.
 */
struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxRemoveOutputDecodeErrorZ_is_ok(const struct LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxRemoveOutputDecodeErrorZ.
 */
void CResult_TxRemoveOutputDecodeErrorZ_free(struct LDKCResult_TxRemoveOutputDecodeErrorZ _res);

/**
 * Creates a new CResult_TxRemoveOutputDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxRemoveOutputDecodeErrorZ CResult_TxRemoveOutputDecodeErrorZ_clone(const struct LDKCResult_TxRemoveOutputDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCompleteDecodeErrorZ in the success state.
 */
struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_ok(struct LDKTxComplete o);

/**
 * Creates a new CResult_TxCompleteDecodeErrorZ in the error state.
 */
struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxCompleteDecodeErrorZ_is_ok(const struct LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxCompleteDecodeErrorZ.
 */
void CResult_TxCompleteDecodeErrorZ_free(struct LDKCResult_TxCompleteDecodeErrorZ _res);

/**
 * Creates a new CResult_TxCompleteDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCompleteDecodeErrorZ CResult_TxCompleteDecodeErrorZ_clone(const struct LDKCResult_TxCompleteDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxSignaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_ok(struct LDKTxSignatures o);

/**
 * Creates a new CResult_TxSignaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxSignaturesDecodeErrorZ.
 */
void CResult_TxSignaturesDecodeErrorZ_free(struct LDKCResult_TxSignaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_TxSignaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxSignaturesDecodeErrorZ CResult_TxSignaturesDecodeErrorZ_clone(const struct LDKCResult_TxSignaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxInitRbfDecodeErrorZ in the success state.
 */
struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_ok(struct LDKTxInitRbf o);

/**
 * Creates a new CResult_TxInitRbfDecodeErrorZ in the error state.
 */
struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxInitRbfDecodeErrorZ_is_ok(const struct LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxInitRbfDecodeErrorZ.
 */
void CResult_TxInitRbfDecodeErrorZ_free(struct LDKCResult_TxInitRbfDecodeErrorZ _res);

/**
 * Creates a new CResult_TxInitRbfDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxInitRbfDecodeErrorZ CResult_TxInitRbfDecodeErrorZ_clone(const struct LDKCResult_TxInitRbfDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxAckRbfDecodeErrorZ in the success state.
 */
struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_ok(struct LDKTxAckRbf o);

/**
 * Creates a new CResult_TxAckRbfDecodeErrorZ in the error state.
 */
struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxAckRbfDecodeErrorZ_is_ok(const struct LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxAckRbfDecodeErrorZ.
 */
void CResult_TxAckRbfDecodeErrorZ_free(struct LDKCResult_TxAckRbfDecodeErrorZ _res);

/**
 * Creates a new CResult_TxAckRbfDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxAckRbfDecodeErrorZ CResult_TxAckRbfDecodeErrorZ_clone(const struct LDKCResult_TxAckRbfDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxAbortDecodeErrorZ in the success state.
 */
struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_ok(struct LDKTxAbort o);

/**
 * Creates a new CResult_TxAbortDecodeErrorZ in the error state.
 */
struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxAbortDecodeErrorZ_is_ok(const struct LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxAbortDecodeErrorZ.
 */
void CResult_TxAbortDecodeErrorZ_free(struct LDKCResult_TxAbortDecodeErrorZ _res);

/**
 * Creates a new CResult_TxAbortDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxAbortDecodeErrorZ CResult_TxAbortDecodeErrorZ_clone(const struct LDKCResult_TxAbortDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the success state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_ok(struct LDKAnnouncementSignatures o);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ in the error state.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_AnnouncementSignaturesDecodeErrorZ_is_ok(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_AnnouncementSignaturesDecodeErrorZ.
 */
void CResult_AnnouncementSignaturesDecodeErrorZ_free(struct LDKCResult_AnnouncementSignaturesDecodeErrorZ _res);

/**
 * Creates a new CResult_AnnouncementSignaturesDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ CResult_AnnouncementSignaturesDecodeErrorZ_clone(const struct LDKCResult_AnnouncementSignaturesDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_ok(struct LDKChannelReestablish o);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelReestablishDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelReestablishDecodeErrorZ.
 */
void CResult_ChannelReestablishDecodeErrorZ_free(struct LDKCResult_ChannelReestablishDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReestablishDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ CResult_ChannelReestablishDecodeErrorZ_clone(const struct LDKCResult_ChannelReestablishDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_ok(struct LDKClosingSigned o);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedDecodeErrorZ.
 */
void CResult_ClosingSignedDecodeErrorZ_free(struct LDKCResult_ClosingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedDecodeErrorZ CResult_ClosingSignedDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_ok(struct LDKClosingSignedFeeRange o);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClosingSignedFeeRangeDecodeErrorZ_is_ok(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClosingSignedFeeRangeDecodeErrorZ.
 */
void CResult_ClosingSignedFeeRangeDecodeErrorZ_free(struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ClosingSignedFeeRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ CResult_ClosingSignedFeeRangeDecodeErrorZ_clone(const struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_ok(struct LDKCommitmentSigned o);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentSignedDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentSignedDecodeErrorZ.
 */
void CResult_CommitmentSignedDecodeErrorZ_free(struct LDKCResult_CommitmentSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CResult_CommitmentSignedDecodeErrorZ_clone(const struct LDKCResult_CommitmentSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_ok(struct LDKFundingCreated o);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingCreatedDecodeErrorZ_is_ok(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingCreatedDecodeErrorZ.
 */
void CResult_FundingCreatedDecodeErrorZ_free(struct LDKCResult_FundingCreatedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingCreatedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingCreatedDecodeErrorZ CResult_FundingCreatedDecodeErrorZ_clone(const struct LDKCResult_FundingCreatedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the success state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_ok(struct LDKFundingSigned o);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ in the error state.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_FundingSignedDecodeErrorZ_is_ok(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_FundingSignedDecodeErrorZ.
 */
void CResult_FundingSignedDecodeErrorZ_free(struct LDKCResult_FundingSignedDecodeErrorZ _res);

/**
 * Creates a new CResult_FundingSignedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_FundingSignedDecodeErrorZ CResult_FundingSignedDecodeErrorZ_clone(const struct LDKCResult_FundingSignedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_ok(struct LDKChannelReady o);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelReadyDecodeErrorZ_is_ok(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelReadyDecodeErrorZ.
 */
void CResult_ChannelReadyDecodeErrorZ_free(struct LDKCResult_ChannelReadyDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelReadyDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelReadyDecodeErrorZ CResult_ChannelReadyDecodeErrorZ_clone(const struct LDKCResult_ChannelReadyDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InitDecodeErrorZ in the success state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_ok(struct LDKInit o);

/**
 * Creates a new CResult_InitDecodeErrorZ in the error state.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InitDecodeErrorZ_is_ok(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InitDecodeErrorZ.
 */
void CResult_InitDecodeErrorZ_free(struct LDKCResult_InitDecodeErrorZ _res);

/**
 * Creates a new CResult_InitDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InitDecodeErrorZ CResult_InitDecodeErrorZ_clone(const struct LDKCResult_InitDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the success state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_ok(struct LDKOpenChannel o);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ in the error state.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OpenChannelDecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OpenChannelDecodeErrorZ.
 */
void CResult_OpenChannelDecodeErrorZ_free(struct LDKCResult_OpenChannelDecodeErrorZ _res);

/**
 * Creates a new CResult_OpenChannelDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OpenChannelDecodeErrorZ CResult_OpenChannelDecodeErrorZ_clone(const struct LDKCResult_OpenChannelDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OpenChannelV2DecodeErrorZ in the success state.
 */
struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_ok(struct LDKOpenChannelV2 o);

/**
 * Creates a new CResult_OpenChannelV2DecodeErrorZ in the error state.
 */
struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OpenChannelV2DecodeErrorZ_is_ok(const struct LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OpenChannelV2DecodeErrorZ.
 */
void CResult_OpenChannelV2DecodeErrorZ_free(struct LDKCResult_OpenChannelV2DecodeErrorZ _res);

/**
 * Creates a new CResult_OpenChannelV2DecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OpenChannelV2DecodeErrorZ CResult_OpenChannelV2DecodeErrorZ_clone(const struct LDKCResult_OpenChannelV2DecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the success state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_ok(struct LDKRevokeAndACK o);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ in the error state.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_RevokeAndACKDecodeErrorZ_is_ok(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_RevokeAndACKDecodeErrorZ.
 */
void CResult_RevokeAndACKDecodeErrorZ_free(struct LDKCResult_RevokeAndACKDecodeErrorZ _res);

/**
 * Creates a new CResult_RevokeAndACKDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ CResult_RevokeAndACKDecodeErrorZ_clone(const struct LDKCResult_RevokeAndACKDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_ok(struct LDKShutdown o);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownDecodeErrorZ.
 */
void CResult_ShutdownDecodeErrorZ_free(struct LDKCResult_ShutdownDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownDecodeErrorZ CResult_ShutdownDecodeErrorZ_clone(const struct LDKCResult_ShutdownDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_ok(struct LDKUpdateFailHTLC o);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailHTLCDecodeErrorZ.
 */
void CResult_UpdateFailHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ CResult_UpdateFailHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_ok(struct LDKUpdateFailMalformedHTLC o);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFailMalformedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFailMalformedHTLCDecodeErrorZ.
 */
void CResult_UpdateFailMalformedHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFailMalformedHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ CResult_UpdateFailMalformedHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_ok(struct LDKUpdateFee o);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFeeDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFeeDecodeErrorZ.
 */
void CResult_UpdateFeeDecodeErrorZ_free(struct LDKCResult_UpdateFeeDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFeeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFeeDecodeErrorZ CResult_UpdateFeeDecodeErrorZ_clone(const struct LDKCResult_UpdateFeeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_ok(struct LDKUpdateFulfillHTLC o);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateFulfillHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateFulfillHTLCDecodeErrorZ.
 */
void CResult_UpdateFulfillHTLCDecodeErrorZ_free(struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateFulfillHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ CResult_UpdateFulfillHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_ok(struct LDKUpdateAddHTLC o);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UpdateAddHTLCDecodeErrorZ_is_ok(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UpdateAddHTLCDecodeErrorZ.
 */
void CResult_UpdateAddHTLCDecodeErrorZ_free(struct LDKCResult_UpdateAddHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_UpdateAddHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ CResult_UpdateAddHTLCDecodeErrorZ_clone(const struct LDKCResult_UpdateAddHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_ok(struct LDKOnionMessage o);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OnionMessageDecodeErrorZ_is_ok(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OnionMessageDecodeErrorZ.
 */
void CResult_OnionMessageDecodeErrorZ_free(struct LDKCResult_OnionMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_OnionMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OnionMessageDecodeErrorZ CResult_OnionMessageDecodeErrorZ_clone(const struct LDKCResult_OnionMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PingDecodeErrorZ in the success state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_ok(struct LDKPing o);

/**
 * Creates a new CResult_PingDecodeErrorZ in the error state.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PingDecodeErrorZ_is_ok(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PingDecodeErrorZ.
 */
void CResult_PingDecodeErrorZ_free(struct LDKCResult_PingDecodeErrorZ _res);

/**
 * Creates a new CResult_PingDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PingDecodeErrorZ CResult_PingDecodeErrorZ_clone(const struct LDKCResult_PingDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PongDecodeErrorZ in the success state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_ok(struct LDKPong o);

/**
 * Creates a new CResult_PongDecodeErrorZ in the error state.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PongDecodeErrorZ_is_ok(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PongDecodeErrorZ.
 */
void CResult_PongDecodeErrorZ_free(struct LDKCResult_PongDecodeErrorZ _res);

/**
 * Creates a new CResult_PongDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PongDecodeErrorZ CResult_PongDecodeErrorZ_clone(const struct LDKCResult_PongDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_ok(struct LDKUnsignedChannelAnnouncement o);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ CResult_UnsignedChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_ok(struct LDKChannelAnnouncement o);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelAnnouncementDecodeErrorZ.
 */
void CResult_ChannelAnnouncementDecodeErrorZ_free(struct LDKCResult_ChannelAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ CResult_ChannelAnnouncementDecodeErrorZ_clone(const struct LDKCResult_ChannelAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_ok(struct LDKUnsignedChannelUpdate o);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedChannelUpdateDecodeErrorZ.
 */
void CResult_UnsignedChannelUpdateDecodeErrorZ_free(struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ CResult_UnsignedChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_ok(struct LDKChannelUpdate o);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelUpdateDecodeErrorZ_is_ok(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelUpdateDecodeErrorZ.
 */
void CResult_ChannelUpdateDecodeErrorZ_free(struct LDKCResult_ChannelUpdateDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelUpdateDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ CResult_ChannelUpdateDecodeErrorZ_clone(const struct LDKCResult_ChannelUpdateDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_ok(struct LDKErrorMessage o);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ErrorMessageDecodeErrorZ_is_ok(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ErrorMessageDecodeErrorZ.
 */
void CResult_ErrorMessageDecodeErrorZ_free(struct LDKCResult_ErrorMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_ErrorMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ErrorMessageDecodeErrorZ CResult_ErrorMessageDecodeErrorZ_clone(const struct LDKCResult_ErrorMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_ok(struct LDKWarningMessage o);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_WarningMessageDecodeErrorZ_is_ok(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_WarningMessageDecodeErrorZ.
 */
void CResult_WarningMessageDecodeErrorZ_free(struct LDKCResult_WarningMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_WarningMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_WarningMessageDecodeErrorZ CResult_WarningMessageDecodeErrorZ_clone(const struct LDKCResult_WarningMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_ok(struct LDKUnsignedNodeAnnouncement o);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UnsignedNodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UnsignedNodeAnnouncementDecodeErrorZ.
 */
void CResult_UnsignedNodeAnnouncementDecodeErrorZ_free(struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_UnsignedNodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ CResult_UnsignedNodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the success state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_ok(struct LDKNodeAnnouncement o);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ in the error state.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NodeAnnouncementDecodeErrorZ_is_ok(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NodeAnnouncementDecodeErrorZ.
 */
void CResult_NodeAnnouncementDecodeErrorZ_free(struct LDKCResult_NodeAnnouncementDecodeErrorZ _res);

/**
 * Creates a new CResult_NodeAnnouncementDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ CResult_NodeAnnouncementDecodeErrorZ_clone(const struct LDKCResult_NodeAnnouncementDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_ok(struct LDKQueryShortChannelIds o);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryShortChannelIdsDecodeErrorZ_is_ok(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryShortChannelIdsDecodeErrorZ.
 */
void CResult_QueryShortChannelIdsDecodeErrorZ_free(struct LDKCResult_QueryShortChannelIdsDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryShortChannelIdsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ CResult_QueryShortChannelIdsDecodeErrorZ_clone(const struct LDKCResult_QueryShortChannelIdsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_ok(struct LDKReplyShortChannelIdsEnd o);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyShortChannelIdsEndDecodeErrorZ_is_ok(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyShortChannelIdsEndDecodeErrorZ.
 */
void CResult_ReplyShortChannelIdsEndDecodeErrorZ_free(struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyShortChannelIdsEndDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ CResult_ReplyShortChannelIdsEndDecodeErrorZ_clone(const struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_ok(struct LDKQueryChannelRange o);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_QueryChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_QueryChannelRangeDecodeErrorZ.
 */
void CResult_QueryChannelRangeDecodeErrorZ_free(struct LDKCResult_QueryChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_QueryChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ CResult_QueryChannelRangeDecodeErrorZ_clone(const struct LDKCResult_QueryChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the success state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_ok(struct LDKReplyChannelRange o);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ in the error state.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReplyChannelRangeDecodeErrorZ_is_ok(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReplyChannelRangeDecodeErrorZ.
 */
void CResult_ReplyChannelRangeDecodeErrorZ_free(struct LDKCResult_ReplyChannelRangeDecodeErrorZ _res);

/**
 * Creates a new CResult_ReplyChannelRangeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ CResult_ReplyChannelRangeDecodeErrorZ_clone(const struct LDKCResult_ReplyChannelRangeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the success state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_ok(struct LDKGossipTimestampFilter o);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ in the error state.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_GossipTimestampFilterDecodeErrorZ_is_ok(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_GossipTimestampFilterDecodeErrorZ.
 */
void CResult_GossipTimestampFilterDecodeErrorZ_free(struct LDKCResult_GossipTimestampFilterDecodeErrorZ _res);

/**
 * Creates a new CResult_GossipTimestampFilterDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ CResult_GossipTimestampFilterDecodeErrorZ_clone(const struct LDKCResult_GossipTimestampFilterDecodeErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PhantomRouteHintsZ_free(struct LDKCVec_PhantomRouteHintsZ _res);

/**
 * Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the success state.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_ok(struct LDKBolt11Invoice o);

/**
 * Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ in the error state.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_err(struct LDKSignOrCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_Bolt11InvoiceSignOrCreationErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_Bolt11InvoiceSignOrCreationErrorZ.
 */
void CResult_Bolt11InvoiceSignOrCreationErrorZ_free(struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ _res);

/**
 * Creates a new CResult_Bolt11InvoiceSignOrCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ CResult_Bolt11InvoiceSignOrCreationErrorZ_clone(const struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_FutureZ_free(struct LDKCVec_FutureZ _res);

/**
 * Creates a new CResult_OffersMessageDecodeErrorZ in the success state.
 */
struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_ok(struct LDKOffersMessage o);

/**
 * Creates a new CResult_OffersMessageDecodeErrorZ in the error state.
 */
struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OffersMessageDecodeErrorZ_is_ok(const struct LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OffersMessageDecodeErrorZ.
 */
void CResult_OffersMessageDecodeErrorZ_free(struct LDKCResult_OffersMessageDecodeErrorZ _res);

/**
 * Creates a new CResult_OffersMessageDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OffersMessageDecodeErrorZ CResult_OffersMessageDecodeErrorZ_clone(const struct LDKCResult_OffersMessageDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_HTLCClaimZ containing a crate::lightning::ln::chan_utils::HTLCClaim
 */
struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_some(enum LDKHTLCClaim o);

/**
 * Constructs a new COption_HTLCClaimZ containing nothing
 */
struct LDKCOption_HTLCClaimZ COption_HTLCClaimZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::ln::chan_utils::HTLCClaim, if we are in the Some state
 */
void COption_HTLCClaimZ_free(struct LDKCOption_HTLCClaimZ _res);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_ok(struct LDKCounterpartyCommitmentSecrets o);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyCommitmentSecretsDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyCommitmentSecretsDecodeErrorZ.
 */
void CResult_CounterpartyCommitmentSecretsDecodeErrorZ_free(struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyCommitmentSecretsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CResult_CounterpartyCommitmentSecretsDecodeErrorZ_clone(const struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_ok(struct LDKTxCreationKeys o);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxCreationKeysDecodeErrorZ_is_ok(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxCreationKeysDecodeErrorZ.
 */
void CResult_TxCreationKeysDecodeErrorZ_free(struct LDKCResult_TxCreationKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_TxCreationKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ CResult_TxCreationKeysDecodeErrorZ_clone(const struct LDKCResult_TxCreationKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_ok(struct LDKChannelPublicKeys o);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelPublicKeysDecodeErrorZ_is_ok(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelPublicKeysDecodeErrorZ.
 */
void CResult_ChannelPublicKeysDecodeErrorZ_free(struct LDKCResult_ChannelPublicKeysDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelPublicKeysDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ CResult_ChannelPublicKeysDecodeErrorZ_clone(const struct LDKCResult_ChannelPublicKeysDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the success state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_ok(struct LDKHTLCOutputInCommitment o);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ in the error state.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HTLCOutputInCommitmentDecodeErrorZ_is_ok(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HTLCOutputInCommitmentDecodeErrorZ.
 */
void CResult_HTLCOutputInCommitmentDecodeErrorZ_free(struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ _res);

/**
 * Creates a new CResult_HTLCOutputInCommitmentDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ CResult_HTLCOutputInCommitmentDecodeErrorZ_clone(const struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_ok(struct LDKCounterpartyChannelTransactionParameters o);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CounterpartyChannelTransactionParametersDecodeErrorZ.
 */
void CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_CounterpartyChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CResult_CounterpartyChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the success state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_ok(struct LDKChannelTransactionParameters o);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ in the error state.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ChannelTransactionParametersDecodeErrorZ_is_ok(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ChannelTransactionParametersDecodeErrorZ.
 */
void CResult_ChannelTransactionParametersDecodeErrorZ_free(struct LDKCResult_ChannelTransactionParametersDecodeErrorZ _res);

/**
 * Creates a new CResult_ChannelTransactionParametersDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ CResult_ChannelTransactionParametersDecodeErrorZ_clone(const struct LDKCResult_ChannelTransactionParametersDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_ok(struct LDKHolderCommitmentTransaction o);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HolderCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HolderCommitmentTransactionDecodeErrorZ.
 */
void CResult_HolderCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_HolderCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ CResult_HolderCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_ok(struct LDKBuiltCommitmentTransaction o);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BuiltCommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BuiltCommitmentTransactionDecodeErrorZ.
 */
void CResult_BuiltCommitmentTransactionDecodeErrorZ_free(struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_BuiltCommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ CResult_BuiltCommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_ok(struct LDKTrustedClosingTransaction o);

/**
 * Creates a new CResult_TrustedClosingTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedClosingTransactionNoneZ CResult_TrustedClosingTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedClosingTransactionNoneZ_is_ok(const struct LDKCResult_TrustedClosingTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedClosingTransactionNoneZ.
 */
void CResult_TrustedClosingTransactionNoneZ_free(struct LDKCResult_TrustedClosingTransactionNoneZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the success state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_ok(struct LDKCommitmentTransaction o);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ in the error state.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CommitmentTransactionDecodeErrorZ_is_ok(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CommitmentTransactionDecodeErrorZ.
 */
void CResult_CommitmentTransactionDecodeErrorZ_free(struct LDKCResult_CommitmentTransactionDecodeErrorZ _res);

/**
 * Creates a new CResult_CommitmentTransactionDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CResult_CommitmentTransactionDecodeErrorZ_clone(const struct LDKCResult_CommitmentTransactionDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the success state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_ok(struct LDKTrustedCommitmentTransaction o);

/**
 * Creates a new CResult_TrustedCommitmentTransactionNoneZ in the error state.
 */
struct LDKCResult_TrustedCommitmentTransactionNoneZ CResult_TrustedCommitmentTransactionNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TrustedCommitmentTransactionNoneZ_is_ok(const struct LDKCResult_TrustedCommitmentTransactionNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TrustedCommitmentTransactionNoneZ.
 */
void CResult_TrustedCommitmentTransactionNoneZ_free(struct LDKCResult_TrustedCommitmentTransactionNoneZ _res);

/**
 * Creates a new CResult_CVec_ECDSASignatureZNoneZ in the success state.
 */
struct LDKCResult_CVec_ECDSASignatureZNoneZ CResult_CVec_ECDSASignatureZNoneZ_ok(struct LDKCVec_ECDSASignatureZ o);

/**
 * Creates a new CResult_CVec_ECDSASignatureZNoneZ in the error state.
 */
struct LDKCResult_CVec_ECDSASignatureZNoneZ CResult_CVec_ECDSASignatureZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_ECDSASignatureZNoneZ_is_ok(const struct LDKCResult_CVec_ECDSASignatureZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_ECDSASignatureZNoneZ.
 */
void CResult_CVec_ECDSASignatureZNoneZ_free(struct LDKCResult_CVec_ECDSASignatureZNoneZ _res);

/**
 * Creates a new CResult_CVec_ECDSASignatureZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_ECDSASignatureZNoneZ CResult_CVec_ECDSASignatureZNoneZ_clone(const struct LDKCResult_CVec_ECDSASignatureZNoneZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_usizeZ containing a usize
 */
struct LDKCOption_usizeZ COption_usizeZ_some(uintptr_t o);

/**
 * Constructs a new COption_usizeZ containing nothing
 */
struct LDKCOption_usizeZ COption_usizeZ_none(void);

/**
 * Frees any resources associated with the usize, if we are in the Some state
 */
void COption_usizeZ_free(struct LDKCOption_usizeZ _res);

/**
 * Creates a new COption_usizeZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_usizeZ COption_usizeZ_clone(const struct LDKCOption_usizeZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the success state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ in the error state.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptDecodeErrorZ_is_ok(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptDecodeErrorZ.
 */
void CResult_ShutdownScriptDecodeErrorZ_free(struct LDKCResult_ShutdownScriptDecodeErrorZ _res);

/**
 * Creates a new CResult_ShutdownScriptDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ CResult_ShutdownScriptDecodeErrorZ_clone(const struct LDKCResult_ShutdownScriptDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the success state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_ok(struct LDKShutdownScript o);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ in the error state.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_err(struct LDKInvalidShutdownScript e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ShutdownScriptInvalidShutdownScriptZ_is_ok(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ShutdownScriptInvalidShutdownScriptZ.
 */
void CResult_ShutdownScriptInvalidShutdownScriptZ_free(struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ _res);

/**
 * Creates a new CResult_ShutdownScriptInvalidShutdownScriptZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ CResult_ShutdownScriptInvalidShutdownScriptZ_clone(const struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_ok(struct LDKPaymentPurpose o);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentPurposeDecodeErrorZ_is_ok(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentPurposeDecodeErrorZ.
 */
void CResult_PaymentPurposeDecodeErrorZ_free(struct LDKCResult_PaymentPurposeDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentPurposeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ CResult_PaymentPurposeDecodeErrorZ_clone(const struct LDKCResult_PaymentPurposeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ClaimedHTLCDecodeErrorZ in the success state.
 */
struct LDKCResult_ClaimedHTLCDecodeErrorZ CResult_ClaimedHTLCDecodeErrorZ_ok(struct LDKClaimedHTLC o);

/**
 * Creates a new CResult_ClaimedHTLCDecodeErrorZ in the error state.
 */
struct LDKCResult_ClaimedHTLCDecodeErrorZ CResult_ClaimedHTLCDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ClaimedHTLCDecodeErrorZ_is_ok(const struct LDKCResult_ClaimedHTLCDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ClaimedHTLCDecodeErrorZ.
 */
void CResult_ClaimedHTLCDecodeErrorZ_free(struct LDKCResult_ClaimedHTLCDecodeErrorZ _res);

/**
 * Creates a new CResult_ClaimedHTLCDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ClaimedHTLCDecodeErrorZ CResult_ClaimedHTLCDecodeErrorZ_clone(const struct LDKCResult_ClaimedHTLCDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_PathFailureZ containing a crate::lightning::events::PathFailure
 */
struct LDKCOption_PathFailureZ COption_PathFailureZ_some(struct LDKPathFailure o);

/**
 * Constructs a new COption_PathFailureZ containing nothing
 */
struct LDKCOption_PathFailureZ COption_PathFailureZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::events::PathFailure, if we are in the Some state
 */
void COption_PathFailureZ_free(struct LDKCOption_PathFailureZ _res);

/**
 * Creates a new COption_PathFailureZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_PathFailureZ COption_PathFailureZ_clone(const struct LDKCOption_PathFailureZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_PathFailureZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_ok(struct LDKCOption_PathFailureZ o);

/**
 * Creates a new CResult_COption_PathFailureZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_PathFailureZDecodeErrorZ_is_ok(const struct LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_PathFailureZDecodeErrorZ.
 */
void CResult_COption_PathFailureZDecodeErrorZ_free(struct LDKCResult_COption_PathFailureZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_PathFailureZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_PathFailureZDecodeErrorZ CResult_COption_PathFailureZDecodeErrorZ_clone(const struct LDKCResult_COption_PathFailureZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_ClosureReasonZ containing a crate::lightning::events::ClosureReason
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_some(struct LDKClosureReason o);

/**
 * Constructs a new COption_ClosureReasonZ containing nothing
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::events::ClosureReason, if we are in the Some state
 */
void COption_ClosureReasonZ_free(struct LDKCOption_ClosureReasonZ _res);

/**
 * Creates a new COption_ClosureReasonZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_ClosureReasonZ COption_ClosureReasonZ_clone(const struct LDKCOption_ClosureReasonZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_ok(struct LDKCOption_ClosureReasonZ o);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_ClosureReasonZDecodeErrorZ_is_ok(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_ClosureReasonZDecodeErrorZ.
 */
void CResult_COption_ClosureReasonZDecodeErrorZ_free(struct LDKCResult_COption_ClosureReasonZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_ClosureReasonZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ CResult_COption_ClosureReasonZDecodeErrorZ_clone(const struct LDKCResult_COption_ClosureReasonZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_HTLCDestinationZ containing a crate::lightning::events::HTLCDestination
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_some(struct LDKHTLCDestination o);

/**
 * Constructs a new COption_HTLCDestinationZ containing nothing
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::events::HTLCDestination, if we are in the Some state
 */
void COption_HTLCDestinationZ_free(struct LDKCOption_HTLCDestinationZ _res);

/**
 * Creates a new COption_HTLCDestinationZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_HTLCDestinationZ COption_HTLCDestinationZ_clone(const struct LDKCOption_HTLCDestinationZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_ok(struct LDKCOption_HTLCDestinationZ o);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_HTLCDestinationZDecodeErrorZ_is_ok(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_HTLCDestinationZDecodeErrorZ.
 */
void CResult_COption_HTLCDestinationZDecodeErrorZ_free(struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_HTLCDestinationZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ CResult_COption_HTLCDestinationZDecodeErrorZ_clone(const struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentFailureReasonDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_ok(enum LDKPaymentFailureReason o);

/**
 * Creates a new CResult_PaymentFailureReasonDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentFailureReasonDecodeErrorZ_is_ok(const struct LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentFailureReasonDecodeErrorZ.
 */
void CResult_PaymentFailureReasonDecodeErrorZ_free(struct LDKCResult_PaymentFailureReasonDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentFailureReasonDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentFailureReasonDecodeErrorZ CResult_PaymentFailureReasonDecodeErrorZ_clone(const struct LDKCResult_PaymentFailureReasonDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_U128Z containing a crate::c_types::U128
 */
struct LDKCOption_U128Z COption_U128Z_some(struct LDKU128 o);

/**
 * Constructs a new COption_U128Z containing nothing
 */
struct LDKCOption_U128Z COption_U128Z_none(void);

/**
 * Frees any resources associated with the crate::c_types::U128, if we are in the Some state
 */
void COption_U128Z_free(struct LDKCOption_U128Z _res);

/**
 * Creates a new COption_U128Z which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_U128Z COption_U128Z_clone(const struct LDKCOption_U128Z *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_ClaimedHTLCZ_free(struct LDKCVec_ClaimedHTLCZ _res);

/**
 * Constructs a new COption_PaymentFailureReasonZ containing a crate::lightning::events::PaymentFailureReason
 */
struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_some(enum LDKPaymentFailureReason o);

/**
 * Constructs a new COption_PaymentFailureReasonZ containing nothing
 */
struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::events::PaymentFailureReason, if we are in the Some state
 */
void COption_PaymentFailureReasonZ_free(struct LDKCOption_PaymentFailureReasonZ _res);

/**
 * Creates a new COption_PaymentFailureReasonZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_PaymentFailureReasonZ COption_PaymentFailureReasonZ_clone(const struct LDKCOption_PaymentFailureReasonZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_EventZ containing a crate::lightning::events::Event
 */
struct LDKCOption_EventZ COption_EventZ_some(struct LDKEvent o);

/**
 * Constructs a new COption_EventZ containing nothing
 */
struct LDKCOption_EventZ COption_EventZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::events::Event, if we are in the Some state
 */
void COption_EventZ_free(struct LDKCOption_EventZ _res);

/**
 * Creates a new COption_EventZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCOption_EventZ COption_EventZ_clone(const struct LDKCOption_EventZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the success state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_ok(struct LDKCOption_EventZ o);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ in the error state.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_COption_EventZDecodeErrorZ_is_ok(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_COption_EventZDecodeErrorZ.
 */
void CResult_COption_EventZDecodeErrorZ_free(struct LDKCResult_COption_EventZDecodeErrorZ _res);

/**
 * Creates a new CResult_COption_EventZDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_COption_EventZDecodeErrorZ CResult_COption_EventZDecodeErrorZ_clone(const struct LDKCResult_COption_EventZDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SiPrefixBolt11ParseErrorZ in the success state.
 */
struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_ok(enum LDKSiPrefix o);

/**
 * Creates a new CResult_SiPrefixBolt11ParseErrorZ in the error state.
 */
struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_err(struct LDKBolt11ParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SiPrefixBolt11ParseErrorZ_is_ok(const struct LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SiPrefixBolt11ParseErrorZ.
 */
void CResult_SiPrefixBolt11ParseErrorZ_free(struct LDKCResult_SiPrefixBolt11ParseErrorZ _res);

/**
 * Creates a new CResult_SiPrefixBolt11ParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SiPrefixBolt11ParseErrorZ CResult_SiPrefixBolt11ParseErrorZ_clone(const struct LDKCResult_SiPrefixBolt11ParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the success state.
 */
struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_ok(struct LDKBolt11Invoice o);

/**
 * Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ in the error state.
 */
struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_err(struct LDKParseOrSemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_Bolt11InvoiceParseOrSemanticErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_Bolt11InvoiceParseOrSemanticErrorZ.
 */
void CResult_Bolt11InvoiceParseOrSemanticErrorZ_free(struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ _res);

/**
 * Creates a new CResult_Bolt11InvoiceParseOrSemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ CResult_Bolt11InvoiceParseOrSemanticErrorZ_clone(const struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the success state.
 */
struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_ok(struct LDKSignedRawBolt11Invoice o);

/**
 * Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ in the error state.
 */
struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_err(struct LDKBolt11ParseError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_is_ok(const struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ.
 */
void CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_free(struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ _res);

/**
 * Creates a new CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ CResult_SignedRawBolt11InvoiceBolt11ParseErrorZ_clone(const struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_clone(const struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ *NONNULL_PTR orig);

/**
 * Creates a new C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ from the contained elements.
 */
struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_new(struct LDKRawBolt11Invoice a, struct LDKThirtyTwoBytes b, struct LDKBolt11InvoiceSignature c);

/**
 * Frees any resources used by the C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ.
 */
void C3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ_free(struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ _res);

/**
 * Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the success state.
 */
struct LDKCResult_PayeePubKeySecp256k1ErrorZ CResult_PayeePubKeySecp256k1ErrorZ_ok(struct LDKPayeePubKey o);

/**
 * Creates a new CResult_PayeePubKeySecp256k1ErrorZ in the error state.
 */
struct LDKCResult_PayeePubKeySecp256k1ErrorZ CResult_PayeePubKeySecp256k1ErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PayeePubKeySecp256k1ErrorZ_is_ok(const struct LDKCResult_PayeePubKeySecp256k1ErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PayeePubKeySecp256k1ErrorZ.
 */
void CResult_PayeePubKeySecp256k1ErrorZ_free(struct LDKCResult_PayeePubKeySecp256k1ErrorZ _res);

/**
 * Creates a new CResult_PayeePubKeySecp256k1ErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PayeePubKeySecp256k1ErrorZ CResult_PayeePubKeySecp256k1ErrorZ_clone(const struct LDKCResult_PayeePubKeySecp256k1ErrorZ *NONNULL_PTR orig);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_PrivateRouteZ_free(struct LDKCVec_PrivateRouteZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the success state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_ok(struct LDKPositiveTimestamp o);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ in the error state.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PositiveTimestampCreationErrorZ_is_ok(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PositiveTimestampCreationErrorZ.
 */
void CResult_PositiveTimestampCreationErrorZ_free(struct LDKCResult_PositiveTimestampCreationErrorZ _res);

/**
 * Creates a new CResult_PositiveTimestampCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PositiveTimestampCreationErrorZ CResult_PositiveTimestampCreationErrorZ_clone(const struct LDKCResult_PositiveTimestampCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NoneBolt11SemanticErrorZ in the success state.
 */
struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_ok(void);

/**
 * Creates a new CResult_NoneBolt11SemanticErrorZ in the error state.
 */
struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_err(enum LDKBolt11SemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneBolt11SemanticErrorZ_is_ok(const struct LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneBolt11SemanticErrorZ.
 */
void CResult_NoneBolt11SemanticErrorZ_free(struct LDKCResult_NoneBolt11SemanticErrorZ _res);

/**
 * Creates a new CResult_NoneBolt11SemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NoneBolt11SemanticErrorZ CResult_NoneBolt11SemanticErrorZ_clone(const struct LDKCResult_NoneBolt11SemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the success state.
 */
struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_ok(struct LDKBolt11Invoice o);

/**
 * Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ in the error state.
 */
struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_err(enum LDKBolt11SemanticError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_Bolt11InvoiceBolt11SemanticErrorZ_is_ok(const struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_Bolt11InvoiceBolt11SemanticErrorZ.
 */
void CResult_Bolt11InvoiceBolt11SemanticErrorZ_free(struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ _res);

/**
 * Creates a new CResult_Bolt11InvoiceBolt11SemanticErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ CResult_Bolt11InvoiceBolt11SemanticErrorZ_clone(const struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the success state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_ok(struct LDKDescription o);

/**
 * Creates a new CResult_DescriptionCreationErrorZ in the error state.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_DescriptionCreationErrorZ_is_ok(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_DescriptionCreationErrorZ.
 */
void CResult_DescriptionCreationErrorZ_free(struct LDKCResult_DescriptionCreationErrorZ _res);

/**
 * Creates a new CResult_DescriptionCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_DescriptionCreationErrorZ CResult_DescriptionCreationErrorZ_clone(const struct LDKCResult_DescriptionCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the success state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_ok(struct LDKPrivateRoute o);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ in the error state.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_err(enum LDKCreationError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PrivateRouteCreationErrorZ_is_ok(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PrivateRouteCreationErrorZ.
 */
void CResult_PrivateRouteCreationErrorZ_free(struct LDKCResult_PrivateRouteCreationErrorZ _res);

/**
 * Creates a new CResult_PrivateRouteCreationErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PrivateRouteCreationErrorZ CResult_PrivateRouteCreationErrorZ_clone(const struct LDKCResult_PrivateRouteCreationErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the success state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_ok(struct LDKOutPoint o);

/**
 * Creates a new CResult_OutPointDecodeErrorZ in the error state.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OutPointDecodeErrorZ_is_ok(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OutPointDecodeErrorZ.
 */
void CResult_OutPointDecodeErrorZ_free(struct LDKCResult_OutPointDecodeErrorZ _res);

/**
 * Creates a new CResult_OutPointDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OutPointDecodeErrorZ CResult_OutPointDecodeErrorZ_clone(const struct LDKCResult_OutPointDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BigSizeDecodeErrorZ in the success state.
 */
struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_ok(struct LDKBigSize o);

/**
 * Creates a new CResult_BigSizeDecodeErrorZ in the error state.
 */
struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BigSizeDecodeErrorZ_is_ok(const struct LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BigSizeDecodeErrorZ.
 */
void CResult_BigSizeDecodeErrorZ_free(struct LDKCResult_BigSizeDecodeErrorZ _res);

/**
 * Creates a new CResult_BigSizeDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BigSizeDecodeErrorZ CResult_BigSizeDecodeErrorZ_clone(const struct LDKCResult_BigSizeDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_HostnameDecodeErrorZ in the success state.
 */
struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_ok(struct LDKHostname o);

/**
 * Creates a new CResult_HostnameDecodeErrorZ in the error state.
 */
struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_HostnameDecodeErrorZ_is_ok(const struct LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_HostnameDecodeErrorZ.
 */
void CResult_HostnameDecodeErrorZ_free(struct LDKCResult_HostnameDecodeErrorZ _res);

/**
 * Creates a new CResult_HostnameDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_HostnameDecodeErrorZ CResult_HostnameDecodeErrorZ_clone(const struct LDKCResult_HostnameDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TransactionU16LenLimitedNoneZ in the success state.
 */
struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_ok(struct LDKTransactionU16LenLimited o);

/**
 * Creates a new CResult_TransactionU16LenLimitedNoneZ in the error state.
 */
struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TransactionU16LenLimitedNoneZ_is_ok(const struct LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TransactionU16LenLimitedNoneZ.
 */
void CResult_TransactionU16LenLimitedNoneZ_free(struct LDKCResult_TransactionU16LenLimitedNoneZ _res);

/**
 * Creates a new CResult_TransactionU16LenLimitedNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionU16LenLimitedNoneZ CResult_TransactionU16LenLimitedNoneZ_clone(const struct LDKCResult_TransactionU16LenLimitedNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the success state.
 */
struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_ok(struct LDKTransactionU16LenLimited o);

/**
 * Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ in the error state.
 */
struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TransactionU16LenLimitedDecodeErrorZ_is_ok(const struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TransactionU16LenLimitedDecodeErrorZ.
 */
void CResult_TransactionU16LenLimitedDecodeErrorZ_free(struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ _res);

/**
 * Creates a new CResult_TransactionU16LenLimitedDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ CResult_TransactionU16LenLimitedDecodeErrorZ_clone(const struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_UntrustedStringDecodeErrorZ in the success state.
 */
struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_ok(struct LDKUntrustedString o);

/**
 * Creates a new CResult_UntrustedStringDecodeErrorZ in the error state.
 */
struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_UntrustedStringDecodeErrorZ_is_ok(const struct LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_UntrustedStringDecodeErrorZ.
 */
void CResult_UntrustedStringDecodeErrorZ_free(struct LDKCResult_UntrustedStringDecodeErrorZ _res);

/**
 * Creates a new CResult_UntrustedStringDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_UntrustedStringDecodeErrorZ CResult_UntrustedStringDecodeErrorZ_clone(const struct LDKCResult_UntrustedStringDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ReceiveTlvsDecodeErrorZ in the success state.
 */
struct LDKCResult_ReceiveTlvsDecodeErrorZ CResult_ReceiveTlvsDecodeErrorZ_ok(struct LDKReceiveTlvs o);

/**
 * Creates a new CResult_ReceiveTlvsDecodeErrorZ in the error state.
 */
struct LDKCResult_ReceiveTlvsDecodeErrorZ CResult_ReceiveTlvsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ReceiveTlvsDecodeErrorZ_is_ok(const struct LDKCResult_ReceiveTlvsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ReceiveTlvsDecodeErrorZ.
 */
void CResult_ReceiveTlvsDecodeErrorZ_free(struct LDKCResult_ReceiveTlvsDecodeErrorZ _res);

/**
 * Creates a new CResult_ReceiveTlvsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ReceiveTlvsDecodeErrorZ CResult_ReceiveTlvsDecodeErrorZ_clone(const struct LDKCResult_ReceiveTlvsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentRelayDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentRelayDecodeErrorZ CResult_PaymentRelayDecodeErrorZ_ok(struct LDKPaymentRelay o);

/**
 * Creates a new CResult_PaymentRelayDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentRelayDecodeErrorZ CResult_PaymentRelayDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentRelayDecodeErrorZ_is_ok(const struct LDKCResult_PaymentRelayDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentRelayDecodeErrorZ.
 */
void CResult_PaymentRelayDecodeErrorZ_free(struct LDKCResult_PaymentRelayDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentRelayDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentRelayDecodeErrorZ CResult_PaymentRelayDecodeErrorZ_clone(const struct LDKCResult_PaymentRelayDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_PaymentConstraintsDecodeErrorZ in the success state.
 */
struct LDKCResult_PaymentConstraintsDecodeErrorZ CResult_PaymentConstraintsDecodeErrorZ_ok(struct LDKPaymentConstraints o);

/**
 * Creates a new CResult_PaymentConstraintsDecodeErrorZ in the error state.
 */
struct LDKCResult_PaymentConstraintsDecodeErrorZ CResult_PaymentConstraintsDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_PaymentConstraintsDecodeErrorZ_is_ok(const struct LDKCResult_PaymentConstraintsDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_PaymentConstraintsDecodeErrorZ.
 */
void CResult_PaymentConstraintsDecodeErrorZ_free(struct LDKCResult_PaymentConstraintsDecodeErrorZ _res);

/**
 * Creates a new CResult_PaymentConstraintsDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_PaymentConstraintsDecodeErrorZ CResult_PaymentConstraintsDecodeErrorZ_clone(const struct LDKCResult_PaymentConstraintsDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentErrorZ in the success state.
 */
struct LDKCResult_ThirtyTwoBytesPaymentErrorZ CResult_ThirtyTwoBytesPaymentErrorZ_ok(struct LDKThirtyTwoBytes o);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentErrorZ in the error state.
 */
struct LDKCResult_ThirtyTwoBytesPaymentErrorZ CResult_ThirtyTwoBytesPaymentErrorZ_err(struct LDKPaymentError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_ThirtyTwoBytesPaymentErrorZ_is_ok(const struct LDKCResult_ThirtyTwoBytesPaymentErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_ThirtyTwoBytesPaymentErrorZ.
 */
void CResult_ThirtyTwoBytesPaymentErrorZ_free(struct LDKCResult_ThirtyTwoBytesPaymentErrorZ _res);

/**
 * Creates a new CResult_ThirtyTwoBytesPaymentErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_ThirtyTwoBytesPaymentErrorZ CResult_ThirtyTwoBytesPaymentErrorZ_clone(const struct LDKCResult_ThirtyTwoBytesPaymentErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_NonePaymentErrorZ in the success state.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_ok(void);

/**
 * Creates a new CResult_NonePaymentErrorZ in the error state.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_err(struct LDKPaymentError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NonePaymentErrorZ_is_ok(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NonePaymentErrorZ.
 */
void CResult_NonePaymentErrorZ_free(struct LDKCResult_NonePaymentErrorZ _res);

/**
 * Creates a new CResult_NonePaymentErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_NonePaymentErrorZ CResult_NonePaymentErrorZ_clone(const struct LDKCResult_NonePaymentErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ in the success state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ_ok(struct LDKCVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZ o);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ in the error state.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ_err(struct LDKProbingError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ_is_ok(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ.
 */
void CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ_free(struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ _res);

/**
 * Creates a new CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ CResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ_clone(const struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_StrSecp256k1ErrorZ in the success state.
 */
struct LDKCResult_StrSecp256k1ErrorZ CResult_StrSecp256k1ErrorZ_ok(struct LDKStr o);

/**
 * Creates a new CResult_StrSecp256k1ErrorZ in the error state.
 */
struct LDKCResult_StrSecp256k1ErrorZ CResult_StrSecp256k1ErrorZ_err(enum LDKSecp256k1Error e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_StrSecp256k1ErrorZ_is_ok(const struct LDKCResult_StrSecp256k1ErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_StrSecp256k1ErrorZ.
 */
void CResult_StrSecp256k1ErrorZ_free(struct LDKCResult_StrSecp256k1ErrorZ _res);

/**
 * Creates a new CResult_StrSecp256k1ErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_StrSecp256k1ErrorZ CResult_StrSecp256k1ErrorZ_clone(const struct LDKCResult_StrSecp256k1ErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_TxOutUtxoLookupErrorZ in the success state.
 */
struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_ok(struct LDKTxOut o);

/**
 * Creates a new CResult_TxOutUtxoLookupErrorZ in the error state.
 */
struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_err(enum LDKUtxoLookupError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_TxOutUtxoLookupErrorZ_is_ok(const struct LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_TxOutUtxoLookupErrorZ.
 */
void CResult_TxOutUtxoLookupErrorZ_free(struct LDKCResult_TxOutUtxoLookupErrorZ _res);

/**
 * Creates a new CResult_TxOutUtxoLookupErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_TxOutUtxoLookupErrorZ CResult_TxOutUtxoLookupErrorZ_clone(const struct LDKCResult_TxOutUtxoLookupErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_OnionMessagePathNoneZ in the success state.
 */
struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_ok(struct LDKOnionMessagePath o);

/**
 * Creates a new CResult_OnionMessagePathNoneZ in the error state.
 */
struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_OnionMessagePathNoneZ_is_ok(const struct LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_OnionMessagePathNoneZ.
 */
void CResult_OnionMessagePathNoneZ_free(struct LDKCResult_OnionMessagePathNoneZ _res);

/**
 * Creates a new CResult_OnionMessagePathNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_OnionMessagePathNoneZ CResult_OnionMessagePathNoneZ_clone(const struct LDKCResult_OnionMessagePathNoneZ *NONNULL_PTR orig);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_PublicKeyOnionMessageZ C2Tuple_PublicKeyOnionMessageZ_clone(const struct LDKC2Tuple_PublicKeyOnionMessageZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_PublicKeyOnionMessageZ from the contained elements.
 */
struct LDKC2Tuple_PublicKeyOnionMessageZ C2Tuple_PublicKeyOnionMessageZ_new(struct LDKPublicKey a, struct LDKOnionMessage b);

/**
 * Frees any resources used by the C2Tuple_PublicKeyOnionMessageZ.
 */
void C2Tuple_PublicKeyOnionMessageZ_free(struct LDKC2Tuple_PublicKeyOnionMessageZ _res);

/**
 * Creates a new CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ in the success state.
 */
struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ_ok(struct LDKC2Tuple_PublicKeyOnionMessageZ o);

/**
 * Creates a new CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ in the error state.
 */
struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ_err(struct LDKSendError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ_is_ok(const struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ.
 */
void CResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ_free(struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ _res);

/**
 * Creates a new CResult_NoneSendErrorZ in the success state.
 */
struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_ok(void);

/**
 * Creates a new CResult_NoneSendErrorZ in the error state.
 */
struct LDKCResult_NoneSendErrorZ CResult_NoneSendErrorZ_err(struct LDKSendError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_NoneSendErrorZ_is_ok(const struct LDKCResult_NoneSendErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_NoneSendErrorZ.
 */
void CResult_NoneSendErrorZ_free(struct LDKCResult_NoneSendErrorZ _res);

/**
 * Creates a new CResult_BlindedPathNoneZ in the success state.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_ok(struct LDKBlindedPath o);

/**
 * Creates a new CResult_BlindedPathNoneZ in the error state.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedPathNoneZ_is_ok(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedPathNoneZ.
 */
void CResult_BlindedPathNoneZ_free(struct LDKCResult_BlindedPathNoneZ _res);

/**
 * Creates a new CResult_BlindedPathNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedPathNoneZ CResult_BlindedPathNoneZ_clone(const struct LDKCResult_BlindedPathNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ in the success state.
 */
struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_ok(struct LDKC2Tuple_BlindedPayInfoBlindedPathZ o);

/**
 * Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ in the error state.
 */
struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_is_ok(const struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ.
 */
void CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_free(struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ _res);

/**
 * Creates a new CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ CResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ_clone(const struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_ok(struct LDKBlindedPath o);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedPathDecodeErrorZ_is_ok(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedPathDecodeErrorZ.
 */
void CResult_BlindedPathDecodeErrorZ_free(struct LDKCResult_BlindedPathDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedPathDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedPathDecodeErrorZ CResult_BlindedPathDecodeErrorZ_clone(const struct LDKCResult_BlindedPathDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ in the success state.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_ok(struct LDKBlindedHop o);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ in the error state.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_BlindedHopDecodeErrorZ_is_ok(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_BlindedHopDecodeErrorZ.
 */
void CResult_BlindedHopDecodeErrorZ_free(struct LDKCResult_BlindedHopDecodeErrorZ _res);

/**
 * Creates a new CResult_BlindedHopDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_BlindedHopDecodeErrorZ CResult_BlindedHopDecodeErrorZ_clone(const struct LDKCResult_BlindedHopDecodeErrorZ *NONNULL_PTR orig);

/**
 * Creates a new CResult_InvoiceErrorDecodeErrorZ in the success state.
 */
struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_ok(struct LDKInvoiceError o);

/**
 * Creates a new CResult_InvoiceErrorDecodeErrorZ in the error state.
 */
struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_err(struct LDKDecodeError e);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_InvoiceErrorDecodeErrorZ_is_ok(const struct LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_InvoiceErrorDecodeErrorZ.
 */
void CResult_InvoiceErrorDecodeErrorZ_free(struct LDKCResult_InvoiceErrorDecodeErrorZ _res);

/**
 * Creates a new CResult_InvoiceErrorDecodeErrorZ which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKCResult_InvoiceErrorDecodeErrorZ CResult_InvoiceErrorDecodeErrorZ_clone(const struct LDKCResult_InvoiceErrorDecodeErrorZ *NONNULL_PTR orig);

/**
 * Constructs a new COption_FilterZ containing a crate::lightning::chain::Filter
 */
struct LDKCOption_FilterZ COption_FilterZ_some(struct LDKFilter o);

/**
 * Constructs a new COption_FilterZ containing nothing
 */
struct LDKCOption_FilterZ COption_FilterZ_none(void);

/**
 * Frees any resources associated with the crate::lightning::chain::Filter, if we are in the Some state
 */
void COption_FilterZ_free(struct LDKCOption_FilterZ _res);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the success state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_ok(struct LDKLockedChannelMonitor o);

/**
 * Creates a new CResult_LockedChannelMonitorNoneZ in the error state.
 */
struct LDKCResult_LockedChannelMonitorNoneZ CResult_LockedChannelMonitorNoneZ_err(void);

/**
 * Checks if the given object is currently in the success state
 */
bool CResult_LockedChannelMonitorNoneZ_is_ok(const struct LDKCResult_LockedChannelMonitorNoneZ *NONNULL_PTR o);

/**
 * Frees any resources used by the CResult_LockedChannelMonitorNoneZ.
 */
void CResult_LockedChannelMonitorNoneZ_free(struct LDKCResult_LockedChannelMonitorNoneZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_OutPointZ_free(struct LDKCVec_OutPointZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_MonitorUpdateIdZ_free(struct LDKCVec_MonitorUpdateIdZ _res);

/**
 * Creates a new tuple which has the same data as `orig`
 * but with all dynamically-allocated buffers duplicated in new buffers.
 */
struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_clone(const struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ *NONNULL_PTR orig);

/**
 * Creates a new C2Tuple_OutPointCVec_MonitorUpdateIdZZ from the contained elements.
 */
struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ C2Tuple_OutPointCVec_MonitorUpdateIdZZ_new(struct LDKOutPoint a, struct LDKCVec_MonitorUpdateIdZ b);

/**
 * Frees any resources used by the C2Tuple_OutPointCVec_MonitorUpdateIdZZ.
 */
void C2Tuple_OutPointCVec_MonitorUpdateIdZZ_free(struct LDKC2Tuple_OutPointCVec_MonitorUpdateIdZZ _res);

/**
 * Frees the buffer pointed to by `data` if `datalen` is non-0.
 */
void CVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ_free(struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ _res);

/**
 * Frees any resources used by the APIError
 */
void APIError_free(struct LDKAPIError this_ptr);

/**
 * Creates a copy of the APIError
 */
struct LDKAPIError APIError_clone(const struct LDKAPIError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new APIMisuseError-variant APIError
 */
struct LDKAPIError APIError_apimisuse_error(struct LDKStr err);

/**
 * Utility method to constructs a new FeeRateTooHigh-variant APIError
 */
struct LDKAPIError APIError_fee_rate_too_high(struct LDKStr err, uint32_t feerate);

/**
 * Utility method to constructs a new InvalidRoute-variant APIError
 */
struct LDKAPIError APIError_invalid_route(struct LDKStr err);

/**
 * Utility method to constructs a new ChannelUnavailable-variant APIError
 */
struct LDKAPIError APIError_channel_unavailable(struct LDKStr err);

/**
 * Utility method to constructs a new MonitorUpdateInProgress-variant APIError
 */
struct LDKAPIError APIError_monitor_update_in_progress(void);

/**
 * Utility method to constructs a new IncompatibleShutdownScript-variant APIError
 */
struct LDKAPIError APIError_incompatible_shutdown_script(struct LDKShutdownScript script);

/**
 * Checks if two APIErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool APIError_eq(const struct LDKAPIError *NONNULL_PTR a, const struct LDKAPIError *NONNULL_PTR b);

/**
 * Serialize the APIError object into a byte array which can be read by APIError_read
 */
struct LDKCVec_u8Z APIError_write(const struct LDKAPIError *NONNULL_PTR obj);

/**
 * Read a APIError from a byte array, created by APIError_write
 */
struct LDKCResult_COption_APIErrorZDecodeErrorZ APIError_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the BigSize, if is_owned is set and inner is non-NULL.
 */
void BigSize_free(struct LDKBigSize this_obj);

uint64_t BigSize_get_a(const struct LDKBigSize *NONNULL_PTR this_ptr);

void BigSize_set_a(struct LDKBigSize *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new BigSize given each field
 */
MUST_USE_RES struct LDKBigSize BigSize_new(uint64_t a_arg);

/**
 * Creates a copy of the BigSize
 */
struct LDKBigSize BigSize_clone(const struct LDKBigSize *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the BigSize.
 */
uint64_t BigSize_hash(const struct LDKBigSize *NONNULL_PTR o);

/**
 * Checks if two BigSizes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BigSize_eq(const struct LDKBigSize *NONNULL_PTR a, const struct LDKBigSize *NONNULL_PTR b);

/**
 * Serialize the BigSize object into a byte array which can be read by BigSize_read
 */
struct LDKCVec_u8Z BigSize_write(const struct LDKBigSize *NONNULL_PTR obj);

/**
 * Read a BigSize from a byte array, created by BigSize_write
 */
struct LDKCResult_BigSizeDecodeErrorZ BigSize_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Hostname, if is_owned is set and inner is non-NULL.
 */
void Hostname_free(struct LDKHostname this_obj);

/**
 * Creates a copy of the Hostname
 */
struct LDKHostname Hostname_clone(const struct LDKHostname *NONNULL_PTR orig);

/**
 * Checks if two Hostnames contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Hostname_eq(const struct LDKHostname *NONNULL_PTR a, const struct LDKHostname *NONNULL_PTR b);

/**
 * Returns the length of the hostname.
 */
MUST_USE_RES uint8_t Hostname_len(const struct LDKHostname *NONNULL_PTR this_arg);

/**
 * Serialize the Hostname object into a byte array which can be read by Hostname_read
 */
struct LDKCVec_u8Z Hostname_write(const struct LDKHostname *NONNULL_PTR obj);

/**
 * Read a Hostname from a byte array, created by Hostname_write
 */
struct LDKCResult_HostnameDecodeErrorZ Hostname_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the TransactionU16LenLimited, if is_owned is set and inner is non-NULL.
 */
void TransactionU16LenLimited_free(struct LDKTransactionU16LenLimited this_obj);

/**
 * Creates a copy of the TransactionU16LenLimited
 */
struct LDKTransactionU16LenLimited TransactionU16LenLimited_clone(const struct LDKTransactionU16LenLimited *NONNULL_PTR orig);

/**
 * Checks if two TransactionU16LenLimiteds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TransactionU16LenLimited_eq(const struct LDKTransactionU16LenLimited *NONNULL_PTR a, const struct LDKTransactionU16LenLimited *NONNULL_PTR b);

/**
 * Constructs a new `TransactionU16LenLimited` from a `Transaction` only if it's consensus-
 * serialized length is <= u16::MAX.
 */
MUST_USE_RES struct LDKCResult_TransactionU16LenLimitedNoneZ TransactionU16LenLimited_new(struct LDKTransaction transaction);

/**
 * Consumes this `TransactionU16LenLimited` and returns its contained `Transaction`.
 */
MUST_USE_RES struct LDKTransaction TransactionU16LenLimited_into_transaction(struct LDKTransactionU16LenLimited this_arg);

/**
 * Serialize the TransactionU16LenLimited object into a byte array which can be read by TransactionU16LenLimited_read
 */
struct LDKCVec_u8Z TransactionU16LenLimited_write(const struct LDKTransactionU16LenLimited *NONNULL_PTR obj);

/**
 * Read a TransactionU16LenLimited from a byte array, created by TransactionU16LenLimited_write
 */
struct LDKCResult_TransactionU16LenLimitedDecodeErrorZ TransactionU16LenLimited_read(struct LDKu8slice ser);

/**
 * Creates a digital signature of a message given a SecretKey, like the node's secret.
 * A receiver knowing the PublicKey (e.g. the node's id) and the message can be sure that the signature was generated by the caller.
 * Signatures are EC recoverable, meaning that given the message and the signature the PublicKey of the signer can be extracted.
 */
struct LDKCResult_StrSecp256k1ErrorZ sign(struct LDKu8slice msg, const uint8_t (*sk)[32]);

/**
 * Recovers the PublicKey of the signer of the message given the message and the signature.
 */
struct LDKCResult_PublicKeySecp256k1ErrorZ recover_pk(struct LDKu8slice msg, struct LDKStr sig);

/**
 * Verifies a message was signed by a PrivateKey that derives to a given PublicKey, given a message, a signature,
 * and the PublicKey.
 */
bool verify(struct LDKu8slice msg, struct LDKStr sig, struct LDKPublicKey pk);

/**
 * Construct the invoice's HRP and signatureless data into a preimage to be hashed.
 */
struct LDKCVec_u8Z construct_invoice_preimage(struct LDKu8slice hrp_bytes, struct LDKCVec_U5Z data_without_signature);

/**
 * Calls the free function if one is set
 */
void KVStore_free(struct LDKKVStore this_ptr);

/**
 * Calls the free function if one is set
 */
void Persister_free(struct LDKPersister this_ptr);

/**
 * Read previously persisted [`ChannelMonitor`]s from the store.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ read_channel_monitors(struct LDKKVStore kv_store, struct LDKEntropySource entropy_source, struct LDKSignerProvider signer_provider);

/**
 * Frees any resources used by the MonitorUpdatingPersister, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdatingPersister_free(struct LDKMonitorUpdatingPersister this_obj);

/**
 * Constructs a new [`MonitorUpdatingPersister`].
 *
 * The `maximum_pending_updates` parameter controls how many updates may be stored before a
 * [`MonitorUpdatingPersister`] consolidates updates by writing a full monitor. Note that
 * consolidation will frequently occur with fewer updates than what you set here; this number
 * is merely the maximum that may be stored. When setting this value, consider that for higher
 * values of `maximum_pending_updates`:
 *
 *   - [`MonitorUpdatingPersister`] will tend to write more [`ChannelMonitorUpdate`]s than
 * [`ChannelMonitor`]s, approaching one [`ChannelMonitor`] write for every
 * `maximum_pending_updates` [`ChannelMonitorUpdate`]s.
 *   - [`MonitorUpdatingPersister`] will issue deletes differently. Lazy deletes will come in
 * \"waves\" for each [`ChannelMonitor`] write. A larger `maximum_pending_updates` means bigger,
 * less frequent \"waves.\"
 *   - [`MonitorUpdatingPersister`] will potentially have more listing to do if you need to run
 * [`MonitorUpdatingPersister::cleanup_stale_updates`].
 */
MUST_USE_RES struct LDKMonitorUpdatingPersister MonitorUpdatingPersister_new(struct LDKKVStore kv_store, struct LDKLogger logger, uint64_t maximum_pending_updates, struct LDKEntropySource entropy_source, struct LDKSignerProvider signer_provider);

/**
 * Reads all stored channel monitors, along with any stored updates for them.
 *
 * It is extremely important that your [`KVStore::read`] implementation uses the
 * [`io::ErrorKind::NotFound`] variant correctly. For more information, please see the
 * documentation for [`MonitorUpdatingPersister`].
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesChannelMonitorZZIOErrorZ MonitorUpdatingPersister_read_all_channel_monitors_with_updates(const struct LDKMonitorUpdatingPersister *NONNULL_PTR this_arg, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator);

/**
 * Read a single channel monitor, along with any stored updates for it.
 *
 * It is extremely important that your [`KVStore::read`] implementation uses the
 * [`io::ErrorKind::NotFound`] variant correctly. For more information, please see the
 * documentation for [`MonitorUpdatingPersister`].
 *
 * For `monitor_key`, channel storage keys be the channel's transaction ID and index, or
 * [`OutPoint`], with an underscore `_` between them. For example, given:
 *
 *   - Transaction ID: `deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef`
 *   - Index: `1`
 *
 * The correct `monitor_key` would be:
 * `deadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeefdeadbeef_1`
 *
 * Loading a large number of monitors will be faster if done in parallel. You can use this
 * function to accomplish this. Take care to limit the number of parallel readers.
 */
MUST_USE_RES struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZIOErrorZ MonitorUpdatingPersister_read_channel_monitor_with_updates(const struct LDKMonitorUpdatingPersister *NONNULL_PTR this_arg, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, struct LDKStr monitor_key);

/**
 * Cleans up stale updates for all monitors.
 *
 * This function works by first listing all monitors, and then for each of them, listing all
 * updates. The updates that have an `update_id` less than or equal to than the stored monitor
 * are deleted. The deletion can either be lazy or non-lazy based on the `lazy` flag; this will
 * be passed to [`KVStore::remove`].
 */
MUST_USE_RES struct LDKCResult_NoneIOErrorZ MonitorUpdatingPersister_cleanup_stale_updates(const struct LDKMonitorUpdatingPersister *NONNULL_PTR this_arg, bool lazy);

/**
 * Constructs a new Persist which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Persist must be freed before this_arg is
 */
struct LDKPersist MonitorUpdatingPersister_as_Persist(const struct LDKMonitorUpdatingPersister *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the UntrustedString, if is_owned is set and inner is non-NULL.
 */
void UntrustedString_free(struct LDKUntrustedString this_obj);

struct LDKStr UntrustedString_get_a(const struct LDKUntrustedString *NONNULL_PTR this_ptr);

void UntrustedString_set_a(struct LDKUntrustedString *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new UntrustedString given each field
 */
MUST_USE_RES struct LDKUntrustedString UntrustedString_new(struct LDKStr a_arg);

/**
 * Creates a copy of the UntrustedString
 */
struct LDKUntrustedString UntrustedString_clone(const struct LDKUntrustedString *NONNULL_PTR orig);

/**
 * Checks if two UntrustedStrings contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UntrustedString_eq(const struct LDKUntrustedString *NONNULL_PTR a, const struct LDKUntrustedString *NONNULL_PTR b);

/**
 * Serialize the UntrustedString object into a byte array which can be read by UntrustedString_read
 */
struct LDKCVec_u8Z UntrustedString_write(const struct LDKUntrustedString *NONNULL_PTR obj);

/**
 * Read a UntrustedString from a byte array, created by UntrustedString_write
 */
struct LDKCResult_UntrustedStringDecodeErrorZ UntrustedString_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PrintableString, if is_owned is set and inner is non-NULL.
 */
void PrintableString_free(struct LDKPrintableString this_obj);

struct LDKStr PrintableString_get_a(const struct LDKPrintableString *NONNULL_PTR this_ptr);

void PrintableString_set_a(struct LDKPrintableString *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new PrintableString given each field
 */
MUST_USE_RES struct LDKPrintableString PrintableString_new(struct LDKStr a_arg);

/**
 * Calls the free function if one is set
 */
void FutureCallback_free(struct LDKFutureCallback this_ptr);

/**
 * Frees any resources used by the Future, if is_owned is set and inner is non-NULL.
 */
void Future_free(struct LDKFuture this_obj);

/**
 * Creates a copy of the Future
 */
struct LDKFuture Future_clone(const struct LDKFuture *NONNULL_PTR orig);

/**
 * Registers a callback to be called upon completion of this future. If the future has already
 * completed, the callback will be called immediately.
 */
void Future_register_callback_fn(const struct LDKFuture *NONNULL_PTR this_arg, struct LDKFutureCallback callback);

/**
 * Waits until this [`Future`] completes.
 */
void Future_wait(struct LDKFuture this_arg);

/**
 * Waits until this [`Future`] completes or the given amount of time has elapsed.
 *
 * Returns true if the [`Future`] completed, false if the time elapsed.
 */
MUST_USE_RES bool Future_wait_timeout(struct LDKFuture this_arg, uint64_t max_wait);

/**
 * Frees any resources used by the Sleeper, if is_owned is set and inner is non-NULL.
 */
void Sleeper_free(struct LDKSleeper this_obj);

/**
 * Constructs a new sleeper from one future, allowing blocking on it.
 */
MUST_USE_RES struct LDKSleeper Sleeper_from_single_future(struct LDKFuture future);

/**
 * Constructs a new sleeper from two futures, allowing blocking on both at once.
 */
MUST_USE_RES struct LDKSleeper Sleeper_from_two_futures(struct LDKFuture fut_a, struct LDKFuture fut_b);

/**
 * Constructs a new sleeper on many futures, allowing blocking on all at once.
 */
MUST_USE_RES struct LDKSleeper Sleeper_new(struct LDKCVec_FutureZ futures);

/**
 * Wait until one of the [`Future`]s registered with this [`Sleeper`] has completed.
 */
void Sleeper_wait(const struct LDKSleeper *NONNULL_PTR this_arg);

/**
 * Wait until one of the [`Future`]s registered with this [`Sleeper`] has completed or the
 * given amount of time has elapsed. Returns true if a [`Future`] completed, false if the time
 * elapsed.
 */
MUST_USE_RES bool Sleeper_wait_timeout(const struct LDKSleeper *NONNULL_PTR this_arg, uint64_t max_wait);

/**
 * Creates a copy of the Level
 */
enum LDKLevel Level_clone(const enum LDKLevel *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Gossip-variant Level
 */
enum LDKLevel Level_gossip(void);

/**
 * Utility method to constructs a new Trace-variant Level
 */
enum LDKLevel Level_trace(void);

/**
 * Utility method to constructs a new Debug-variant Level
 */
enum LDKLevel Level_debug(void);

/**
 * Utility method to constructs a new Info-variant Level
 */
enum LDKLevel Level_info(void);

/**
 * Utility method to constructs a new Warn-variant Level
 */
enum LDKLevel Level_warn(void);

/**
 * Utility method to constructs a new Error-variant Level
 */
enum LDKLevel Level_error(void);

/**
 * Checks if two Levels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Level_eq(const enum LDKLevel *NONNULL_PTR a, const enum LDKLevel *NONNULL_PTR b);

/**
 * Generates a non-cryptographic 64-bit hash of the Level.
 */
uint64_t Level_hash(const enum LDKLevel *NONNULL_PTR o);

/**
 * Returns the most verbose logging level.
 */
MUST_USE_RES enum LDKLevel Level_max(void);

/**
 * Frees any resources used by the Record, if is_owned is set and inner is non-NULL.
 */
void Record_free(struct LDKRecord this_obj);

/**
 * The verbosity level of the message.
 */
enum LDKLevel Record_get_level(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The verbosity level of the message.
 */
void Record_set_level(struct LDKRecord *NONNULL_PTR this_ptr, enum LDKLevel val);

/**
 * The message body.
 */
struct LDKStr Record_get_args(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The message body.
 */
void Record_set_args(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The module path of the message.
 */
struct LDKStr Record_get_module_path(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The module path of the message.
 */
void Record_set_module_path(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The source file containing the message.
 */
struct LDKStr Record_get_file(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The source file containing the message.
 */
void Record_set_file(struct LDKRecord *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The line containing the message.
 */
uint32_t Record_get_line(const struct LDKRecord *NONNULL_PTR this_ptr);

/**
 * The line containing the message.
 */
void Record_set_line(struct LDKRecord *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Creates a copy of the Record
 */
struct LDKRecord Record_clone(const struct LDKRecord *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Logger_free(struct LDKLogger this_ptr);

/**
 * Frees any resources used by the ChannelHandshakeConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeConfig_free(struct LDKChannelHandshakeConfig this_obj);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
 * transaction before operation. If you wish to accept channels with zero confirmations, see
 * [`UserConfig::manually_accept_inbound_channels`] and
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
 *
 * Default value: 6.
 *
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
 */
uint32_t ChannelHandshakeConfig_get_minimum_depth(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Confirmations we will wait for before considering the channel locked in.
 * Applied only for inbound channels (see ChannelHandshakeLimits::max_minimum_depth for the
 * equivalent limit applied to outbound channels).
 *
 * A lower-bound of 1 is applied, requiring all channels to have a confirmed commitment
 * transaction before operation. If you wish to accept channels with zero confirmations, see
 * [`UserConfig::manually_accept_inbound_channels`] and
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`].
 *
 * Default value: 6.
 *
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`ChannelManager::accept_inbound_channel_from_trusted_peer_0conf`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel_from_trusted_peer_0conf
 */
void ChannelHandshakeConfig_set_minimum_depth(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
uint16_t ChannelHandshakeConfig_get_our_to_self_delay(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the number of blocks we require our counterparty to wait to claim their money (ie
 * the number of blocks we have to punish our counterparty if they broadcast a revoked
 * transaction).
 *
 * This is one of the main parameters of our security model. We (or one of our watchtowers) MUST
 * be online to check for revoked transactions on-chain at least once every our_to_self_delay
 * blocks (minus some margin to allow us enough time to broadcast and confirm a transaction,
 * possibly with time in between to RBF the spending transaction).
 *
 * Meanwhile, asking for a too high delay, we bother peer to freeze funds for nothing in
 * case of an honest unilateral channel close, which implicitly decrease the economic value of
 * our channel.
 *
 * Default value: [`BREAKDOWN_TIMEOUT`], we enforce it as a minimum at channel opening so you
 * can tweak config to ask for more security, not less.
 */
void ChannelHandshakeConfig_set_our_to_self_delay(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
uint64_t ChannelHandshakeConfig_get_our_htlc_minimum_msat(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to the smallest value HTLC we will accept to process.
 *
 * This value is sent to our counterparty on channel-open and we close the channel any time
 * our counterparty misbehaves by sending us an HTLC with a value smaller than this.
 *
 * Default value: 1. If the value is less than 1, it is ignored and set to 1, as is required
 * by the protocol.
 */
void ChannelHandshakeConfig_set_our_htlc_minimum_msat(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Sets the percentage of the channel value we will cap the total value of outstanding inbound
 * HTLCs to.
 *
 * This can be set to a value between 1-100, where the value corresponds to the percent of the
 * channel value in whole percentages.
 *
 * Note that:
 * * If configured to another value than the default value 10, any new channels created with
 * the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
 * `ChannelManager`.
 *
 * * This caps the total value for inbound HTLCs in-flight only, and there's currently
 * no way to configure the cap for the total value of outbound HTLCs in-flight.
 *
 * * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
 * are different from the non-HTLC-encumbered funds. This makes this an important knob to
 * restrict exposure to loss due to being offline for too long.
 * See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
 * for more information.
 *
 * Default value: 10.
 * Minimum value: 1, any values less than 1 will be treated as 1 instead.
 * Maximum value: 100, any values larger than 100 will be treated as 100 instead.
 */
uint8_t ChannelHandshakeConfig_get_max_inbound_htlc_value_in_flight_percent_of_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Sets the percentage of the channel value we will cap the total value of outstanding inbound
 * HTLCs to.
 *
 * This can be set to a value between 1-100, where the value corresponds to the percent of the
 * channel value in whole percentages.
 *
 * Note that:
 * * If configured to another value than the default value 10, any new channels created with
 * the non default value will cause versions of LDK prior to 0.0.104 to refuse to read the
 * `ChannelManager`.
 *
 * * This caps the total value for inbound HTLCs in-flight only, and there's currently
 * no way to configure the cap for the total value of outbound HTLCs in-flight.
 *
 * * The requirements for your node being online to ensure the safety of HTLC-encumbered funds
 * are different from the non-HTLC-encumbered funds. This makes this an important knob to
 * restrict exposure to loss due to being offline for too long.
 * See [`ChannelHandshakeConfig::our_to_self_delay`] and [`ChannelConfig::cltv_expiry_delta`]
 * for more information.
 *
 * Default value: 10.
 * Minimum value: 1, any values less than 1 will be treated as 1 instead.
 * Maximum value: 100, any values larger than 100 will be treated as 100 instead.
 */
void ChannelHandshakeConfig_set_max_inbound_htlc_value_in_flight_percent_of_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint8_t val);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
bool ChannelHandshakeConfig_get_negotiate_scid_privacy(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * If set, we attempt to negotiate the `scid_privacy` (referred to as `scid_alias` in the
 * BOLTs) option for outbound private channels. This provides better privacy by not including
 * our real on-chain channel UTXO in each invoice and requiring that our counterparty only
 * relay HTLCs to us using the channel's SCID alias.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.106, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `scid_alias` option; we will simply fall back to a
 * private channel without that option.
 *
 * Ignored if the channel is negotiated to be announced, see
 * [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`] for more.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 */
void ChannelHandshakeConfig_set_negotiate_scid_privacy(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * Default value: false.
 */
bool ChannelHandshakeConfig_get_announced_channel(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * Set to announce the channel publicly and notify all nodes that they can route via this
 * channel.
 *
 * This should only be set to true for nodes which expect to be online reliably.
 *
 * As the node which funds a channel picks this value this will only apply for new outbound
 * channels unless [`ChannelHandshakeLimits::force_announced_channel_preference`] is set.
 *
 * Default value: false.
 */
void ChannelHandshakeConfig_set_announced_channel(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * The upfront key committed is provided from [`SignerProvider::get_shutdown_scriptpubkey`].
 *
 * Default value: true.
 *
 * [`SignerProvider::get_shutdown_scriptpubkey`]: crate::sign::SignerProvider::get_shutdown_scriptpubkey
 */
bool ChannelHandshakeConfig_get_commit_upfront_shutdown_pubkey(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * When set, we commit to an upfront shutdown_pubkey at channel open. If our counterparty
 * supports it, they will then enforce the mutual-close output to us matches what we provided
 * at intialization, preventing us from closing to an alternate pubkey.
 *
 * This is set to true by default to provide a slight increase in security, though ultimately
 * any attacker who is able to take control of a channel can just as easily send the funds via
 * lightning payments, so we never require that our counterparties support this option.
 *
 * The upfront key committed is provided from [`SignerProvider::get_shutdown_scriptpubkey`].
 *
 * Default value: true.
 *
 * [`SignerProvider::get_shutdown_scriptpubkey`]: crate::sign::SignerProvider::get_shutdown_scriptpubkey
 */
void ChannelHandshakeConfig_set_commit_upfront_shutdown_pubkey(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * The Proportion of the channel value to configure as counterparty's channel reserve,
 * i.e., `their_channel_reserve_satoshis` for both outbound and inbound channels.
 *
 * `their_channel_reserve_satoshis` is the minimum balance that the other node has to maintain
 * on their side, at all times.
 * This ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * Channel reserve values greater than 30% could be considered highly unreasonable, since that
 * amount can never be used for payments.
 * Also, if our selected channel reserve for counterparty and counterparty's selected
 * channel reserve for us sum up to equal or greater than channel value, channel negotiations
 * will fail.
 *
 * Note: Versions of LDK earlier than v0.0.104 will fail to read channels with any channel reserve
 * other than the default value.
 *
 * Default value: 1% of channel value, i.e., configured as 10,000 millionths.
 * Minimum value: If the calculated proportional value is less than 1000 sats, it will be treated
 *                as 1000 sats instead, which is a safe implementation-specific lower bound.
 * Maximum value: 1,000,000, any values larger than 1 Million will be treated as 1 Million (or 100%)
 *                instead, although channel negotiations will fail in that case.
 */
uint32_t ChannelHandshakeConfig_get_their_channel_reserve_proportional_millionths(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * The Proportion of the channel value to configure as counterparty's channel reserve,
 * i.e., `their_channel_reserve_satoshis` for both outbound and inbound channels.
 *
 * `their_channel_reserve_satoshis` is the minimum balance that the other node has to maintain
 * on their side, at all times.
 * This ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * Channel reserve values greater than 30% could be considered highly unreasonable, since that
 * amount can never be used for payments.
 * Also, if our selected channel reserve for counterparty and counterparty's selected
 * channel reserve for us sum up to equal or greater than channel value, channel negotiations
 * will fail.
 *
 * Note: Versions of LDK earlier than v0.0.104 will fail to read channels with any channel reserve
 * other than the default value.
 *
 * Default value: 1% of channel value, i.e., configured as 10,000 millionths.
 * Minimum value: If the calculated proportional value is less than 1000 sats, it will be treated
 *                as 1000 sats instead, which is a safe implementation-specific lower bound.
 * Maximum value: 1,000,000, any values larger than 1 Million will be treated as 1 Million (or 100%)
 *                instead, although channel negotiations will fail in that case.
 */
void ChannelHandshakeConfig_set_their_channel_reserve_proportional_millionths(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * If set, we attempt to negotiate the `anchors_zero_fee_htlc_tx`option for all future
 * channels. This feature requires having a reserve of onchain funds readily available to bump
 * transactions in the event of a channel force close to avoid the possibility of losing funds.
 *
 * Note that if you wish accept inbound channels with anchor outputs, you must enable
 * [`UserConfig::manually_accept_inbound_channels`] and manually accept them with
 * [`ChannelManager::accept_inbound_channel`]. This is done to give you the chance to check
 * whether your reserve of onchain funds is enough to cover the fees for all existing and new
 * channels featuring anchor outputs in the event of a force close.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.116, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `anchors_zero_fee_htlc_tx` option; we will simply
 * fall back to a `static_remote_key` channel.
 *
 * LDK will not support the legacy `option_anchors` commitment version due to a discovered
 * vulnerability after its deployment. For more context, see the [`SIGHASH_SINGLE + update_fee
 * Considered Harmful`] mailing list post.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 * [`SIGHASH_SINGLE + update_fee Considered Harmful`]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-September/002796.html
 */
bool ChannelHandshakeConfig_get_negotiate_anchors_zero_fee_htlc_tx(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * If set, we attempt to negotiate the `anchors_zero_fee_htlc_tx`option for all future
 * channels. This feature requires having a reserve of onchain funds readily available to bump
 * transactions in the event of a channel force close to avoid the possibility of losing funds.
 *
 * Note that if you wish accept inbound channels with anchor outputs, you must enable
 * [`UserConfig::manually_accept_inbound_channels`] and manually accept them with
 * [`ChannelManager::accept_inbound_channel`]. This is done to give you the chance to check
 * whether your reserve of onchain funds is enough to cover the fees for all existing and new
 * channels featuring anchor outputs in the event of a force close.
 *
 * If this option is set, channels may be created that will not be readable by LDK versions
 * prior to 0.0.116, causing [`ChannelManager`]'s read method to return a
 * [`DecodeError::InvalidValue`].
 *
 * Note that setting this to true does *not* prevent us from opening channels with
 * counterparties that do not support the `anchors_zero_fee_htlc_tx` option; we will simply
 * fall back to a `static_remote_key` channel.
 *
 * LDK will not support the legacy `option_anchors` commitment version due to a discovered
 * vulnerability after its deployment. For more context, see the [`SIGHASH_SINGLE + update_fee
 * Considered Harmful`] mailing list post.
 *
 * Default value: false. This value is likely to change to true in the future.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`DecodeError::InvalidValue`]: crate::ln::msgs::DecodeError::InvalidValue
 * [`SIGHASH_SINGLE + update_fee Considered Harmful`]: https://lists.linuxfoundation.org/pipermail/lightning-dev/2020-September/002796.html
 */
void ChannelHandshakeConfig_set_negotiate_anchors_zero_fee_htlc_tx(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, bool val);

/**
 * The maximum number of HTLCs in-flight from our counterparty towards us at the same time.
 *
 * Increasing the value can help improve liquidity and stability in
 * routing at the cost of higher long term disk / DB usage.
 *
 * Note: Versions of LDK earlier than v0.0.115 will fail to read channels with a configuration
 * other than the default value.
 *
 * Default value: 50
 * Maximum value: 483, any values larger will be treated as 483.
 *                     This is the BOLT #2 spec limit on `max_accepted_htlcs`.
 */
uint16_t ChannelHandshakeConfig_get_our_max_accepted_htlcs(const struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr);

/**
 * The maximum number of HTLCs in-flight from our counterparty towards us at the same time.
 *
 * Increasing the value can help improve liquidity and stability in
 * routing at the cost of higher long term disk / DB usage.
 *
 * Note: Versions of LDK earlier than v0.0.115 will fail to read channels with a configuration
 * other than the default value.
 *
 * Default value: 50
 * Maximum value: 483, any values larger will be treated as 483.
 *                     This is the BOLT #2 spec limit on `max_accepted_htlcs`.
 */
void ChannelHandshakeConfig_set_our_max_accepted_htlcs(struct LDKChannelHandshakeConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeConfig given each field
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_new(uint32_t minimum_depth_arg, uint16_t our_to_self_delay_arg, uint64_t our_htlc_minimum_msat_arg, uint8_t max_inbound_htlc_value_in_flight_percent_of_channel_arg, bool negotiate_scid_privacy_arg, bool announced_channel_arg, bool commit_upfront_shutdown_pubkey_arg, uint32_t their_channel_reserve_proportional_millionths_arg, bool negotiate_anchors_zero_fee_htlc_tx_arg, uint16_t our_max_accepted_htlcs_arg);

/**
 * Creates a copy of the ChannelHandshakeConfig
 */
struct LDKChannelHandshakeConfig ChannelHandshakeConfig_clone(const struct LDKChannelHandshakeConfig *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeConfig ChannelHandshakeConfig_default(void);

/**
 * Frees any resources used by the ChannelHandshakeLimits, if is_owned is set and inner is non-NULL.
 */
void ChannelHandshakeLimits_free(struct LDKChannelHandshakeLimits this_obj);

/**
 * Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Minimum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 2^24 - 1.
 */
uint64_t ChannelHandshakeLimits_get_max_funding_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Maximum allowed satoshis when a channel is funded. This is supplied by the sender and so
 * only applies to inbound channels.
 *
 * Default value: 2^24 - 1.
 */
void ChannelHandshakeLimits_set_max_funding_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_htlc_minimum_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the minimum size of HTLCs we can send to them. This allows
 * you to limit the maximum minimum-size they can require.
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_htlc_minimum_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint64_t ChannelHandshakeLimits_get_min_max_htlc_value_in_flight_msat(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum value of pending HTLCs to them at any given
 * time to limit their funds exposure to HTLCs. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_htlc_value_in_flight_msat(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
uint64_t ChannelHandshakeLimits_get_max_channel_reserve_satoshis(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node will require we keep a certain amount in direct payment to ourselves at all
 * time, ensuring that we are able to be punished if we broadcast an old state. This allows to
 * you limit the amount which we will have to keep to ourselves (and cannot use for HTLCs).
 *
 * Default value: u64::max_value.
 */
void ChannelHandshakeLimits_set_max_channel_reserve_satoshis(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
uint16_t ChannelHandshakeLimits_get_min_max_accepted_htlcs(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * The remote node sets a limit on the maximum number of pending HTLCs to them at any given
 * time. This allows you to set a minimum such value.
 *
 * Default value: 0.
 */
void ChannelHandshakeLimits_set_min_max_accepted_htlcs(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
uint32_t ChannelHandshakeLimits_get_max_minimum_depth(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Before a channel is usable the funding transaction will need to be confirmed by at least a
 * certain number of blocks, specified by the node which is not the funder (as the funder can
 * assume they aren't going to double-spend themselves).
 * This config allows you to set a limit on the maximum amount of time to wait.
 *
 * Default value: 144, or roughly one day and only applies to outbound channels.
 */
void ChannelHandshakeLimits_set_max_minimum_depth(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether we implicitly trust funding transactions generated by us for our own outbound
 * channels to not be double-spent.
 *
 * If this is set, we assume that our own funding transactions are *never* double-spent, and
 * thus we can trust them without any confirmations. This is generally a reasonable
 * assumption, given we're the only ones who could ever double-spend it (assuming we have sole
 * control of the signing keys).
 *
 * You may wish to un-set this if you allow the user to (or do in an automated fashion)
 * double-spend the funding transaction to RBF with an alternative channel open.
 *
 * This only applies if our counterparty set their confirmations-required value to 0, and we
 * always trust our own funding transaction at 1 confirmation irrespective of this value.
 * Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
 * `true` (0) and `false` (1).
 *
 * Default value: true
 */
bool ChannelHandshakeLimits_get_trust_own_funding_0conf(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Whether we implicitly trust funding transactions generated by us for our own outbound
 * channels to not be double-spent.
 *
 * If this is set, we assume that our own funding transactions are *never* double-spent, and
 * thus we can trust them without any confirmations. This is generally a reasonable
 * assumption, given we're the only ones who could ever double-spend it (assuming we have sole
 * control of the signing keys).
 *
 * You may wish to un-set this if you allow the user to (or do in an automated fashion)
 * double-spend the funding transaction to RBF with an alternative channel open.
 *
 * This only applies if our counterparty set their confirmations-required value to 0, and we
 * always trust our own funding transaction at 1 confirmation irrespective of this value.
 * Thus, this effectively acts as a `min_minimum_depth`, with the only possible values being
 * `true` (0) and `false` (1).
 *
 * Default value: true
 */
void ChannelHandshakeLimits_set_trust_own_funding_0conf(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelHandshakeConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
bool ChannelHandshakeLimits_get_force_announced_channel_preference(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to force an incoming channel to match our announced channel preference in
 * [`ChannelHandshakeConfig::announced_channel`].
 *
 * For a node which is not online reliably, this should be set to true and
 * [`ChannelHandshakeConfig::announced_channel`] set to false, ensuring that no announced (aka public)
 * channels will ever be opened.
 *
 * Default value: true.
 */
void ChannelHandshakeLimits_set_force_announced_channel_preference(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, bool val);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
uint16_t ChannelHandshakeLimits_get_their_to_self_delay(const struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr);

/**
 * Set to the amount of time we're willing to wait to claim money back to us.
 *
 * Not checking this value would be a security issue, as our peer would be able to set it to
 * max relative lock-time (a year) and we would \"lose\" money as it would be locked for a long time.
 *
 * Default value: 2016, which we also enforce as a maximum value so you can tweak config to
 * reduce the loss of having useless locked funds (if your peer accepts)
 */
void ChannelHandshakeLimits_set_their_to_self_delay(struct LDKChannelHandshakeLimits *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new ChannelHandshakeLimits given each field
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_new(uint64_t min_funding_satoshis_arg, uint64_t max_funding_satoshis_arg, uint64_t max_htlc_minimum_msat_arg, uint64_t min_max_htlc_value_in_flight_msat_arg, uint64_t max_channel_reserve_satoshis_arg, uint16_t min_max_accepted_htlcs_arg, uint32_t max_minimum_depth_arg, bool trust_own_funding_0conf_arg, bool force_announced_channel_preference_arg, uint16_t their_to_self_delay_arg);

/**
 * Creates a copy of the ChannelHandshakeLimits
 */
struct LDKChannelHandshakeLimits ChannelHandshakeLimits_clone(const struct LDKChannelHandshakeLimits *NONNULL_PTR orig);

/**
 * Creates a "default" ChannelHandshakeLimits. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelHandshakeLimits ChannelHandshakeLimits_default(void);

/**
 * Frees any resources used by the MaxDustHTLCExposure
 */
void MaxDustHTLCExposure_free(struct LDKMaxDustHTLCExposure this_ptr);

/**
 * Creates a copy of the MaxDustHTLCExposure
 */
struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_clone(const struct LDKMaxDustHTLCExposure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new FixedLimitMsat-variant MaxDustHTLCExposure
 */
struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_fixed_limit_msat(uint64_t a);

/**
 * Utility method to constructs a new FeeRateMultiplier-variant MaxDustHTLCExposure
 */
struct LDKMaxDustHTLCExposure MaxDustHTLCExposure_fee_rate_multiplier(uint64_t a);

/**
 * Checks if two MaxDustHTLCExposures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool MaxDustHTLCExposure_eq(const struct LDKMaxDustHTLCExposure *NONNULL_PTR a, const struct LDKMaxDustHTLCExposure *NONNULL_PTR b);

/**
 * Serialize the MaxDustHTLCExposure object into a byte array which can be read by MaxDustHTLCExposure_read
 */
struct LDKCVec_u8Z MaxDustHTLCExposure_write(const struct LDKMaxDustHTLCExposure *NONNULL_PTR obj);

/**
 * Read a MaxDustHTLCExposure from a byte array, created by MaxDustHTLCExposure_write
 */
struct LDKCResult_MaxDustHTLCExposureDecodeErrorZ MaxDustHTLCExposure_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelConfig, if is_owned is set and inner is non-NULL.
 */
void ChannelConfig_free(struct LDKChannelConfig this_obj);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
uint32_t ChannelConfig_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in millionths of a satoshi) charged per satoshi for payments forwarded outbound
 * over the channel.
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * Default value: 0.
 */
void ChannelConfig_set_forwarding_fee_proportional_millionths(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
uint32_t ChannelConfig_get_forwarding_fee_base_msat(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Amount (in milli-satoshi) charged for payments forwarded outbound over the channel, in
 * excess of [`forwarding_fee_proportional_millionths`].
 * This may be allowed to change at runtime in a later update, however doing so must result in
 * update messages sent to notify all nodes of our updated relay fee.
 *
 * The default value of a single satoshi roughly matches the market rate on many routing nodes
 * as of July 2021. Adjusting it upwards or downwards may change whether nodes route through
 * this node.
 *
 * Default value: 1000.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 */
void ChannelConfig_set_forwarding_fee_base_msat(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
uint16_t ChannelConfig_get_cltv_expiry_delta(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The difference in the CLTV value between incoming HTLCs and an outbound HTLC forwarded over
 * the channel this config applies to.
 *
 * This is analogous to [`ChannelHandshakeConfig::our_to_self_delay`] but applies to in-flight
 * HTLC balance when a channel appears on-chain whereas
 * [`ChannelHandshakeConfig::our_to_self_delay`] applies to the remaining
 * (non-HTLC-encumbered) balance.
 *
 * Thus, for HTLC-encumbered balances to be enforced on-chain when a channel is force-closed,
 * we (or one of our watchtowers) MUST be online to check for broadcast of the current
 * commitment transaction at least once per this many blocks (minus some margin to allow us
 * enough time to broadcast and confirm a transaction, possibly with time in between to RBF
 * the spending transaction).
 *
 * Default value: 72 (12 hours at an average of 6 blocks/hour).
 * Minimum value: [`MIN_CLTV_EXPIRY_DELTA`], any values less than this will be treated as
 *                [`MIN_CLTV_EXPIRY_DELTA`] instead.
 *
 * [`MIN_CLTV_EXPIRY_DELTA`]: crate::ln::channelmanager::MIN_CLTV_EXPIRY_DELTA
 */
void ChannelConfig_set_cltv_expiry_delta(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * The dust threshold for each HTLC is based on the `dust_limit_satoshis` for each party in a
 * channel negotiated throughout the channel open process, along with the fees required to have
 * a broadcastable HTLC spending transaction. When a channel supports anchor outputs
 * (specifically the zero fee HTLC transaction variant), this threshold no longer takes into
 * account the HTLC transaction fee as it is zero. Because of this, you may want to set this
 * value to a fixed limit for channels using anchor outputs, while the fee rate multiplier
 * variant is primarily intended for use with pre-anchor channels.
 *
 * The selected limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel.
 *
 * Default value: [`MaxDustHTLCExposure::FeeRateMultiplier`] with a multiplier of 5000.
 */
struct LDKMaxDustHTLCExposure ChannelConfig_get_max_dust_htlc_exposure(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * Limit our total exposure to in-flight HTLCs which are burned to fees as they are too
 * small to claim on-chain.
 *
 * When an HTLC present in one of our channels is below a \"dust\" threshold, the HTLC will
 * not be claimable on-chain, instead being turned into additional miner fees if either
 * party force-closes the channel. Because the threshold is per-HTLC, our total exposure
 * to such payments may be sustantial if there are many dust HTLCs present when the
 * channel is force-closed.
 *
 * The dust threshold for each HTLC is based on the `dust_limit_satoshis` for each party in a
 * channel negotiated throughout the channel open process, along with the fees required to have
 * a broadcastable HTLC spending transaction. When a channel supports anchor outputs
 * (specifically the zero fee HTLC transaction variant), this threshold no longer takes into
 * account the HTLC transaction fee as it is zero. Because of this, you may want to set this
 * value to a fixed limit for channels using anchor outputs, while the fee rate multiplier
 * variant is primarily intended for use with pre-anchor channels.
 *
 * The selected limit is applied for sent, forwarded, and received HTLCs and limits the total
 * exposure across all three types per-channel.
 *
 * Default value: [`MaxDustHTLCExposure::FeeRateMultiplier`] with a multiplier of 5000.
 */
void ChannelConfig_set_max_dust_htlc_exposure(struct LDKChannelConfig *NONNULL_PTR this_ptr, struct LDKMaxDustHTLCExposure val);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
uint64_t ChannelConfig_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * The additional fee we're willing to pay to avoid waiting for the counterparty's
 * `to_self_delay` to reclaim funds.
 *
 * When we close a channel cooperatively with our counterparty, we negotiate a fee for the
 * closing transaction which both sides find acceptable, ultimately paid by the channel
 * funder/initiator.
 *
 * When we are the funder, because we have to pay the channel closing fee, we bound the
 * acceptable fee by our [`Background`] and [`Normal`] fees, with the upper bound increased by
 * this value. Because the on-chain fee we'd pay to force-close the channel is kept near our
 * [`Normal`] feerate during normal operation, this value represents the additional fee we're
 * willing to pay in order to avoid waiting for our counterparty's to_self_delay to reclaim our
 * funds.
 *
 * When we are not the funder, we require the closing transaction fee pay at least our
 * [`Background`] fee estimate, but allow our counterparty to pay as much fee as they like.
 * Thus, this value is ignored when we are not the funder.
 *
 * Default value: 1000 satoshis.
 *
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 */
void ChannelConfig_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfig *NONNULL_PTR this_ptr, uint64_t val);

/**
 * If set, allows this channel's counterparty to skim an additional fee off this node's inbound
 * HTLCs. Useful for liquidity providers to offload on-chain channel costs to end users.
 *
 * Usage:
 * - The payee will set this option and set its invoice route hints to use [intercept scids]
 *   generated by this channel's counterparty.
 * - The counterparty will get an [`HTLCIntercepted`] event upon payment forward, and call
 *   [`forward_intercepted_htlc`] with less than the amount provided in
 *   [`HTLCIntercepted::expected_outbound_amount_msat`]. The difference between the expected and
 *   actual forward amounts is their fee.
 *
 * # Note
 * It's important for payee wallet software to verify that [`PaymentClaimable::amount_msat`] is
 * as-expected if this feature is activated, otherwise they may lose money!
 * [`PaymentClaimable::counterparty_skimmed_fee_msat`] provides the fee taken by the
 * counterparty.
 *
 * # Note
 * Switching this config flag on may break compatibility with versions of LDK prior to 0.0.116.
 * Unsetting this flag between restarts may lead to payment receive failures.
 *
 * Default value: false.
 *
 * [intercept scids]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`forward_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::forward_intercepted_htlc
 * [`HTLCIntercepted`]: crate::events::Event::HTLCIntercepted
 * [`HTLCIntercepted::expected_outbound_amount_msat`]: crate::events::Event::HTLCIntercepted::expected_outbound_amount_msat
 * [`PaymentClaimable::amount_msat`]: crate::events::Event::PaymentClaimable::amount_msat
 * [`PaymentClaimable::counterparty_skimmed_fee_msat`]: crate::events::Event::PaymentClaimable::counterparty_skimmed_fee_msat
 */
bool ChannelConfig_get_accept_underpaying_htlcs(const struct LDKChannelConfig *NONNULL_PTR this_ptr);

/**
 * If set, allows this channel's counterparty to skim an additional fee off this node's inbound
 * HTLCs. Useful for liquidity providers to offload on-chain channel costs to end users.
 *
 * Usage:
 * - The payee will set this option and set its invoice route hints to use [intercept scids]
 *   generated by this channel's counterparty.
 * - The counterparty will get an [`HTLCIntercepted`] event upon payment forward, and call
 *   [`forward_intercepted_htlc`] with less than the amount provided in
 *   [`HTLCIntercepted::expected_outbound_amount_msat`]. The difference between the expected and
 *   actual forward amounts is their fee.
 *
 * # Note
 * It's important for payee wallet software to verify that [`PaymentClaimable::amount_msat`] is
 * as-expected if this feature is activated, otherwise they may lose money!
 * [`PaymentClaimable::counterparty_skimmed_fee_msat`] provides the fee taken by the
 * counterparty.
 *
 * # Note
 * Switching this config flag on may break compatibility with versions of LDK prior to 0.0.116.
 * Unsetting this flag between restarts may lead to payment receive failures.
 *
 * Default value: false.
 *
 * [intercept scids]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`forward_intercepted_htlc`]: crate::ln::channelmanager::ChannelManager::forward_intercepted_htlc
 * [`HTLCIntercepted`]: crate::events::Event::HTLCIntercepted
 * [`HTLCIntercepted::expected_outbound_amount_msat`]: crate::events::Event::HTLCIntercepted::expected_outbound_amount_msat
 * [`PaymentClaimable::amount_msat`]: crate::events::Event::PaymentClaimable::amount_msat
 * [`PaymentClaimable::counterparty_skimmed_fee_msat`]: crate::events::Event::PaymentClaimable::counterparty_skimmed_fee_msat
 */
void ChannelConfig_set_accept_underpaying_htlcs(struct LDKChannelConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ChannelConfig given each field
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_new(uint32_t forwarding_fee_proportional_millionths_arg, uint32_t forwarding_fee_base_msat_arg, uint16_t cltv_expiry_delta_arg, struct LDKMaxDustHTLCExposure max_dust_htlc_exposure_arg, uint64_t force_close_avoidance_max_fee_satoshis_arg, bool accept_underpaying_htlcs_arg);

/**
 * Creates a copy of the ChannelConfig
 */
struct LDKChannelConfig ChannelConfig_clone(const struct LDKChannelConfig *NONNULL_PTR orig);

/**
 * Checks if two ChannelConfigs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelConfig_eq(const struct LDKChannelConfig *NONNULL_PTR a, const struct LDKChannelConfig *NONNULL_PTR b);

/**
 * Applies the given [`ChannelConfigUpdate`] as a partial update to the [`ChannelConfig`].
 */
void ChannelConfig_apply(struct LDKChannelConfig *NONNULL_PTR this_arg, const struct LDKChannelConfigUpdate *NONNULL_PTR update);

/**
 * Creates a "default" ChannelConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelConfig ChannelConfig_default(void);

/**
 * Serialize the ChannelConfig object into a byte array which can be read by ChannelConfig_read
 */
struct LDKCVec_u8Z ChannelConfig_write(const struct LDKChannelConfig *NONNULL_PTR obj);

/**
 * Read a ChannelConfig from a byte array, created by ChannelConfig_write
 */
struct LDKCResult_ChannelConfigDecodeErrorZ ChannelConfig_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelConfigUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelConfigUpdate_free(struct LDKChannelConfigUpdate this_obj);

struct LDKCOption_u32Z ChannelConfigUpdate_get_forwarding_fee_proportional_millionths(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);

void ChannelConfigUpdate_set_forwarding_fee_proportional_millionths(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

struct LDKCOption_u32Z ChannelConfigUpdate_get_forwarding_fee_base_msat(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);

void ChannelConfigUpdate_set_forwarding_fee_base_msat(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

struct LDKCOption_u16Z ChannelConfigUpdate_get_cltv_expiry_delta(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);

void ChannelConfigUpdate_set_cltv_expiry_delta(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);

/**
 *
 * Returns a copy of the field.
 */
struct LDKCOption_MaxDustHTLCExposureZ ChannelConfigUpdate_get_max_dust_htlc_exposure_msat(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);

void ChannelConfigUpdate_set_max_dust_htlc_exposure_msat(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_MaxDustHTLCExposureZ val);

struct LDKCOption_u64Z ChannelConfigUpdate_get_force_close_avoidance_max_fee_satoshis(const struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr);

void ChannelConfigUpdate_set_force_close_avoidance_max_fee_satoshis(struct LDKChannelConfigUpdate *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new ChannelConfigUpdate given each field
 */
MUST_USE_RES struct LDKChannelConfigUpdate ChannelConfigUpdate_new(struct LDKCOption_u32Z forwarding_fee_proportional_millionths_arg, struct LDKCOption_u32Z forwarding_fee_base_msat_arg, struct LDKCOption_u16Z cltv_expiry_delta_arg, struct LDKCOption_MaxDustHTLCExposureZ max_dust_htlc_exposure_msat_arg, struct LDKCOption_u64Z force_close_avoidance_max_fee_satoshis_arg);

/**
 * Creates a "default" ChannelConfigUpdate. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKChannelConfigUpdate ChannelConfigUpdate_default(void);

/**
 * Frees any resources used by the UserConfig, if is_owned is set and inner is non-NULL.
 */
void UserConfig_free(struct LDKUserConfig this_obj);

/**
 * Channel handshake config that we propose to our counterparty.
 */
struct LDKChannelHandshakeConfig UserConfig_get_channel_handshake_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel handshake config that we propose to our counterparty.
 */
void UserConfig_set_channel_handshake_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeConfig val);

/**
 * Limits applied to our counterparty's proposed channel handshake config settings.
 */
struct LDKChannelHandshakeLimits UserConfig_get_channel_handshake_limits(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Limits applied to our counterparty's proposed channel handshake config settings.
 */
void UserConfig_set_channel_handshake_limits(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelHandshakeLimits val);

/**
 * Channel config which affects behavior during channel lifetime.
 */
struct LDKChannelConfig UserConfig_get_channel_config(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * Channel config which affects behavior during channel lifetime.
 */
void UserConfig_set_channel_config(struct LDKUserConfig *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
bool UserConfig_get_accept_forwards_to_priv_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we will reject any HTLCs which were to be forwarded over private
 * channels. This prevents us from taking on HTLC-forwarding risk when we intend to run as a
 * node which is not online reliably.
 *
 * For nodes which are not online reliably, you should set all channels to *not* be announced
 * (using [`ChannelHandshakeConfig::announced_channel`] and
 * [`ChannelHandshakeLimits::force_announced_channel_preference`]) and set this to false to
 * ensure you are not exposed to any forwarding risk.
 *
 * Note that because you cannot change a channel's announced state after creation, there is no
 * way to disable forwarding on public channels retroactively. Thus, in order to change a node
 * from a publicly-announced forwarding node to a private non-forwarding node you must close
 * all your channels and open new ones. For privacy, you should also change your node_id
 * (swapping all private and public key material for new ones) at that time.
 *
 * Default value: false.
 */
void UserConfig_set_accept_forwards_to_priv_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
bool UserConfig_get_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, we do not accept inbound requests to open a new channel.
 * Default value: true.
 */
void UserConfig_set_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
bool UserConfig_get_manually_accept_inbound_channels(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to true, the user needs to manually accept inbound requests to open a new
 * channel.
 *
 * When set to true, [`Event::OpenChannelRequest`] will be triggered once a request to open a
 * new inbound channel is received through a [`msgs::OpenChannel`] message. In that case, a
 * [`msgs::AcceptChannel`] message will not be sent back to the counterparty node unless the
 * user explicitly chooses to accept the request.
 *
 * Default value: false.
 *
 * [`Event::OpenChannelRequest`]: crate::events::Event::OpenChannelRequest
 * [`msgs::OpenChannel`]: crate::ln::msgs::OpenChannel
 * [`msgs::AcceptChannel`]: crate::ln::msgs::AcceptChannel
 */
void UserConfig_set_manually_accept_inbound_channels(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 *  If this is set to true, LDK will intercept HTLCs that are attempting to be forwarded over
 *  fake short channel ids generated via [`ChannelManager::get_intercept_scid`]. Upon HTLC
 *  intercept, LDK will generate an [`Event::HTLCIntercepted`] which MUST be handled by the user.
 *
 *  Setting this to true may break backwards compatibility with LDK versions < 0.0.113.
 *
 *  Default value: false.
 *
 * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`Event::HTLCIntercepted`]: crate::events::Event::HTLCIntercepted
 */
bool UserConfig_get_accept_intercept_htlcs(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 *  If this is set to true, LDK will intercept HTLCs that are attempting to be forwarded over
 *  fake short channel ids generated via [`ChannelManager::get_intercept_scid`]. Upon HTLC
 *  intercept, LDK will generate an [`Event::HTLCIntercepted`] which MUST be handled by the user.
 *
 *  Setting this to true may break backwards compatibility with LDK versions < 0.0.113.
 *
 *  Default value: false.
 *
 * [`ChannelManager::get_intercept_scid`]: crate::ln::channelmanager::ChannelManager::get_intercept_scid
 * [`Event::HTLCIntercepted`]: crate::events::Event::HTLCIntercepted
 */
void UserConfig_set_accept_intercept_htlcs(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * If this is set to false, when receiving a keysend payment we'll fail it if it has multiple
 * parts. If this is set to true, we'll accept the payment.
 *
 * Setting this to true will break backwards compatibility upon downgrading to an LDK
 * version < 0.0.116 while receiving an MPP keysend. If we have already received an MPP
 * keysend, downgrading will cause us to fail to deserialize [`ChannelManager`].
 *
 * Default value: false.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
bool UserConfig_get_accept_mpp_keysend(const struct LDKUserConfig *NONNULL_PTR this_ptr);

/**
 * If this is set to false, when receiving a keysend payment we'll fail it if it has multiple
 * parts. If this is set to true, we'll accept the payment.
 *
 * Setting this to true will break backwards compatibility upon downgrading to an LDK
 * version < 0.0.116 while receiving an MPP keysend. If we have already received an MPP
 * keysend, downgrading will cause us to fail to deserialize [`ChannelManager`].
 *
 * Default value: false.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void UserConfig_set_accept_mpp_keysend(struct LDKUserConfig *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new UserConfig given each field
 */
MUST_USE_RES struct LDKUserConfig UserConfig_new(struct LDKChannelHandshakeConfig channel_handshake_config_arg, struct LDKChannelHandshakeLimits channel_handshake_limits_arg, struct LDKChannelConfig channel_config_arg, bool accept_forwards_to_priv_channels_arg, bool accept_inbound_channels_arg, bool manually_accept_inbound_channels_arg, bool accept_intercept_htlcs_arg, bool accept_mpp_keysend_arg);

/**
 * Creates a copy of the UserConfig
 */
struct LDKUserConfig UserConfig_clone(const struct LDKUserConfig *NONNULL_PTR orig);

/**
 * Creates a "default" UserConfig. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKUserConfig UserConfig_default(void);

/**
 * Frees any resources used by the BestBlock, if is_owned is set and inner is non-NULL.
 */
void BestBlock_free(struct LDKBestBlock this_obj);

/**
 * Creates a copy of the BestBlock
 */
struct LDKBestBlock BestBlock_clone(const struct LDKBestBlock *NONNULL_PTR orig);

/**
 * Checks if two BestBlocks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BestBlock_eq(const struct LDKBestBlock *NONNULL_PTR a, const struct LDKBestBlock *NONNULL_PTR b);

/**
 * Constructs a `BestBlock` that represents the genesis block at height 0 of the given
 * network.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_from_network(enum LDKNetwork network);

/**
 * Returns a `BestBlock` as identified by the given block hash and height.
 */
MUST_USE_RES struct LDKBestBlock BestBlock_new(struct LDKThirtyTwoBytes block_hash, uint32_t height);

/**
 * Returns the best block hash.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BestBlock_block_hash(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Returns the best block height.
 */
MUST_USE_RES uint32_t BestBlock_height(const struct LDKBestBlock *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void Listen_free(struct LDKListen this_ptr);

/**
 * Calls the free function if one is set
 */
void Confirm_free(struct LDKConfirm this_ptr);

/**
 * Creates a copy of the ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_clone(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Completed-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_completed(void);

/**
 * Utility method to constructs a new InProgress-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_in_progress(void);

/**
 * Utility method to constructs a new UnrecoverableError-variant ChannelMonitorUpdateStatus
 */
enum LDKChannelMonitorUpdateStatus ChannelMonitorUpdateStatus_unrecoverable_error(void);

/**
 * Checks if two ChannelMonitorUpdateStatuss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ChannelMonitorUpdateStatus_eq(const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR a, const enum LDKChannelMonitorUpdateStatus *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void Watch_free(struct LDKWatch this_ptr);

/**
 * Calls the free function if one is set
 */
void Filter_free(struct LDKFilter this_ptr);

/**
 * Frees any resources used by the WatchedOutput, if is_owned is set and inner is non-NULL.
 */
void WatchedOutput_free(struct LDKWatchedOutput this_obj);

/**
 * First block where the transaction output may have been spent.
 */
struct LDKCOption_ThirtyTwoBytesZ WatchedOutput_get_block_hash(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * First block where the transaction output may have been spent.
 */
void WatchedOutput_set_block_hash(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCOption_ThirtyTwoBytesZ val);

/**
 * Outpoint identifying the transaction output.
 */
struct LDKOutPoint WatchedOutput_get_outpoint(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Outpoint identifying the transaction output.
 */
void WatchedOutput_set_outpoint(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Spending condition of the transaction output.
 */
struct LDKu8slice WatchedOutput_get_script_pubkey(const struct LDKWatchedOutput *NONNULL_PTR this_ptr);

/**
 * Spending condition of the transaction output.
 */
void WatchedOutput_set_script_pubkey(struct LDKWatchedOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new WatchedOutput given each field
 */
MUST_USE_RES struct LDKWatchedOutput WatchedOutput_new(struct LDKCOption_ThirtyTwoBytesZ block_hash_arg, struct LDKOutPoint outpoint_arg, struct LDKCVec_u8Z script_pubkey_arg);

/**
 * Creates a copy of the WatchedOutput
 */
struct LDKWatchedOutput WatchedOutput_clone(const struct LDKWatchedOutput *NONNULL_PTR orig);

/**
 * Checks if two WatchedOutputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool WatchedOutput_eq(const struct LDKWatchedOutput *NONNULL_PTR a, const struct LDKWatchedOutput *NONNULL_PTR b);

/**
 * Generates a non-cryptographic 64-bit hash of the WatchedOutput.
 */
uint64_t WatchedOutput_hash(const struct LDKWatchedOutput *NONNULL_PTR o);

/**
 * Calls the free function if one is set
 */
void BroadcasterInterface_free(struct LDKBroadcasterInterface this_ptr);

/**
 * Creates a copy of the ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_clone(const enum LDKConfirmationTarget *NONNULL_PTR orig);

/**
 * Utility method to constructs a new MempoolMinimum-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_mempool_minimum(void);

/**
 * Utility method to constructs a new Background-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_background(void);

/**
 * Utility method to constructs a new Normal-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_normal(void);

/**
 * Utility method to constructs a new HighPriority-variant ConfirmationTarget
 */
enum LDKConfirmationTarget ConfirmationTarget_high_priority(void);

/**
 * Generates a non-cryptographic 64-bit hash of the ConfirmationTarget.
 */
uint64_t ConfirmationTarget_hash(const enum LDKConfirmationTarget *NONNULL_PTR o);

/**
 * Checks if two ConfirmationTargets contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ConfirmationTarget_eq(const enum LDKConfirmationTarget *NONNULL_PTR a, const enum LDKConfirmationTarget *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void FeeEstimator_free(struct LDKFeeEstimator this_ptr);

/**
 * Frees any resources used by the MonitorUpdateId, if is_owned is set and inner is non-NULL.
 */
void MonitorUpdateId_free(struct LDKMonitorUpdateId this_obj);

/**
 * Creates a copy of the MonitorUpdateId
 */
struct LDKMonitorUpdateId MonitorUpdateId_clone(const struct LDKMonitorUpdateId *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the MonitorUpdateId.
 */
uint64_t MonitorUpdateId_hash(const struct LDKMonitorUpdateId *NONNULL_PTR o);

/**
 * Checks if two MonitorUpdateIds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MonitorUpdateId_eq(const struct LDKMonitorUpdateId *NONNULL_PTR a, const struct LDKMonitorUpdateId *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void Persist_free(struct LDKPersist this_ptr);

/**
 * Frees any resources used by the LockedChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void LockedChannelMonitor_free(struct LDKLockedChannelMonitor this_obj);

/**
 * Frees any resources used by the ChainMonitor, if is_owned is set and inner is non-NULL.
 */
void ChainMonitor_free(struct LDKChainMonitor this_obj);

/**
 * Creates a new `ChainMonitor` used to watch on-chain activity pertaining to channels.
 *
 * When an optional chain source implementing [`chain::Filter`] is provided, the chain monitor
 * will call back to it indicating transactions and outputs of interest. This allows clients to
 * pre-filter blocks or only fetch blocks matching a compact filter. Otherwise, clients may
 * always need to fetch full blocks absent another means for determining which blocks contain
 * transactions relevant to the watched channels.
 */
MUST_USE_RES struct LDKChainMonitor ChainMonitor_new(struct LDKCOption_FilterZ chain_source, struct LDKBroadcasterInterface broadcaster, struct LDKLogger logger, struct LDKFeeEstimator feeest, struct LDKPersist persister);

/**
 * Gets the balances in the contained [`ChannelMonitor`]s which are claimable on-chain or
 * claims which are awaiting confirmation.
 *
 * Includes the balances from each [`ChannelMonitor`] *except* those included in
 * `ignored_channels`, allowing you to filter out balances from channels which are still open
 * (and whose balance should likely be pulled from the [`ChannelDetails`]).
 *
 * See [`ChannelMonitor::get_claimable_balances`] for more details on the exact criteria for
 * inclusion in the return value.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChainMonitor_get_claimable_balances(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKCVec_ChannelDetailsZ ignored_channels);

/**
 * Gets the [`LockedChannelMonitor`] for a given funding outpoint, returning an `Err` if no
 * such [`ChannelMonitor`] is currently being monitored for.
 *
 * Note that the result holds a mutex over our monitor set, and should not be held
 * indefinitely.
 */
MUST_USE_RES struct LDKCResult_LockedChannelMonitorNoneZ ChainMonitor_get_monitor(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo);

/**
 * Lists the funding outpoint of each [`ChannelMonitor`] being monitored.
 *
 * Note that [`ChannelMonitor`]s are not removed when a channel is closed as they are always
 * monitoring for on-chain state resolutions.
 */
MUST_USE_RES struct LDKCVec_OutPointZ ChainMonitor_list_monitors(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Lists the pending updates for each [`ChannelMonitor`] (by `OutPoint` being monitored).
 */
MUST_USE_RES struct LDKCVec_C2Tuple_OutPointCVec_MonitorUpdateIdZZZ ChainMonitor_list_pending_monitor_updates(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Indicates the persistence of a [`ChannelMonitor`] has completed after
 * [`ChannelMonitorUpdateStatus::InProgress`] was returned from an update operation.
 *
 * Thus, the anticipated use is, at a high level:
 *  1) This [`ChainMonitor`] calls [`Persist::update_persisted_channel`] which stores the
 *     update to disk and begins updating any remote (e.g. watchtower/backup) copies,
 *     returning [`ChannelMonitorUpdateStatus::InProgress`],
 *  2) once all remote copies are updated, you call this function with the
 *     `completed_update_id` that completed, and once all pending updates have completed the
 *     channel will be re-enabled.
 *
 * Returns an [`APIError::APIMisuseError`] if `funding_txo` does not match any currently
 * registered [`ChannelMonitor`]s.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChainMonitor_channel_monitor_updated(const struct LDKChainMonitor *NONNULL_PTR this_arg, struct LDKOutPoint funding_txo, struct LDKMonitorUpdateId completed_update_id);

/**
 * Gets a [`Future`] that completes when an event is available either via
 * [`chain::Watch::release_pending_monitor_events`] or
 * [`EventsProvider::process_pending_events`].
 *
 * Note that callbacks registered on the [`Future`] MUST NOT call back into this
 * [`ChainMonitor`] and should instead register actions to be taken later.
 *
 * [`EventsProvider::process_pending_events`]: crate::events::EventsProvider::process_pending_events
 */
MUST_USE_RES struct LDKFuture ChainMonitor_get_update_future(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
 * crucial in preventing certain classes of pinning attacks, detecting substantial mempool
 * feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
 * invoking this every 30 seconds, or lower if running in an environment with spotty
 * connections, like on mobile.
 */
void ChainMonitor_rebroadcast_pending_claims(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChainMonitor_as_Listen(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChainMonitor_as_Confirm(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new Watch which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Watch must be freed before this_arg is
 */
struct LDKWatch ChainMonitor_as_Watch(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChainMonitor_as_EventsProvider(const struct LDKChainMonitor *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitorUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitorUpdate_free(struct LDKChannelMonitorUpdate this_obj);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with two exceptions specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instances we allow where update_id values are not strictly increasing have a
 * special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. This update ID is used for updates that
 * will force close the channel by broadcasting the latest commitment transaction or
 * special post-force-close updates, like providing preimages necessary to claim outputs on the
 * broadcast commitment transaction. See its docs for more details.
 *
 * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
 */
uint64_t ChannelMonitorUpdate_get_update_id(const struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr);

/**
 * The sequence number of this update. Updates *must* be replayed in-order according to this
 * sequence number (and updates may panic if they are not). The update_id values are strictly
 * increasing and increase by one for each new update, with two exceptions specified below.
 *
 * This sequence number is also used to track up to which points updates which returned
 * [`ChannelMonitorUpdateStatus::InProgress`] have been applied to all copies of a given
 * ChannelMonitor when ChannelManager::channel_monitor_updated is called.
 *
 * The only instances we allow where update_id values are not strictly increasing have a
 * special update ID of [`CLOSED_CHANNEL_UPDATE_ID`]. This update ID is used for updates that
 * will force close the channel by broadcasting the latest commitment transaction or
 * special post-force-close updates, like providing preimages necessary to claim outputs on the
 * broadcast commitment transaction. See its docs for more details.
 *
 * [`ChannelMonitorUpdateStatus::InProgress`]: super::ChannelMonitorUpdateStatus::InProgress
 */
void ChannelMonitorUpdate_set_update_id(struct LDKChannelMonitorUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the ChannelMonitorUpdate
 */
struct LDKChannelMonitorUpdate ChannelMonitorUpdate_clone(const struct LDKChannelMonitorUpdate *NONNULL_PTR orig);

/**
 * Checks if two ChannelMonitorUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelMonitorUpdate_eq(const struct LDKChannelMonitorUpdate *NONNULL_PTR a, const struct LDKChannelMonitorUpdate *NONNULL_PTR b);

/**
 * Serialize the ChannelMonitorUpdate object into a byte array which can be read by ChannelMonitorUpdate_read
 */
struct LDKCVec_u8Z ChannelMonitorUpdate_write(const struct LDKChannelMonitorUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelMonitorUpdate from a byte array, created by ChannelMonitorUpdate_write
 */
struct LDKCResult_ChannelMonitorUpdateDecodeErrorZ ChannelMonitorUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MonitorEvent
 */
void MonitorEvent_free(struct LDKMonitorEvent this_ptr);

/**
 * Creates a copy of the MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_clone(const struct LDKMonitorEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new HTLCEvent-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_htlcevent(struct LDKHTLCUpdate a);

/**
 * Utility method to constructs a new HolderForceClosed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_holder_force_closed(struct LDKOutPoint a);

/**
 * Utility method to constructs a new Completed-variant MonitorEvent
 */
struct LDKMonitorEvent MonitorEvent_completed(struct LDKOutPoint funding_txo, uint64_t monitor_update_id);

/**
 * Checks if two MonitorEvents contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool MonitorEvent_eq(const struct LDKMonitorEvent *NONNULL_PTR a, const struct LDKMonitorEvent *NONNULL_PTR b);

/**
 * Serialize the MonitorEvent object into a byte array which can be read by MonitorEvent_read
 */
struct LDKCVec_u8Z MonitorEvent_write(const struct LDKMonitorEvent *NONNULL_PTR obj);

/**
 * Read a MonitorEvent from a byte array, created by MonitorEvent_write
 */
struct LDKCResult_COption_MonitorEventZDecodeErrorZ MonitorEvent_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the HTLCUpdate, if is_owned is set and inner is non-NULL.
 */
void HTLCUpdate_free(struct LDKHTLCUpdate this_obj);

/**
 * Creates a copy of the HTLCUpdate
 */
struct LDKHTLCUpdate HTLCUpdate_clone(const struct LDKHTLCUpdate *NONNULL_PTR orig);

/**
 * Checks if two HTLCUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool HTLCUpdate_eq(const struct LDKHTLCUpdate *NONNULL_PTR a, const struct LDKHTLCUpdate *NONNULL_PTR b);

/**
 * Serialize the HTLCUpdate object into a byte array which can be read by HTLCUpdate_read
 */
struct LDKCVec_u8Z HTLCUpdate_write(const struct LDKHTLCUpdate *NONNULL_PTR obj);

/**
 * Read a HTLCUpdate from a byte array, created by HTLCUpdate_write
 */
struct LDKCResult_HTLCUpdateDecodeErrorZ HTLCUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Balance
 */
void Balance_free(struct LDKBalance this_ptr);

/**
 * Creates a copy of the Balance
 */
struct LDKBalance Balance_clone(const struct LDKBalance *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ClaimableOnChannelClose-variant Balance
 */
struct LDKBalance Balance_claimable_on_channel_close(uint64_t amount_satoshis);

/**
 * Utility method to constructs a new ClaimableAwaitingConfirmations-variant Balance
 */
struct LDKBalance Balance_claimable_awaiting_confirmations(uint64_t amount_satoshis, uint32_t confirmation_height);

/**
 * Utility method to constructs a new ContentiousClaimable-variant Balance
 */
struct LDKBalance Balance_contentious_claimable(uint64_t amount_satoshis, uint32_t timeout_height, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Utility method to constructs a new MaybeTimeoutClaimableHTLC-variant Balance
 */
struct LDKBalance Balance_maybe_timeout_claimable_htlc(uint64_t amount_satoshis, uint32_t claimable_height, struct LDKThirtyTwoBytes payment_hash);

/**
 * Utility method to constructs a new MaybePreimageClaimableHTLC-variant Balance
 */
struct LDKBalance Balance_maybe_preimage_claimable_htlc(uint64_t amount_satoshis, uint32_t expiry_height, struct LDKThirtyTwoBytes payment_hash);

/**
 * Utility method to constructs a new CounterpartyRevokedOutputClaimable-variant Balance
 */
struct LDKBalance Balance_counterparty_revoked_output_claimable(uint64_t amount_satoshis);

/**
 * Checks if two Balances contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Balance_eq(const struct LDKBalance *NONNULL_PTR a, const struct LDKBalance *NONNULL_PTR b);

/**
 * The amount claimable, in satoshis. This excludes balances that we are unsure if we are able
 * to claim, this is because we are waiting for a preimage or for a timeout to expire. For more
 * information on these balances see [`Balance::MaybeTimeoutClaimableHTLC`] and
 * [`Balance::MaybePreimageClaimableHTLC`].
 *
 * On-chain fees required to claim the balance are not included in this amount.
 */
MUST_USE_RES uint64_t Balance_claimable_amount_satoshis(const struct LDKBalance *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelMonitor, if is_owned is set and inner is non-NULL.
 */
void ChannelMonitor_free(struct LDKChannelMonitor this_obj);

/**
 * Creates a copy of the ChannelMonitor
 */
struct LDKChannelMonitor ChannelMonitor_clone(const struct LDKChannelMonitor *NONNULL_PTR orig);

/**
 * Serialize the ChannelMonitor object into a byte array which can be read by ChannelMonitor_read
 */
struct LDKCVec_u8Z ChannelMonitor_write(const struct LDKChannelMonitor *NONNULL_PTR obj);

/**
 * Updates a ChannelMonitor on the basis of some new information provided by the Channel
 * itself.
 *
 * panics if the given update is not the next update by update_id.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelMonitor_update_monitor(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR updates, const struct LDKBroadcasterInterface *NONNULL_PTR broadcaster, const struct LDKFeeEstimator *NONNULL_PTR fee_estimator, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Gets the update_id from the latest ChannelMonitorUpdate which was applied to this
 * ChannelMonitor.
 */
MUST_USE_RES uint64_t ChannelMonitor_get_latest_update_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the funding transaction outpoint of the channel this ChannelMonitor is monitoring for.
 */
MUST_USE_RES struct LDKC2Tuple_OutPointCVec_u8ZZ ChannelMonitor_get_funding_txo(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets a list of txids, with their output scripts (in the order they appear in the
 * transaction), which we must learn about spends of via block_connected().
 */
MUST_USE_RES struct LDKCVec_C2Tuple_ThirtyTwoBytesCVec_C2Tuple_u32CVec_u8ZZZZZ ChannelMonitor_get_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Loads the funding txo and outputs to watch into the given `chain::Filter` by repeatedly
 * calling `chain::Filter::register_output` and `chain::Filter::register_tx` until all outputs
 * have been registered.
 */
void ChannelMonitor_load_outputs_to_watch(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKFilter *NONNULL_PTR filter);

/**
 * Get the list of HTLCs who's status has been updated on chain. This should be called by
 * ChannelManager via [`chain::Watch::release_pending_monitor_events`].
 */
MUST_USE_RES struct LDKCVec_MonitorEventZ ChannelMonitor_get_and_clear_pending_monitor_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Processes [`SpendableOutputs`] events produced from each [`ChannelMonitor`] upon maturity.
 *
 * For channels featuring anchor outputs, this method will also process [`BumpTransaction`]
 * events produced from each [`ChannelMonitor`] while there is a balance to claim onchain
 * within each channel. As the confirmation of a commitment transaction may be critical to the
 * safety of funds, we recommend invoking this every 30 seconds, or lower if running in an
 * environment with spotty connections, like on mobile.
 *
 * An [`EventHandler`] may safely call back to the provider, though this shouldn't be needed in
 * order to handle these events.
 *
 * [`SpendableOutputs`]: crate::events::Event::SpendableOutputs
 * [`BumpTransaction`]: crate::events::Event::BumpTransaction
 */
void ChannelMonitor_process_pending_events(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKEventHandler *NONNULL_PTR handler);

/**
 * Gets the counterparty's initial commitment transaction. The returned commitment
 * transaction is unsigned. This is intended to be called during the initial persistence of
 * the monitor (inside an implementation of [`Persist::persist_new_channel`]), to allow for
 * watchtowers in the persistence pipeline to have enough data to form justice transactions.
 *
 * This is similar to [`Self::counterparty_commitment_txs_from_update`], except
 * that for the initial commitment transaction, we don't have a corresponding update.
 *
 * This will only return `Some` for channel monitors that have been created after upgrading
 * to LDK 0.0.117+.
 *
 * [`Persist::persist_new_channel`]: crate::chain::chainmonitor::Persist::persist_new_channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCommitmentTransaction ChannelMonitor_initial_counterparty_commitment_tx(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets all of the counterparty commitment transactions provided by the given update. This
 * may be empty if the update doesn't include any new counterparty commitments. Returned
 * commitment transactions are unsigned.
 *
 * This is provided so that watchtower clients in the persistence pipeline are able to build
 * justice transactions for each counterparty commitment upon each update. It's intended to be
 * used within an implementation of [`Persist::update_persisted_channel`], which is provided
 * with a monitor and an update. Once revoked, signing a justice transaction can be done using
 * [`Self::sign_to_local_justice_tx`].
 *
 * It is expected that a watchtower client may use this method to retrieve the latest counterparty
 * commitment transaction(s), and then hold the necessary data until a later update in which
 * the monitor has been updated with the corresponding revocation data, at which point the
 * monitor can sign the justice transaction.
 *
 * This will only return a non-empty list for monitor updates that have been created after
 * upgrading to LDK 0.0.117+. Note that no restriction lies on the monitors themselves, which
 * may have been created prior to upgrading.
 *
 * [`Persist::update_persisted_channel`]: crate::chain::chainmonitor::Persist::update_persisted_channel
 */
MUST_USE_RES struct LDKCVec_CommitmentTransactionZ ChannelMonitor_counterparty_commitment_txs_from_update(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKChannelMonitorUpdate *NONNULL_PTR update);

/**
 * Wrapper around [`EcdsaChannelSigner::sign_justice_revoked_output`] to make
 * signing the justice transaction easier for implementors of
 * [`chain::chainmonitor::Persist`]. On success this method returns the provided transaction
 * signing the input at `input_idx`. This method will only produce a valid signature for
 * a transaction spending the `to_local` output of a commitment transaction, i.e. this cannot
 * be used for revoked HTLC outputs.
 *
 * `Value` is the value of the output being spent by the input at `input_idx`, committed
 * in the BIP 143 signature.
 *
 * This method will only succeed if this monitor has received the revocation secret for the
 * provided `commitment_number`. If a commitment number is provided that does not correspond
 * to the commitment transaction being revoked, this will return a signed transaction, but
 * the signature will not be valid.
 *
 * [`EcdsaChannelSigner::sign_justice_revoked_output`]: crate::sign::EcdsaChannelSigner::sign_justice_revoked_output
 * [`Persist`]: crate::chain::chainmonitor::Persist
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ ChannelMonitor_sign_to_local_justice_tx(const struct LDKChannelMonitor *NONNULL_PTR this_arg, struct LDKTransaction justice_tx, uintptr_t input_idx, uint64_t value, uint64_t commitment_number);

/**
 * Gets the `node_id` of the counterparty for this channel.
 *
 * Will be `None` for channels constructed on LDK versions prior to 0.0.110 and always `Some`
 * otherwise.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey ChannelMonitor_get_counterparty_node_id(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Used by [`ChannelManager`] deserialization to broadcast the latest holder state if its copy
 * of the channel state was out-of-date.
 *
 * You may also use this to broadcast the latest local commitment transaction, either because
 * a monitor update failed or because we've fallen behind (i.e. we've received proof that our
 * counterparty side knows a revocation secret we gave them that they shouldn't know).
 *
 * Broadcasting these transactions in the second case is UNSAFE, as they allow counterparty
 * side to punish you. Nevertheless you may want to broadcast them if counterparty doesn't
 * close channel with their commitment transaction after a substantial amount of time. Best
 * may be to contact the other node operator out-of-band to coordinate other options available
 * to you.
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCVec_TransactionZ ChannelMonitor_get_latest_holder_commitment_txn(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const struct LDKLogger *NONNULL_PTR logger);

/**
 * Processes transactions in a newly connected block, which may result in any of the following:
 * - update the monitor's state against resolved HTLCs
 * - punish the counterparty in the case of seeing a revoked commitment transaction
 * - force close the channel and claim/timeout incoming/outgoing HTLCs if near expiration
 * - detect settled outputs for later spending
 * - schedule and bump any in-flight claims
 *
 * Returns any new outputs to watch from `txdata`; after called, these are also included in
 * [`get_outputs_to_watch`].
 *
 * [`get_outputs_to_watch`]: #method.get_outputs_to_watch
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_block_connected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Determines if the disconnected block contained any transactions of interest and updates
 * appropriately.
 */
void ChannelMonitor_block_disconnected(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes transactions confirmed in a block with the given header and height, returning new
 * outputs to watch. See [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_transactions_confirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], struct LDKCVec_C2Tuple_usizeTransactionZZ txdata, uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Processes a transaction that was reorganized out of the chain.
 *
 * Used instead of [`block_disconnected`] by clients that are notified of transactions rather
 * than blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_disconnected`]: Self::block_disconnected
 */
void ChannelMonitor_transaction_unconfirmed(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*txid)[32], struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Updates the monitor with the current best chain tip, returning new outputs to watch. See
 * [`block_connected`] for details.
 *
 * Used instead of [`block_connected`] by clients that are notified of transactions rather than
 * blocks. See [`chain::Confirm`] for calling expectations.
 *
 * [`block_connected`]: Self::block_connected
 */
MUST_USE_RES struct LDKCVec_TransactionOutputsZ ChannelMonitor_best_block_updated(const struct LDKChannelMonitor *NONNULL_PTR this_arg, const uint8_t (*header)[80], uint32_t height, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Returns the set of txids that should be monitored for re-organization out of the chain.
 */
MUST_USE_RES struct LDKCVec_C2Tuple_ThirtyTwoBytesCOption_ThirtyTwoBytesZZZ ChannelMonitor_get_relevant_txids(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelMonitor_current_best_block(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Triggers rebroadcasts/fee-bumps of pending claims from a force-closed channel. This is
 * crucial in preventing certain classes of pinning attacks, detecting substantial mempool
 * feerate changes between blocks, and ensuring reliability if broadcasting fails. We recommend
 * invoking this every 30 seconds, or lower if running in an environment with spotty
 * connections, like on mobile.
 */
void ChannelMonitor_rebroadcast_pending_claims(const struct LDKChannelMonitor *NONNULL_PTR this_arg, struct LDKBroadcasterInterface broadcaster, struct LDKFeeEstimator fee_estimator, struct LDKLogger logger);

/**
 * Returns the descriptors for relevant outputs (i.e., those that we can spend) within the
 * transaction if they exist and the transaction has at least [`ANTI_REORG_DELAY`]
 * confirmations. For [`SpendableOutputDescriptor::DelayedPaymentOutput`] descriptors to be
 * returned, the transaction must have at least `max(ANTI_REORG_DELAY, to_self_delay)`
 * confirmations.
 *
 * Descriptors returned by this method are primarily exposed via [`Event::SpendableOutputs`]
 * once they are no longer under reorg risk. This method serves as a way to retrieve these
 * descriptors at a later time, either for historical purposes, or to replay any
 * missed/unhandled descriptors. For the purpose of gathering historical records, if the
 * channel close has fully resolved (i.e., [`ChannelMonitor::get_claimable_balances`] returns
 * an empty set), you can retrieve all spendable outputs by providing all descendant spending
 * transactions starting from the channel's funding transaction and going down three levels.
 *
 * `tx` is a transaction we'll scan the outputs of. Any transaction can be provided. If any
 * outputs which can be spent by us are found, at least one descriptor is returned.
 *
 * `confirmation_height` must be the height of the block in which `tx` was included in.
 */
MUST_USE_RES struct LDKCVec_SpendableOutputDescriptorZ ChannelMonitor_get_spendable_outputs(const struct LDKChannelMonitor *NONNULL_PTR this_arg, struct LDKTransaction tx, uint32_t confirmation_height);

/**
 * Gets the balances in this channel which are either claimable by us if we were to
 * force-close the channel now or which are claimable on-chain (possibly awaiting
 * confirmation).
 *
 * Any balances in the channel which are available on-chain (excluding on-chain fees) are
 * included here until an [`Event::SpendableOutputs`] event has been generated for the
 * balance, or until our counterparty has claimed the balance and accrued several
 * confirmations on the claim transaction.
 *
 * Note that for `ChannelMonitors` which track a channel which went on-chain with versions of
 * LDK prior to 0.0.111, not all or excess balances may be included.
 *
 * See [`Balance`] for additional details on the types of claimable balances which
 * may be returned here and their meanings.
 */
MUST_USE_RES struct LDKCVec_BalanceZ ChannelMonitor_get_claimable_balances(const struct LDKChannelMonitor *NONNULL_PTR this_arg);

/**
 * Read a C2Tuple_ThirtyTwoBytesChannelMonitorZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelMonitorZ_write
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelMonitorZDecodeErrorZ C2Tuple_ThirtyTwoBytesChannelMonitorZ_read(struct LDKu8slice ser, const struct LDKEntropySource *NONNULL_PTR arg_a, const struct LDKSignerProvider *NONNULL_PTR arg_b);

/**
 * Frees any resources used by the OutPoint, if is_owned is set and inner is non-NULL.
 */
void OutPoint_free(struct LDKOutPoint this_obj);

/**
 * The referenced transaction's txid.
 */
const uint8_t (*OutPoint_get_txid(const struct LDKOutPoint *NONNULL_PTR this_ptr))[32];

/**
 * The referenced transaction's txid.
 */
void OutPoint_set_txid(struct LDKOutPoint *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The index of the referenced output in its transaction's vout.
 */
uint16_t OutPoint_get_index(const struct LDKOutPoint *NONNULL_PTR this_ptr);

/**
 * The index of the referenced output in its transaction's vout.
 */
void OutPoint_set_index(struct LDKOutPoint *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new OutPoint given each field
 */
MUST_USE_RES struct LDKOutPoint OutPoint_new(struct LDKThirtyTwoBytes txid_arg, uint16_t index_arg);

/**
 * Creates a copy of the OutPoint
 */
struct LDKOutPoint OutPoint_clone(const struct LDKOutPoint *NONNULL_PTR orig);

/**
 * Checks if two OutPoints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OutPoint_eq(const struct LDKOutPoint *NONNULL_PTR a, const struct LDKOutPoint *NONNULL_PTR b);

/**
 * Generates a non-cryptographic 64-bit hash of the OutPoint.
 */
uint64_t OutPoint_hash(const struct LDKOutPoint *NONNULL_PTR o);

/**
 * Convert an `OutPoint` to a lightning channel id.
 */
MUST_USE_RES struct LDKThirtyTwoBytes OutPoint_to_channel_id(const struct LDKOutPoint *NONNULL_PTR this_arg);

/**
 * Serialize the OutPoint object into a byte array which can be read by OutPoint_read
 */
struct LDKCVec_u8Z OutPoint_write(const struct LDKOutPoint *NONNULL_PTR obj);

/**
 * Read a OutPoint from a byte array, created by OutPoint_write
 */
struct LDKCResult_OutPointDecodeErrorZ OutPoint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the FailureCode
 */
void FailureCode_free(struct LDKFailureCode this_ptr);

/**
 * Creates a copy of the FailureCode
 */
struct LDKFailureCode FailureCode_clone(const struct LDKFailureCode *NONNULL_PTR orig);

/**
 * Utility method to constructs a new TemporaryNodeFailure-variant FailureCode
 */
struct LDKFailureCode FailureCode_temporary_node_failure(void);

/**
 * Utility method to constructs a new RequiredNodeFeatureMissing-variant FailureCode
 */
struct LDKFailureCode FailureCode_required_node_feature_missing(void);

/**
 * Utility method to constructs a new IncorrectOrUnknownPaymentDetails-variant FailureCode
 */
struct LDKFailureCode FailureCode_incorrect_or_unknown_payment_details(void);

/**
 * Utility method to constructs a new InvalidOnionPayload-variant FailureCode
 */
struct LDKFailureCode FailureCode_invalid_onion_payload(struct LDKCOption_C2Tuple_u64u16ZZ a);

/**
 * Frees any resources used by the ChannelManager, if is_owned is set and inner is non-NULL.
 */
void ChannelManager_free(struct LDKChannelManager this_obj);

/**
 * Frees any resources used by the ChainParameters, if is_owned is set and inner is non-NULL.
 */
void ChainParameters_free(struct LDKChainParameters this_obj);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
enum LDKNetwork ChainParameters_get_network(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The network for determining the `chain_hash` in Lightning messages.
 */
void ChainParameters_set_network(struct LDKChainParameters *NONNULL_PTR this_ptr, enum LDKNetwork val);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
struct LDKBestBlock ChainParameters_get_best_block(const struct LDKChainParameters *NONNULL_PTR this_ptr);

/**
 * The hash and height of the latest block successfully connected.
 *
 * Used to track on-chain channel funding outputs and send payments with reliable timelocks.
 */
void ChainParameters_set_best_block(struct LDKChainParameters *NONNULL_PTR this_ptr, struct LDKBestBlock val);

/**
 * Constructs a new ChainParameters given each field
 */
MUST_USE_RES struct LDKChainParameters ChainParameters_new(enum LDKNetwork network_arg, struct LDKBestBlock best_block_arg);

/**
 * Creates a copy of the ChainParameters
 */
struct LDKChainParameters ChainParameters_clone(const struct LDKChainParameters *NONNULL_PTR orig);

/**
 * Frees any resources used by the CounterpartyForwardingInfo, if is_owned is set and inner is non-NULL.
 */
void CounterpartyForwardingInfo_free(struct LDKCounterpartyForwardingInfo this_obj);

/**
 * Base routing fee in millisatoshis.
 */
uint32_t CounterpartyForwardingInfo_get_fee_base_msat(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Base routing fee in millisatoshis.
 */
void CounterpartyForwardingInfo_set_fee_base_msat(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
uint32_t CounterpartyForwardingInfo_get_fee_proportional_millionths(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * Amount in millionths of a satoshi the channel will charge per transferred satoshi.
 */
void CounterpartyForwardingInfo_set_fee_proportional_millionths(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
uint16_t CounterpartyForwardingInfo_get_cltv_expiry_delta(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr);

/**
 * The minimum difference in cltv_expiry between an ingoing HTLC and its outgoing counterpart,
 * such that the outgoing HTLC is forwardable to this counterparty. See `msgs::ChannelUpdate`'s
 * `cltv_expiry_delta` for more details.
 */
void CounterpartyForwardingInfo_set_cltv_expiry_delta(struct LDKCounterpartyForwardingInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyForwardingInfo given each field
 */
MUST_USE_RES struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg);

/**
 * Creates a copy of the CounterpartyForwardingInfo
 */
struct LDKCounterpartyForwardingInfo CounterpartyForwardingInfo_clone(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelCounterparty, if is_owned is set and inner is non-NULL.
 */
void ChannelCounterparty_free(struct LDKChannelCounterparty this_obj);

/**
 * The node_id of our counterparty
 */
struct LDKPublicKey ChannelCounterparty_get_node_id(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The node_id of our counterparty
 */
void ChannelCounterparty_set_node_id(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
struct LDKInitFeatures ChannelCounterparty_get_features(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The Features the channel counterparty provided upon last connection.
 * Useful for routing as it is the most up-to-date copy of the counterparty's features and
 * many routing-relevant features are present in the init context.
 */
void ChannelCounterparty_set_features(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
uint64_t ChannelCounterparty_get_unspendable_punishment_reserve(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for our counterparty. This
 * value ensures that if our counterparty broadcasts a revoked state, we can punish them by
 * claiming at least this value on chain.
 *
 * This value is not included in [`inbound_capacity_msat`] as it can never be spent.
 *
 * [`inbound_capacity_msat`]: ChannelDetails::inbound_capacity_msat
 */
void ChannelCounterparty_set_unspendable_punishment_reserve(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyForwardingInfo ChannelCounterparty_get_forwarding_info(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * Information on the fees and requirements that the counterparty requires when forwarding
 * payments to us through this channel.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelCounterparty_set_forwarding_info(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCounterpartyForwardingInfo val);

/**
 * The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
 * is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
 * from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
 */
struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_minimum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The smallest value HTLC (in msat) the remote peer will accept, for this channel. This field
 * is only `None` before we have received either the `OpenChannel` or `AcceptChannel` message
 * from the remote peer, or for `ChannelCounterparty` objects serialized prior to LDK 0.0.107.
 */
void ChannelCounterparty_set_outbound_htlc_minimum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
 */
struct LDKCOption_u64Z ChannelCounterparty_get_outbound_htlc_maximum_msat(const struct LDKChannelCounterparty *NONNULL_PTR this_ptr);

/**
 * The largest value HTLC (in msat) the remote peer currently will accept, for this channel.
 */
void ChannelCounterparty_set_outbound_htlc_maximum_msat(struct LDKChannelCounterparty *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new ChannelCounterparty given each field
 *
 * Note that forwarding_info_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelCounterparty ChannelCounterparty_new(struct LDKPublicKey node_id_arg, struct LDKInitFeatures features_arg, uint64_t unspendable_punishment_reserve_arg, struct LDKCounterpartyForwardingInfo forwarding_info_arg, struct LDKCOption_u64Z outbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z outbound_htlc_maximum_msat_arg);

/**
 * Creates a copy of the ChannelCounterparty
 */
struct LDKChannelCounterparty ChannelCounterparty_clone(const struct LDKChannelCounterparty *NONNULL_PTR orig);

/**
 * Frees any resources used by the ChannelDetails, if is_owned is set and inner is non-NULL.
 */
void ChannelDetails_free(struct LDKChannelDetails this_obj);

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
const uint8_t (*ChannelDetails_get_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr))[32];

/**
 * The channel's ID (prior to funding transaction generation, this is a random 32 bytes,
 * thereafter this is the txid of the funding transaction xor the funding transaction output).
 * Note that this means this value is *not* persistent - it can change once during the
 * lifetime of the channel.
 */
void ChannelDetails_set_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
struct LDKChannelCounterparty ChannelDetails_get_counterparty(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Parameters which apply to our counterparty. See individual fields for more information.
 */
void ChannelDetails_set_counterparty(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelCounterparty val);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelDetails_get_funding_txo(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The Channel's funding transaction output, if we've negotiated the funding transaction with
 * our counterparty already.
 *
 * Note that, if this has been set, `channel_id` will be equivalent to
 * `funding_txo.unwrap().to_channel_id()`.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_funding_txo(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures ChannelDetails_get_channel_type(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The features which this channel operates with. See individual features for more info.
 *
 * `None` until negotiation completes and the channel type is finalized.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_channel_type(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
 * be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`outbound_scid_alias`]: Self::outbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 * [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
 * [`confirmations_required`]: Self::confirmations_required
 */
struct LDKCOption_u64Z ChannelDetails_get_short_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The position of the funding transaction in the chain. None if the funding transaction has
 * not yet been confirmed and the channel fully opened.
 *
 * Note that if [`inbound_scid_alias`] is set, it must be used for invoices and inbound
 * payments instead of this. See [`get_inbound_payment_scid`].
 *
 * For channels with [`confirmations_required`] set to `Some(0)`, [`outbound_scid_alias`] may
 * be used in place of this in outbound routes. See [`get_outbound_payment_scid`].
 *
 * [`inbound_scid_alias`]: Self::inbound_scid_alias
 * [`outbound_scid_alias`]: Self::outbound_scid_alias
 * [`get_inbound_payment_scid`]: Self::get_inbound_payment_scid
 * [`get_outbound_payment_scid`]: Self::get_outbound_payment_scid
 * [`confirmations_required`]: Self::confirmations_required
 */
void ChannelDetails_set_short_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by us and
 * usable in place of [`short_channel_id`] to reference the channel in outbound routes when
 * the channel has not yet been confirmed (as long as [`confirmations_required`] is
 * `Some(0)`).
 *
 * This will be `None` as long as the channel is not available for routing outbound payments.
 *
 * [`short_channel_id`]: Self::short_channel_id
 * [`confirmations_required`]: Self::confirmations_required
 */
struct LDKCOption_u64Z ChannelDetails_get_outbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by us and
 * usable in place of [`short_channel_id`] to reference the channel in outbound routes when
 * the channel has not yet been confirmed (as long as [`confirmations_required`] is
 * `Some(0)`).
 *
 * This will be `None` as long as the channel is not available for routing outbound payments.
 *
 * [`short_channel_id`]: Self::short_channel_id
 * [`confirmations_required`]: Self::confirmations_required
 */
void ChannelDetails_set_outbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_scid_alias(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * An optional [`short_channel_id`] alias for this channel, randomly generated by our
 * counterparty and usable in place of [`short_channel_id`] in invoice route hints. Our
 * counterparty will recognize the alias provided here in place of the [`short_channel_id`]
 * when they see a payment to be routed to us.
 *
 * Our counterparty may choose to rotate this value at any time, though will always recognize
 * previous values for inbound payment forwarding.
 *
 * [`short_channel_id`]: Self::short_channel_id
 */
void ChannelDetails_set_inbound_scid_alias(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
uint64_t ChannelDetails_get_channel_value_satoshis(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, of this channel as appears in the funding output
 */
void ChannelDetails_set_channel_value_satoshis(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
struct LDKCOption_u64Z ChannelDetails_get_unspendable_punishment_reserve(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The value, in satoshis, that must always be held in the channel for us. This value ensures
 * that if we broadcast a revoked state, our counterparty can punish us by claiming at least
 * this value on chain.
 *
 * This value is not included in [`outbound_capacity_msat`] as it can never be spent.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`outbound_capacity_msat`]: ChannelDetails::outbound_capacity_msat
 */
void ChannelDetails_set_unspendable_punishment_reserve(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
 * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
 * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
 * `user_channel_id` will be randomized for an inbound channel.  This may be zero for objects
 * serialized with LDK versions prior to 0.0.113.
 *
 * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
 */
struct LDKU128 ChannelDetails_get_user_channel_id(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The `user_channel_id` value passed in to [`ChannelManager::create_channel`] for outbound
 * channels, or to [`ChannelManager::accept_inbound_channel`] for inbound channels if
 * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
 * `user_channel_id` will be randomized for an inbound channel.  This may be zero for objects
 * serialized with LDK versions prior to 0.0.113.
 *
 * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
 */
void ChannelDetails_set_user_channel_id(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKU128 val);

/**
 * The currently negotiated fee rate denominated in satoshi per 1000 weight units,
 * which is applied to commitment and HTLC transactions.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.115.
 */
struct LDKCOption_u32Z ChannelDetails_get_feerate_sat_per_1000_weight(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The currently negotiated fee rate denominated in satoshi per 1000 weight units,
 * which is applied to commitment and HTLC transactions.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.115.
 */
void ChannelDetails_set_feerate_sat_per_1000_weight(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
uint64_t ChannelDetails_get_balance_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Our total balance.  This is the amount we would get if we close the channel.
 * This value is not exact. Due to various in-flight changes and feerate changes, exactly this
 * amount is not likely to be recoverable on close.
 *
 * This does not include any pending HTLCs which are not yet fully resolved (and, thus, whose
 * balance is not available for inclusion in new outbound HTLCs). This further does not include
 * any pending outgoing HTLCs which are awaiting some other resolution to be sent.
 * This does not consider any on-chain fees.
 *
 * See also [`ChannelDetails::outbound_capacity_msat`]
 */
void ChannelDetails_set_balance_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_outbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending HTLCs to the remote peer. This does not include
 * any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new outbound HTLCs). This further does not include any pending
 * outgoing HTLCs which are awaiting some other resolution to be sent.
 *
 * See also [`ChannelDetails::balance_msat`]
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * conflict-avoidance policy, exactly this amount is not likely to be spendable. However, we
 * should be able to spend nearly this amount.
 */
void ChannelDetails_set_outbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available outbound capacity for sending a single HTLC to the remote peer. This is
 * similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
 * the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
 * to use a limit as close as possible to the HTLC limit we can currently send.
 *
 * See also [`ChannelDetails::next_outbound_htlc_minimum_msat`],
 * [`ChannelDetails::balance_msat`], and [`ChannelDetails::outbound_capacity_msat`].
 */
uint64_t ChannelDetails_get_next_outbound_htlc_limit_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available outbound capacity for sending a single HTLC to the remote peer. This is
 * similar to [`ChannelDetails::outbound_capacity_msat`] but it may be further restricted by
 * the current state and per-HTLC limit(s). This is intended for use when routing, allowing us
 * to use a limit as close as possible to the HTLC limit we can currently send.
 *
 * See also [`ChannelDetails::next_outbound_htlc_minimum_msat`],
 * [`ChannelDetails::balance_msat`], and [`ChannelDetails::outbound_capacity_msat`].
 */
void ChannelDetails_set_next_outbound_htlc_limit_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value for sending a single HTLC to the remote peer. This is the equivalent of
 * [`ChannelDetails::next_outbound_htlc_limit_msat`] but represents a lower-bound, rather than
 * an upper-bound. This is intended for use when routing, allowing us to ensure we pick a
 * route which is valid.
 */
uint64_t ChannelDetails_get_next_outbound_htlc_minimum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The minimum value for sending a single HTLC to the remote peer. This is the equivalent of
 * [`ChannelDetails::next_outbound_htlc_limit_msat`] but represents a lower-bound, rather than
 * an upper-bound. This is intended for use when routing, allowing us to ensure we pick a
 * route which is valid.
 */
void ChannelDetails_set_next_outbound_htlc_minimum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
uint64_t ChannelDetails_get_inbound_capacity_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The available inbound capacity for the remote peer to send HTLCs to us. This does not
 * include any pending HTLCs which are not yet fully resolved (and, thus, whose balance is not
 * available for inclusion in new inbound HTLCs).
 * Note that there are some corner cases not fully handled here, so the actual available
 * inbound capacity may be slightly higher than this.
 *
 * This value is not exact. Due to various in-flight changes, feerate changes, and our
 * counterparty's conflict-avoidance policy, exactly this amount is not likely to be spendable.
 * However, our counterparty should be able to spend nearly this amount.
 */
void ChannelDetails_set_inbound_capacity_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations_required(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of required confirmations on the funding transaction before the funding will be
 * considered \"locked\". This number is selected by the channel fundee (i.e. us if
 * [`is_outbound`] is *not* set), and can be selected for inbound channels with
 * [`ChannelHandshakeConfig::minimum_depth`] or limited for outbound channels with
 * [`ChannelHandshakeLimits::max_minimum_depth`].
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 *
 * [`is_outbound`]: ChannelDetails::is_outbound
 * [`ChannelHandshakeConfig::minimum_depth`]: crate::util::config::ChannelHandshakeConfig::minimum_depth
 * [`ChannelHandshakeLimits::max_minimum_depth`]: crate::util::config::ChannelHandshakeLimits::max_minimum_depth
 */
void ChannelDetails_set_confirmations_required(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The current number of confirmations on the funding transaction.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.113.
 */
struct LDKCOption_u32Z ChannelDetails_get_confirmations(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The current number of confirmations on the funding transaction.
 *
 * This value will be `None` for objects serialized with LDK versions prior to 0.0.113.
 */
void ChannelDetails_set_confirmations(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
struct LDKCOption_u16Z ChannelDetails_get_force_close_spend_delay(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The number of blocks (after our commitment transaction confirms) that we will need to wait
 * until we can claim our funds after we force-close the channel. During this time our
 * counterparty is allowed to punish us if we broadcasted a stale state. If our counterparty
 * force-closes the channel and broadcasts a commitment transaction we do not have to wait any
 * time to claim our non-HTLC-encumbered funds.
 *
 * This value will be `None` for outbound channels until the counterparty accepts the channel.
 */
void ChannelDetails_set_force_close_spend_delay(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u16Z val);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
bool ChannelDetails_get_is_outbound(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel was initiated (and thus funded) by us.
 */
void ChannelDetails_set_is_outbound(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if the channel is confirmed, channel_ready messages have been exchanged, and the
 * channel is not currently being shut down. `channel_ready` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
bool ChannelDetails_get_is_channel_ready(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is confirmed, channel_ready messages have been exchanged, and the
 * channel is not currently being shut down. `channel_ready` message exchange implies the
 * required confirmation count has been reached (and we were connected to the peer at some
 * point after the funding transaction received enough confirmations). The required
 * confirmation count is provided in [`confirmations_required`].
 *
 * [`confirmations_required`]: ChannelDetails::confirmations_required
 */
void ChannelDetails_set_is_channel_ready(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * The stage of the channel's shutdown.
 * `None` for `ChannelDetails` serialized on LDK versions prior to 0.0.116.
 *
 * Returns a copy of the field.
 */
struct LDKCOption_ChannelShutdownStateZ ChannelDetails_get_channel_shutdown_state(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The stage of the channel's shutdown.
 * `None` for `ChannelDetails` serialized on LDK versions prior to 0.0.116.
 */
void ChannelDetails_set_channel_shutdown_state(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_ChannelShutdownStateZ val);

/**
 * True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_channel_ready`.
 */
bool ChannelDetails_get_is_usable(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if the channel is (a) confirmed and channel_ready messages have been exchanged, (b)
 * the peer is connected, and (c) the channel is not currently negotiating a shutdown.
 *
 * This is a strict superset of `is_channel_ready`.
 */
void ChannelDetails_set_is_usable(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * True if this channel is (or will be) publicly-announced.
 */
bool ChannelDetails_get_is_public(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * True if this channel is (or will be) publicly-announced.
 */
void ChannelDetails_set_is_public(struct LDKChannelDetails *NONNULL_PTR this_ptr, bool val);

/**
 * The smallest value HTLC (in msat) we will accept, for this channel. This field
 * is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_minimum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The smallest value HTLC (in msat) we will accept, for this channel. This field
 * is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.107
 */
void ChannelDetails_set_inbound_htlc_minimum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The largest value HTLC (in msat) we currently will accept, for this channel.
 */
struct LDKCOption_u64Z ChannelDetails_get_inbound_htlc_maximum_msat(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * The largest value HTLC (in msat) we currently will accept, for this channel.
 */
void ChannelDetails_set_inbound_htlc_maximum_msat(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Set of configurable parameters that affect channel operation.
 *
 * This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelConfig ChannelDetails_get_config(const struct LDKChannelDetails *NONNULL_PTR this_ptr);

/**
 * Set of configurable parameters that affect channel operation.
 *
 * This field is only `None` for `ChannelDetails` objects serialized prior to LDK 0.0.109.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelDetails_set_config(struct LDKChannelDetails *NONNULL_PTR this_ptr, struct LDKChannelConfig val);

/**
 * Constructs a new ChannelDetails given each field
 *
 * Note that funding_txo_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 * Note that channel_type_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 * Note that config_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelDetails ChannelDetails_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKChannelCounterparty counterparty_arg, struct LDKOutPoint funding_txo_arg, struct LDKChannelTypeFeatures channel_type_arg, struct LDKCOption_u64Z short_channel_id_arg, struct LDKCOption_u64Z outbound_scid_alias_arg, struct LDKCOption_u64Z inbound_scid_alias_arg, uint64_t channel_value_satoshis_arg, struct LDKCOption_u64Z unspendable_punishment_reserve_arg, struct LDKU128 user_channel_id_arg, struct LDKCOption_u32Z feerate_sat_per_1000_weight_arg, uint64_t balance_msat_arg, uint64_t outbound_capacity_msat_arg, uint64_t next_outbound_htlc_limit_msat_arg, uint64_t next_outbound_htlc_minimum_msat_arg, uint64_t inbound_capacity_msat_arg, struct LDKCOption_u32Z confirmations_required_arg, struct LDKCOption_u32Z confirmations_arg, struct LDKCOption_u16Z force_close_spend_delay_arg, bool is_outbound_arg, bool is_channel_ready_arg, struct LDKCOption_ChannelShutdownStateZ channel_shutdown_state_arg, bool is_usable_arg, bool is_public_arg, struct LDKCOption_u64Z inbound_htlc_minimum_msat_arg, struct LDKCOption_u64Z inbound_htlc_maximum_msat_arg, struct LDKChannelConfig config_arg);

/**
 * Creates a copy of the ChannelDetails
 */
struct LDKChannelDetails ChannelDetails_clone(const struct LDKChannelDetails *NONNULL_PTR orig);

/**
 * Gets the current SCID which should be used to identify this channel for inbound payments.
 * This should be used for providing invoice hints or in any other context where our
 * counterparty will forward a payment to us.
 *
 * This is either the [`ChannelDetails::inbound_scid_alias`], if set, or the
 * [`ChannelDetails::short_channel_id`]. See those for more information.
 */
MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_inbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);

/**
 * Gets the current SCID which should be used to identify this channel for outbound payments.
 * This should be used in [`Route`]s to describe the first hop or in other contexts where
 * we're sending or forwarding a payment outbound over this channel.
 *
 * This is either the [`ChannelDetails::short_channel_id`], if set, or the
 * [`ChannelDetails::outbound_scid_alias`]. See those for more information.
 */
MUST_USE_RES struct LDKCOption_u64Z ChannelDetails_get_outbound_payment_scid(const struct LDKChannelDetails *NONNULL_PTR this_arg);

/**
 * Creates a copy of the ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_clone(const enum LDKChannelShutdownState *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NotShuttingDown-variant ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_not_shutting_down(void);

/**
 * Utility method to constructs a new ShutdownInitiated-variant ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_shutdown_initiated(void);

/**
 * Utility method to constructs a new ResolvingHTLCs-variant ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_resolving_htlcs(void);

/**
 * Utility method to constructs a new NegotiatingClosingFee-variant ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_negotiating_closing_fee(void);

/**
 * Utility method to constructs a new ShutdownComplete-variant ChannelShutdownState
 */
enum LDKChannelShutdownState ChannelShutdownState_shutdown_complete(void);

/**
 * Checks if two ChannelShutdownStates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ChannelShutdownState_eq(const enum LDKChannelShutdownState *NONNULL_PTR a, const enum LDKChannelShutdownState *NONNULL_PTR b);

/**
 * Frees any resources used by the RecentPaymentDetails
 */
void RecentPaymentDetails_free(struct LDKRecentPaymentDetails this_ptr);

/**
 * Creates a copy of the RecentPaymentDetails
 */
struct LDKRecentPaymentDetails RecentPaymentDetails_clone(const struct LDKRecentPaymentDetails *NONNULL_PTR orig);

/**
 * Utility method to constructs a new AwaitingInvoice-variant RecentPaymentDetails
 */
struct LDKRecentPaymentDetails RecentPaymentDetails_awaiting_invoice(struct LDKThirtyTwoBytes payment_id);

/**
 * Utility method to constructs a new Pending-variant RecentPaymentDetails
 */
struct LDKRecentPaymentDetails RecentPaymentDetails_pending(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, uint64_t total_msat);

/**
 * Utility method to constructs a new Fulfilled-variant RecentPaymentDetails
 */
struct LDKRecentPaymentDetails RecentPaymentDetails_fulfilled(struct LDKThirtyTwoBytes payment_id, struct LDKCOption_ThirtyTwoBytesZ payment_hash);

/**
 * Utility method to constructs a new Abandoned-variant RecentPaymentDetails
 */
struct LDKRecentPaymentDetails RecentPaymentDetails_abandoned(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash);

/**
 * Frees any resources used by the PhantomRouteHints, if is_owned is set and inner is non-NULL.
 */
void PhantomRouteHints_free(struct LDKPhantomRouteHints this_obj);

/**
 * The list of channels to be included in the invoice route hints.
 */
struct LDKCVec_ChannelDetailsZ PhantomRouteHints_get_channels(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The list of channels to be included in the invoice route hints.
 */
void PhantomRouteHints_set_channels(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKCVec_ChannelDetailsZ val);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
uint64_t PhantomRouteHints_get_phantom_scid(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * A fake scid used for representing the phantom node's fake channel in generating the invoice
 * route hints.
 */
void PhantomRouteHints_set_phantom_scid(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
struct LDKPublicKey PhantomRouteHints_get_real_node_pubkey(const struct LDKPhantomRouteHints *NONNULL_PTR this_ptr);

/**
 * The pubkey of the real backing node that would ultimately receive the payment.
 */
void PhantomRouteHints_set_real_node_pubkey(struct LDKPhantomRouteHints *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PhantomRouteHints given each field
 */
MUST_USE_RES struct LDKPhantomRouteHints PhantomRouteHints_new(struct LDKCVec_ChannelDetailsZ channels_arg, uint64_t phantom_scid_arg, struct LDKPublicKey real_node_pubkey_arg);

/**
 * Creates a copy of the PhantomRouteHints
 */
struct LDKPhantomRouteHints PhantomRouteHints_clone(const struct LDKPhantomRouteHints *NONNULL_PTR orig);

/**
 * Constructs a new `ChannelManager` to hold several channels and route between them.
 *
 * The current time or latest block header time can be provided as the `current_timestamp`.
 *
 * This is the main \"logic hub\" for all channel-related actions, and implements
 * [`ChannelMessageHandler`].
 *
 * Non-proportional fees are fixed according to our risk using the provided fee estimator.
 *
 * Users need to notify the new `ChannelManager` when a new block is connected or
 * disconnected using its [`block_connected`] and [`block_disconnected`] methods, starting
 * from after [`params.best_block.block_hash`]. See [`chain::Listen`] and [`chain::Confirm`] for
 * more details.
 *
 * [`block_connected`]: chain::Listen::block_connected
 * [`block_disconnected`]: chain::Listen::block_disconnected
 * [`params.best_block.block_hash`]: chain::BestBlock::block_hash
 */
MUST_USE_RES struct LDKChannelManager ChannelManager_new(struct LDKFeeEstimator fee_est, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKRouter router, struct LDKLogger logger, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKSignerProvider signer_provider, struct LDKUserConfig config, struct LDKChainParameters params, uint32_t current_timestamp);

/**
 * Gets the current configuration applied to all new channels.
 */
MUST_USE_RES struct LDKUserConfig ChannelManager_get_current_default_configuration(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Creates a new outbound channel to the given remote node and with the given value.
 *
 * `user_channel_id` will be provided back as in
 * [`Event::FundingGenerationReady::user_channel_id`] to allow tracking of which events
 * correspond with which `create_channel` call. Note that the `user_channel_id` defaults to a
 * randomized value for inbound channels. `user_channel_id` has no meaning inside of LDK, it
 * is simply copied to events and otherwise ignored.
 *
 * Raises [`APIError::APIMisuseError`] when `channel_value_satoshis` > 2**24 or `push_msat` is
 * greater than `channel_value_satoshis * 1k` or `channel_value_satoshis < 1000`.
 *
 * Raises [`APIError::ChannelUnavailable`] if the channel cannot be opened due to failing to
 * generate a shutdown scriptpubkey or destination script set by
 * [`SignerProvider::get_shutdown_scriptpubkey`] or [`SignerProvider::get_destination_script`].
 *
 * Note that we do not check if you are currently connected to the given peer. If no
 * connection is available, the outbound `open_channel` message may fail to send, resulting in
 * the channel eventually being silently forgotten (dropped on reload).
 *
 * Returns the new Channel's temporary `channel_id`. This ID will appear as
 * [`Event::FundingGenerationReady::temporary_channel_id`] and in
 * [`ChannelDetails::channel_id`] until after
 * [`ChannelManager::funding_transaction_generated`] is called, swapping the Channel's ID for
 * one derived from the funding transaction's TXID. If the counterparty rejects the channel
 * immediately, this temporary ID will appear in [`Event::ChannelClosed::channel_id`].
 *
 * [`Event::FundingGenerationReady::user_channel_id`]: events::Event::FundingGenerationReady::user_channel_id
 * [`Event::FundingGenerationReady::temporary_channel_id`]: events::Event::FundingGenerationReady::temporary_channel_id
 * [`Event::ChannelClosed::channel_id`]: events::Event::ChannelClosed::channel_id
 *
 * Note that override_config (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesAPIErrorZ ChannelManager_create_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey their_network_key, uint64_t channel_value_satoshis, uint64_t push_msat, struct LDKU128 user_channel_id, struct LDKUserConfig override_config);

/**
 * Gets the list of open channels, in random order. See [`ChannelDetails`] field documentation for
 * more information.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of usable channels, in random order. Useful as an argument to
 * [`Router::find_route`] to ensure non-announced channels are used.
 *
 * These are guaranteed to have their [`ChannelDetails::is_usable`] value set to true, see the
 * documentation for [`ChannelDetails::is_usable`] for more info on exactly what the criteria
 * are.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_usable_channels(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the list of channels we have with a given counterparty, in random order.
 */
MUST_USE_RES struct LDKCVec_ChannelDetailsZ ChannelManager_list_channels_with_counterparty(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id);

/**
 * Returns in an undefined order recent payments that -- if not fulfilled -- have yet to find a
 * successful path, or have unresolved HTLCs.
 *
 * This can be useful for payments that may have been prepared, but ultimately not sent, as a
 * result of a crash. If such a payment exists, is not listed here, and an
 * [`Event::PaymentSent`] has not been received, you may consider resending the payment.
 *
 * [`Event::PaymentSent`]: events::Event::PaymentSent
 */
MUST_USE_RES struct LDKCVec_RecentPaymentDetailsZ ChannelManager_list_recent_payments(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 *  * If we are the channel initiator, we will pay between our [`Background`] and
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate.
 *  * If our counterparty is the channel initiator, we will require a channel closing
 *    transaction feerate of at least our [`Background`] feerate or the feerate which
 *    would appear on a force-closure transaction, whichever is lower. We will allow our
 *    counterparty to pay as much fee as they'd like, however.
 *
 * May generate a [`SendShutdown`] message event on success, which should be relayed.
 *
 * Raises [`APIError::ChannelUnavailable`] if the channel cannot be closed due to failing to
 * generate a shutdown scriptpubkey or destination script set by
 * [`SignerProvider::get_shutdown_scriptpubkey`]. A force-closure may be needed to close the
 * channel.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`SendShutdown`]: crate::events::MessageSendEvent::SendShutdown
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Begins the process of closing a channel. After this call (plus some timeout), no new HTLCs
 * will be accepted on the given channel, and after additional timeout/the closing of all
 * pending HTLCs, the channel will be closed on chain.
 *
 * `target_feerate_sat_per_1000_weight` has different meanings depending on if we initiated
 * the channel being closed or not:
 *  * If we are the channel initiator, we will pay at least this feerate on the closing
 *    transaction. The upper-bound is set by
 *    [`ChannelConfig::force_close_avoidance_max_fee_satoshis`] plus our [`Normal`] fee
 *    estimate (or `target_feerate_sat_per_1000_weight`, if it is greater).
 *  * If our counterparty is the channel initiator, we will refuse to accept a channel closure
 *    transaction feerate below `target_feerate_sat_per_1000_weight` (or the feerate which
 *    will appear on a force-closure transaction, whichever is lower).
 *
 * The `shutdown_script` provided  will be used as the `scriptPubKey` for the closing transaction.
 * Will fail if a shutdown script has already been set for this channel by
 * ['ChannelHandshakeConfig::commit_upfront_shutdown_pubkey`]. The given shutdown script must
 * also be compatible with our and the counterparty's features.
 *
 * May generate a [`SendShutdown`] message event on success, which should be relayed.
 *
 * Raises [`APIError::ChannelUnavailable`] if the channel cannot be closed due to failing to
 * generate a shutdown scriptpubkey or destination script set by
 * [`SignerProvider::get_shutdown_scriptpubkey`]. A force-closure may be needed to close the
 * channel.
 *
 * [`ChannelConfig::force_close_avoidance_max_fee_satoshis`]: crate::util::config::ChannelConfig::force_close_avoidance_max_fee_satoshis
 * [`Background`]: crate::chain::chaininterface::ConfirmationTarget::Background
 * [`Normal`]: crate::chain::chaininterface::ConfirmationTarget::Normal
 * [`SendShutdown`]: crate::events::MessageSendEvent::SendShutdown
 *
 * Note that shutdown_script (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_close_channel_with_feerate_and_script(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKCOption_u32Z target_feerate_sats_per_1000_weight, struct LDKShutdownScript shutdown_script);

/**
 * Force closes a channel, immediately broadcasting the latest local transaction(s) and
 * rejecting new HTLCs on the given channel. Fails if `channel_id` is unknown to
 * the manager, or if the `counterparty_node_id` isn't the counterparty of the corresponding
 * channel.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Force closes a channel, rejecting new HTLCs on the given channel but skips broadcasting
 * the latest local transaction(s). Fails if `channel_id` is unknown to the manager, or if the
 * `counterparty_node_id` isn't the counterparty of the corresponding channel.
 *
 * You can always get the latest local transaction(s) to broadcast from
 * [`ChannelMonitor::get_latest_holder_commitment_txn`].
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_force_close_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*channel_id)[32], struct LDKPublicKey counterparty_node_id);

/**
 * Force close all channels, immediately broadcasting the latest local commitment transaction
 * for each to the chain and rejecting new HTLCs on each.
 */
void ChannelManager_force_close_all_channels_broadcasting_latest_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Force close all channels rejecting new HTLCs on each but without broadcasting the latest
 * local transaction(s).
 */
void ChannelManager_force_close_all_channels_without_broadcasting_txn(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Sends a payment along a given route.
 *
 * Value parameters are provided via the last hop in route, see documentation for [`RouteHop`]
 * fields for more info.
 *
 * May generate [`UpdateHTLCs`] message(s) event on success, which should be relayed (e.g. via
 * [`PeerManager::process_events`]).
 *
 * # Avoiding Duplicate Payments
 *
 * If a pending payment is currently in-flight with the same [`PaymentId`] provided, this
 * method will error with an [`APIError::InvalidRoute`]. Note, however, that once a payment
 * is no longer pending (either via [`ChannelManager::abandon_payment`], or handling of an
 * [`Event::PaymentSent`] or [`Event::PaymentFailed`]) LDK will not stop you from sending a
 * second payment with the same [`PaymentId`].
 *
 * Thus, in order to ensure duplicate payments are not sent, you should implement your own
 * tracking of payments, including state to indicate once a payment has completed. Because you
 * should also ensure that [`PaymentHash`]es are not re-used, for simplicity, you should
 * consider using the [`PaymentHash`] as the key for tracking payments. In that case, the
 * [`PaymentId`] should be a copy of the [`PaymentHash`] bytes.
 *
 * Additionally, in the scenario where we begin the process of sending a payment, but crash
 * before `send_payment` returns (or prior to [`ChannelMonitorUpdate`] persistence if you're
 * using [`ChannelMonitorUpdateStatus::InProgress`]), the payment may be lost on restart. See
 * [`ChannelManager::list_recent_payments`] for more information.
 *
 * # Possible Error States on [`PaymentSendFailure`]
 *
 * Each path may have a different return value, and [`PaymentSendFailure`] may return a `Vec` with
 * each entry matching the corresponding-index entry in the route paths, see
 * [`PaymentSendFailure`] for more info.
 *
 * In general, a path may raise:
 *  * [`APIError::InvalidRoute`] when an invalid route or forwarding parameter (cltv_delta, fee,
 *    node public key) is specified.
 *  * [`APIError::ChannelUnavailable`] if the next-hop channel is not available as it has been
 *    closed, doesn't exist, or the peer is currently disconnected.
 *  * [`APIError::MonitorUpdateInProgress`] if a new monitor update failure prevented sending the
 *    relevant updates.
 *
 * Note that depending on the type of the [`PaymentSendFailure`] the HTLC may have been
 * irrevocably committed to on our end. In such a case, do NOT retry the payment with a
 * different route unless you intend to pay twice!
 *
 * [`RouteHop`]: crate::routing::router::RouteHop
 * [`Event::PaymentSent`]: events::Event::PaymentSent
 * [`Event::PaymentFailed`]: events::Event::PaymentFailed
 * [`UpdateHTLCs`]: events::MessageSendEvent::UpdateHTLCs
 * [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
 * [`ChannelMonitorUpdateStatus::InProgress`]: crate::chain::ChannelMonitorUpdateStatus::InProgress
 */
MUST_USE_RES struct LDKCResult_NonePaymentSendFailureZ ChannelManager_send_payment_with_route(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id);

/**
 * Similar to [`ChannelManager::send_payment_with_route`], but will automatically find a route based on
 * `route_params` and retry failed payment paths based on `retry_strategy`.
 */
MUST_USE_RES struct LDKCResult_NoneRetryableSendFailureZ ChannelManager_send_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id, struct LDKRouteParameters route_params, struct LDKRetry retry_strategy);

/**
 * Signals that no further attempts for the given payment should occur. Useful if you have a
 * pending outbound payment with retries remaining, but wish to stop retrying the payment before
 * retries are exhausted.
 *
 * # Event Generation
 *
 * If no [`Event::PaymentFailed`] event had been generated before, one will be generated as soon
 * as there are no remaining pending HTLCs for this payment.
 *
 * Note that calling this method does *not* prevent a payment from succeeding. You must still
 * wait until you receive either a [`Event::PaymentFailed`] or [`Event::PaymentSent`] event to
 * determine the ultimate status of a payment.
 *
 * # Restart Behavior
 *
 * If an [`Event::PaymentFailed`] is generated and we restart without first persisting the
 * [`ChannelManager`], another [`Event::PaymentFailed`] may be generated.
 */
void ChannelManager_abandon_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_id);

/**
 * Send a spontaneous payment, which is a payment that does not require the recipient to have
 * generated an invoice. Optionally, you may specify the preimage. If you do choose to specify
 * the preimage, it must be a cryptographically secure random value that no intermediate node
 * would be able to guess -- otherwise, an intermediate node may claim the payment and it will
 * never reach the recipient.
 *
 * See [`send_payment`] documentation for more details on the return value of this function
 * and idempotency guarantees provided by the [`PaymentId`] key.
 *
 * Similar to regular payments, you MUST NOT reuse a `payment_preimage` value. See
 * [`send_payment`] for more information about the risks of duplicate preimage usage.
 *
 * [`send_payment`]: Self::send_payment
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesPaymentSendFailureZ ChannelManager_send_spontaneous_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, const struct LDKRoute *NONNULL_PTR route, struct LDKCOption_ThirtyTwoBytesZ payment_preimage, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id);

/**
 * Similar to [`ChannelManager::send_spontaneous_payment`], but will automatically find a route
 * based on `route_params` and retry failed payment paths based on `retry_strategy`.
 *
 * See [`PaymentParameters::for_keysend`] for help in constructing `route_params` for spontaneous
 * payments.
 *
 * [`PaymentParameters::for_keysend`]: crate::routing::router::PaymentParameters::for_keysend
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesRetryableSendFailureZ ChannelManager_send_spontaneous_payment_with_retry(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_ThirtyTwoBytesZ payment_preimage, struct LDKRecipientOnionFields recipient_onion, struct LDKThirtyTwoBytes payment_id, struct LDKRouteParameters route_params, struct LDKRetry retry_strategy);

/**
 * Send a payment that is probing the given route for liquidity. We calculate the
 * [`PaymentHash`] of probes based on a static secret and a random [`PaymentId`], which allows
 * us to easily discern them from real payments.
 */
MUST_USE_RES struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZPaymentSendFailureZ ChannelManager_send_probe(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPath path);

/**
 * Sends payment probes over all paths of a route that would be used to pay the given
 * amount to the given `node_id`.
 *
 * See [`ChannelManager::send_preflight_probes`] for more information.
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ ChannelManager_send_spontaneous_preflight_probes(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id, uint64_t amount_msat, uint32_t final_cltv_expiry_delta, struct LDKCOption_u64Z liquidity_limit_multiplier);

/**
 * Sends payment probes over all paths of a route that would be used to pay a route found
 * according to the given [`RouteParameters`].
 *
 * This may be used to send \"pre-flight\" probes, i.e., to train our scorer before conducting
 * the actual payment. Note this is only useful if there likely is sufficient time for the
 * probe to settle before sending out the actual payment, e.g., when waiting for user
 * confirmation in a wallet UI.
 *
 * Otherwise, there is a chance the probe could take up some liquidity needed to complete the
 * actual payment. Users should therefore be cautious and might avoid sending probes if
 * liquidity is scarce and/or they don't expect the probe to return before they send the
 * payment. To mitigate this issue, channels with available liquidity less than the required
 * amount times the given `liquidity_limit_multiplier` won't be used to send pre-flight
 * probes. If `None` is given as `liquidity_limit_multiplier`, it defaults to `3`.
 */
MUST_USE_RES struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbeSendFailureZ ChannelManager_send_preflight_probes(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKRouteParameters route_params, struct LDKCOption_u64Z liquidity_limit_multiplier);

/**
 * Call this upon creation of a funding transaction for the given channel.
 *
 * Returns an [`APIError::APIMisuseError`] if the funding_transaction spent non-SegWit outputs
 * or if no output was found which matches the parameters in [`Event::FundingGenerationReady`].
 *
 * Returns [`APIError::APIMisuseError`] if the funding transaction is not final for propagation
 * across the p2p network.
 *
 * Returns [`APIError::ChannelUnavailable`] if a funding transaction has already been provided
 * for the channel or if the channel has been closed as indicated by [`Event::ChannelClosed`].
 *
 * May panic if the output found in the funding transaction is duplicative with some other
 * channel (note that this should be trivially prevented by using unique funding transaction
 * keys per-channel).
 *
 * Do NOT broadcast the funding transaction yourself. When we have safely received our
 * counterparty's signature the funding transaction will automatically be broadcast via the
 * [`BroadcasterInterface`] provided when this `ChannelManager` was constructed.
 *
 * Note that this includes RBF or similar transaction replacement strategies - lightning does
 * not currently support replacing a funding transaction on an existing channel. Instead,
 * create a new channel with a conflicting funding transaction.
 *
 * Note to keep the miner incentives aligned in moving the blockchain forward, we recommend
 * the wallet software generating the funding transaction to apply anti-fee sniping as
 * implemented by Bitcoin Core wallet. See <https://bitcoinops.org/en/topics/fee-sniping/>
 * for more details.
 *
 * [`Event::FundingGenerationReady`]: crate::events::Event::FundingGenerationReady
 * [`Event::ChannelClosed`]: crate::events::Event::ChannelClosed
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKTransaction funding_transaction);

/**
 * Call this upon creation of a batch funding transaction for the given channels.
 *
 * Return values are identical to [`Self::funding_transaction_generated`], respective to
 * each individual channel and transaction output.
 *
 * Do NOT broadcast the funding transaction yourself. This batch funding transcaction
 * will only be broadcast when we have safely received and persisted the counterparty's
 * signature for each channel.
 *
 * If there is an error, all channels in the batch are to be considered closed.
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_batch_funding_transaction_generated(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCVec_C2Tuple_ThirtyTwoBytesPublicKeyZZ temporary_channels, struct LDKTransaction funding_transaction);

/**
 * Atomically applies partial updates to the [`ChannelConfig`] of the given channels.
 *
 * Once the updates are applied, each eligible channel (advertised with a known short channel
 * ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
 * or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
 * containing the new [`ChannelUpdate`] message which should be broadcast to the network.
 *
 * Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
 * `counterparty_node_id` is provided.
 *
 * Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
 * below [`MIN_CLTV_EXPIRY_DELTA`].
 *
 * If an error is returned, none of the updates should be considered applied.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 * [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
 * [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
 * [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
 * [`ChannelUpdate`]: msgs::ChannelUpdate
 * [`ChannelUnavailable`]: APIError::ChannelUnavailable
 * [`APIMisuseError`]: APIError::APIMisuseError
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_update_partial_channel_config(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id, struct LDKCVec_ThirtyTwoBytesZ channel_ids, const struct LDKChannelConfigUpdate *NONNULL_PTR config_update);

/**
 * Atomically updates the [`ChannelConfig`] for the given channels.
 *
 * Once the updates are applied, each eligible channel (advertised with a known short channel
 * ID and a change in [`forwarding_fee_proportional_millionths`], [`forwarding_fee_base_msat`],
 * or [`cltv_expiry_delta`]) has a [`BroadcastChannelUpdate`] event message generated
 * containing the new [`ChannelUpdate`] message which should be broadcast to the network.
 *
 * Returns [`ChannelUnavailable`] when a channel is not found or an incorrect
 * `counterparty_node_id` is provided.
 *
 * Returns [`APIMisuseError`] when a [`cltv_expiry_delta`] update is to be applied with a value
 * below [`MIN_CLTV_EXPIRY_DELTA`].
 *
 * If an error is returned, none of the updates should be considered applied.
 *
 * [`forwarding_fee_proportional_millionths`]: ChannelConfig::forwarding_fee_proportional_millionths
 * [`forwarding_fee_base_msat`]: ChannelConfig::forwarding_fee_base_msat
 * [`cltv_expiry_delta`]: ChannelConfig::cltv_expiry_delta
 * [`BroadcastChannelUpdate`]: events::MessageSendEvent::BroadcastChannelUpdate
 * [`ChannelUpdate`]: msgs::ChannelUpdate
 * [`ChannelUnavailable`]: APIError::ChannelUnavailable
 * [`APIMisuseError`]: APIError::APIMisuseError
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_update_channel_config(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKPublicKey counterparty_node_id, struct LDKCVec_ThirtyTwoBytesZ channel_ids, const struct LDKChannelConfig *NONNULL_PTR config);

/**
 * Attempts to forward an intercepted HTLC over the provided channel id and with the provided
 * amount to forward. Should only be called in response to an [`HTLCIntercepted`] event.
 *
 * Intercepted HTLCs can be useful for Lightning Service Providers (LSPs) to open a just-in-time
 * channel to a receiving node if the node lacks sufficient inbound liquidity.
 *
 * To make use of intercepted HTLCs, set [`UserConfig::accept_intercept_htlcs`] and use
 * [`ChannelManager::get_intercept_scid`] to generate short channel id(s) to put in the
 * receiver's invoice route hints. These route hints will signal to LDK to generate an
 * [`HTLCIntercepted`] event when it receives the forwarded HTLC, and this method or
 * [`ChannelManager::fail_intercepted_htlc`] MUST be called in response to the event.
 *
 * Note that LDK does not enforce fee requirements in `amt_to_forward_msat`, and will not stop
 * you from forwarding more than you received. See
 * [`HTLCIntercepted::expected_outbound_amount_msat`] for more on forwarding a different amount
 * than expected.
 *
 * Errors if the event was not handled in time, in which case the HTLC was automatically failed
 * backwards.
 *
 * [`UserConfig::accept_intercept_htlcs`]: crate::util::config::UserConfig::accept_intercept_htlcs
 * [`HTLCIntercepted`]: events::Event::HTLCIntercepted
 * [`HTLCIntercepted::expected_outbound_amount_msat`]: events::Event::HTLCIntercepted::expected_outbound_amount_msat
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_forward_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id, const uint8_t (*next_hop_channel_id)[32], struct LDKPublicKey next_node_id, uint64_t amt_to_forward_msat);

/**
 * Fails the intercepted HTLC indicated by intercept_id. Should only be called in response to
 * an [`HTLCIntercepted`] event. See [`ChannelManager::forward_intercepted_htlc`].
 *
 * Errors if the event was not handled in time, in which case the HTLC was automatically failed
 * backwards.
 *
 * [`HTLCIntercepted`]: events::Event::HTLCIntercepted
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_fail_intercepted_htlc(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes intercept_id);

/**
 * Processes HTLCs which are pending waiting on random forward delay.
 *
 * Should only really ever be called in response to a PendingHTLCsForwardable event.
 * Will likely generate further events.
 */
void ChannelManager_process_pending_htlc_forwards(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Performs actions which should happen on startup and roughly once per minute thereafter.
 *
 * This currently includes:
 *  * Increasing or decreasing the on-chain feerate estimates for our outbound channels,
 *  * Broadcasting [`ChannelUpdate`] messages if we've been disconnected from our peer for more
 *    than a minute, informing the network that they should no longer attempt to route over
 *    the channel.
 *  * Expiring a channel's previous [`ChannelConfig`] if necessary to only allow forwarding HTLCs
 *    with the current [`ChannelConfig`].
 *  * Removing peers which have disconnected but and no longer have any channels.
 *  * Force-closing and removing channels which have not completed establishment in a timely manner.
 *
 * Note that this may cause reentrancy through [`chain::Watch::update_channel`] calls or feerate
 * estimate fetches.
 *
 * [`ChannelUpdate`]: msgs::ChannelUpdate
 * [`ChannelConfig`]: crate::util::config::ChannelConfig
 */
void ChannelManager_timer_tick_occurred(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Indicates that the preimage for payment_hash is unknown or the received amount is incorrect
 * after a PaymentClaimable event, failing the HTLC back to its origin and freeing resources
 * along the path (including in our own channel on which we received it).
 *
 * Note that in some cases around unclean shutdown, it is possible the payment may have
 * already been claimed by you via [`ChannelManager::claim_funds`] prior to you seeing (a
 * second copy of) the [`events::Event::PaymentClaimable`] event. Alternatively, the payment
 * may have already been failed automatically by LDK if it was nearing its expiration time.
 *
 * While LDK will never claim a payment automatically on your behalf (i.e. without you calling
 * [`ChannelManager::claim_funds`]), you should still monitor for
 * [`events::Event::PaymentClaimed`] events even for payments you intend to fail, especially on
 * startup during which time claims that were in-progress at shutdown may be replayed.
 */
void ChannelManager_fail_htlc_backwards(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32]);

/**
 * This is a variant of [`ChannelManager::fail_htlc_backwards`] that allows you to specify the
 * reason for the failure.
 *
 * See [`FailureCode`] for valid failure codes.
 */
void ChannelManager_fail_htlc_backwards_with_reason(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*payment_hash)[32], struct LDKFailureCode failure_code);

/**
 * Provides a payment preimage in response to [`Event::PaymentClaimable`], generating any
 * [`MessageSendEvent`]s needed to claim the payment.
 *
 * This method is guaranteed to ensure the payment has been claimed but only if the current
 * height is strictly below [`Event::PaymentClaimable::claim_deadline`]. To avoid race
 * conditions, you should wait for an [`Event::PaymentClaimed`] before considering the payment
 * successful. It will generally be available in the next [`process_pending_events`] call.
 *
 * Note that if you did not set an `amount_msat` when calling [`create_inbound_payment`] or
 * [`create_inbound_payment_for_hash`] you must check that the amount in the `PaymentClaimable`
 * event matches your expectation. If you fail to do so and call this method, you may provide
 * the sender \"proof-of-payment\" when they did not fulfill the full expected payment.
 *
 * This function will fail the payment if it has custom TLVs with even type numbers, as we
 * will assume they are unknown. If you intend to accept even custom TLVs, you should use
 * [`claim_funds_with_known_custom_tlvs`].
 *
 * [`Event::PaymentClaimable`]: crate::events::Event::PaymentClaimable
 * [`Event::PaymentClaimable::claim_deadline`]: crate::events::Event::PaymentClaimable::claim_deadline
 * [`Event::PaymentClaimed`]: crate::events::Event::PaymentClaimed
 * [`process_pending_events`]: EventsProvider::process_pending_events
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 * [`claim_funds_with_known_custom_tlvs`]: Self::claim_funds_with_known_custom_tlvs
 */
void ChannelManager_claim_funds(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);

/**
 * This is a variant of [`claim_funds`] that allows accepting a payment with custom TLVs with
 * even type numbers.
 *
 * # Note
 *
 * You MUST check you've understood all even TLVs before using this to
 * claim, otherwise you may unintentionally agree to some protocol you do not understand.
 *
 * [`claim_funds`]: Self::claim_funds
 */
void ChannelManager_claim_funds_with_known_custom_tlvs(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_preimage);

/**
 * Gets the node_id held by this ChannelManager
 */
MUST_USE_RES struct LDKPublicKey ChannelManager_get_our_node_id(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Accepts a request to open a channel after a [`Event::OpenChannelRequest`].
 *
 * The `temporary_channel_id` parameter indicates which inbound channel should be accepted,
 * and the `counterparty_node_id` parameter is the id of the peer which has requested to open
 * the channel.
 *
 * The `user_channel_id` parameter will be provided back in
 * [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
 * with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
 *
 * Note that this method will return an error and reject the channel, if it requires support
 * for zero confirmations. Instead, `accept_inbound_channel_from_trusted_peer_0conf` must be
 * used to accept such channels.
 *
 * [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
 * [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);

/**
 * Accepts a request to open a channel after a [`events::Event::OpenChannelRequest`], treating
 * it as confirmed immediately.
 *
 * The `user_channel_id` parameter will be provided back in
 * [`Event::ChannelClosed::user_channel_id`] to allow tracking of which events correspond
 * with which `accept_inbound_channel`/`accept_inbound_channel_from_trusted_peer_0conf` call.
 *
 * Unlike [`ChannelManager::accept_inbound_channel`], this method accepts the incoming channel
 * and (if the counterparty agrees), enables forwarding of payments immediately.
 *
 * This fully trusts that the counterparty has honestly and correctly constructed the funding
 * transaction and blindly assumes that it will eventually confirm.
 *
 * If it does not confirm before we decide to close the channel, or if the funding transaction
 * does not pay to the correct script the correct amount, *you will lose funds*.
 *
 * [`Event::OpenChannelRequest`]: events::Event::OpenChannelRequest
 * [`Event::ChannelClosed::user_channel_id`]: events::Event::ChannelClosed::user_channel_id
 */
MUST_USE_RES struct LDKCResult_NoneAPIErrorZ ChannelManager_accept_inbound_channel_from_trusted_peer_0conf(const struct LDKChannelManager *NONNULL_PTR this_arg, const uint8_t (*temporary_channel_id)[32], struct LDKPublicKey counterparty_node_id, struct LDKU128 user_channel_id);

/**
 * Gets a payment secret and payment hash for use in an invoice given to a third party wishing
 * to pay us.
 *
 * This differs from [`create_inbound_payment_for_hash`] only in that it generates the
 * [`PaymentHash`] and [`PaymentPreimage`] for you.
 *
 * The [`PaymentPreimage`] will ultimately be returned to you in the [`PaymentClaimable`], which
 * will have the [`PaymentClaimable::purpose`] be [`PaymentPurpose::InvoicePayment`] with
 * its [`PaymentPurpose::InvoicePayment::payment_preimage`] field filled in. That should then be
 * passed directly to [`claim_funds`].
 *
 * See [`create_inbound_payment_for_hash`] for detailed documentation on behavior and requirements.
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * If `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
 * on versions of LDK prior to 0.0.114.
 *
 * [`claim_funds`]: Self::claim_funds
 * [`PaymentClaimable`]: events::Event::PaymentClaimable
 * [`PaymentClaimable::purpose`]: events::Event::PaymentClaimable::purpose
 * [`PaymentPurpose::InvoicePayment`]: events::PaymentPurpose::InvoicePayment
 * [`PaymentPurpose::InvoicePayment::payment_preimage`]: events::PaymentPurpose::InvoicePayment::payment_preimage
 * [`create_inbound_payment_for_hash`]: Self::create_inbound_payment_for_hash
 */
MUST_USE_RES struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ ChannelManager_create_inbound_payment(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * Gets a [`PaymentSecret`] for a given [`PaymentHash`], for which the payment preimage is
 * stored external to LDK.
 *
 * A [`PaymentClaimable`] event will only be generated if the [`PaymentSecret`] matches a
 * payment secret fetched via this method or [`create_inbound_payment`], and which is at least
 * the `min_value_msat` provided here, if one is provided.
 *
 * The [`PaymentHash`] (and corresponding [`PaymentPreimage`]) should be globally unique, though
 * note that LDK will not stop you from registering duplicate payment hashes for inbound
 * payments.
 *
 * `min_value_msat` should be set if the invoice being generated contains a value. Any payment
 * received for the returned [`PaymentHash`] will be required to be at least `min_value_msat`
 * before a [`PaymentClaimable`] event will be generated, ensuring that we do not provide the
 * sender \"proof-of-payment\" unless they have paid the required amount.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time. This should roughly match the expiry time set in the invoice.
 * After this many seconds, we will remove the inbound payment, resulting in any attempts to
 * pay the invoice failing. The BOLT spec suggests 3,600 secs as a default validity time for
 * invoices when no timeout is set.
 *
 * Note that we use block header time to time-out pending inbound payments (with some margin
 * to compensate for the inaccuracy of block header timestamps). Thus, in practice we will
 * accept a payment and generate a [`PaymentClaimable`] event for some time after the expiry.
 * If you need exact expiry semantics, you should enforce them upon receipt of
 * [`PaymentClaimable`].
 *
 * Note that invoices generated for inbound payments should have their `min_final_cltv_expiry_delta`
 * set to at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
 *
 * Note that a malicious eavesdropper can intuit whether an inbound payment was created by
 * `create_inbound_payment` or `create_inbound_payment_for_hash` based on runtime.
 *
 * # Note
 *
 * If you register an inbound payment with this method, then serialize the `ChannelManager`, then
 * deserialize it with a node running 0.0.103 and earlier, the payment will fail to be received.
 *
 * Errors if `min_value_msat` is greater than total bitcoin supply.
 *
 * If `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
 * on versions of LDK prior to 0.0.114.
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 * [`PaymentClaimable`]: events::Event::PaymentClaimable
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesNoneZ ChannelManager_create_inbound_payment_for_hash(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry);

/**
 * Gets an LDK-generated payment preimage from a payment hash and payment secret that were
 * previously returned from [`create_inbound_payment`].
 *
 * [`create_inbound_payment`]: Self::create_inbound_payment
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesAPIErrorZ ChannelManager_get_payment_preimage(const struct LDKChannelManager *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes payment_hash, struct LDKThirtyTwoBytes payment_secret);

/**
 * Gets a fake short channel id for use in receiving [phantom node payments]. These fake scids
 * are used when constructing the phantom invoice's route hints.
 *
 * [phantom node payments]: crate::sign::PhantomKeysManager
 */
MUST_USE_RES uint64_t ChannelManager_get_phantom_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets route hints for use in receiving [phantom node payments].
 *
 * [phantom node payments]: crate::sign::PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomRouteHints ChannelManager_get_phantom_route_hints(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets a fake short channel id for use in receiving intercepted payments. These fake scids are
 * used when constructing the route hints for HTLCs intended to be intercepted. See
 * [`ChannelManager::forward_intercepted_htlc`].
 *
 * Note that this method is not guaranteed to return unique values, you may need to call it a few
 * times to get a unique scid.
 */
MUST_USE_RES uint64_t ChannelManager_get_intercept_scid(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets inflight HTLC information by processing pending outbound payments that are in
 * our channels. May be used during pathfinding to account for in-use channel liquidity.
 */
MUST_USE_RES struct LDKInFlightHtlcs ChannelManager_compute_inflight_htlcs(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ChannelManager_as_MessageSendEventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new EventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EventsProvider must be freed before this_arg is
 */
struct LDKEventsProvider ChannelManager_as_EventsProvider(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Listen which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Listen must be freed before this_arg is
 */
struct LDKListen ChannelManager_as_Listen(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new Confirm which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Confirm must be freed before this_arg is
 */
struct LDKConfirm ChannelManager_as_Confirm(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets a [`Future`] that completes when this [`ChannelManager`] may need to be persisted or
 * may have events that need processing.
 *
 * In order to check if this [`ChannelManager`] needs persisting, call
 * [`Self::get_and_clear_needs_persistence`].
 *
 * Note that callbacks registered on the [`Future`] MUST NOT call back into this
 * [`ChannelManager`] and should instead register actions to be taken later.
 */
MUST_USE_RES struct LDKFuture ChannelManager_get_event_or_persistence_needed_future(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Returns true if this [`ChannelManager`] needs to be persisted.
 */
MUST_USE_RES bool ChannelManager_get_and_clear_needs_persistence(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Gets the latest best block which was connected either via the [`chain::Listen`] or
 * [`chain::Confirm`] interfaces.
 */
MUST_USE_RES struct LDKBestBlock ChannelManager_current_best_block(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`NodeFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
MUST_USE_RES struct LDKNodeFeatures ChannelManager_node_features(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`ChannelFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
MUST_USE_RES struct LDKChannelFeatures ChannelManager_channel_features(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`ChannelTypeFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
MUST_USE_RES struct LDKChannelTypeFeatures ChannelManager_channel_type_features(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`InitFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
MUST_USE_RES struct LDKInitFeatures ChannelManager_init_features(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ChannelManager_as_ChannelMessageHandler(const struct LDKChannelManager *NONNULL_PTR this_arg);

/**
 * Fetches the set of [`InitFeatures`] flags which are provided by or required by
 * [`ChannelManager`].
 */
struct LDKInitFeatures provided_init_features(const struct LDKUserConfig *NONNULL_PTR config);

/**
 * Serialize the CounterpartyForwardingInfo object into a byte array which can be read by CounterpartyForwardingInfo_read
 */
struct LDKCVec_u8Z CounterpartyForwardingInfo_write(const struct LDKCounterpartyForwardingInfo *NONNULL_PTR obj);

/**
 * Read a CounterpartyForwardingInfo from a byte array, created by CounterpartyForwardingInfo_write
 */
struct LDKCResult_CounterpartyForwardingInfoDecodeErrorZ CounterpartyForwardingInfo_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelCounterparty object into a byte array which can be read by ChannelCounterparty_read
 */
struct LDKCVec_u8Z ChannelCounterparty_write(const struct LDKChannelCounterparty *NONNULL_PTR obj);

/**
 * Read a ChannelCounterparty from a byte array, created by ChannelCounterparty_write
 */
struct LDKCResult_ChannelCounterpartyDecodeErrorZ ChannelCounterparty_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelDetails object into a byte array which can be read by ChannelDetails_read
 */
struct LDKCVec_u8Z ChannelDetails_write(const struct LDKChannelDetails *NONNULL_PTR obj);

/**
 * Read a ChannelDetails from a byte array, created by ChannelDetails_write
 */
struct LDKCResult_ChannelDetailsDecodeErrorZ ChannelDetails_read(struct LDKu8slice ser);

/**
 * Serialize the PhantomRouteHints object into a byte array which can be read by PhantomRouteHints_read
 */
struct LDKCVec_u8Z PhantomRouteHints_write(const struct LDKPhantomRouteHints *NONNULL_PTR obj);

/**
 * Read a PhantomRouteHints from a byte array, created by PhantomRouteHints_write
 */
struct LDKCResult_PhantomRouteHintsDecodeErrorZ PhantomRouteHints_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelManager object into a byte array which can be read by ChannelManager_read
 */
struct LDKCVec_u8Z ChannelManager_write(const struct LDKChannelManager *NONNULL_PTR obj);

/**
 * Serialize the ChannelShutdownState object into a byte array which can be read by ChannelShutdownState_read
 */
struct LDKCVec_u8Z ChannelShutdownState_write(const enum LDKChannelShutdownState *NONNULL_PTR obj);

/**
 * Read a ChannelShutdownState from a byte array, created by ChannelShutdownState_write
 */
struct LDKCResult_ChannelShutdownStateDecodeErrorZ ChannelShutdownState_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelManagerReadArgs, if is_owned is set and inner is non-NULL.
 */
void ChannelManagerReadArgs_free(struct LDKChannelManagerReadArgs this_obj);

/**
 * A cryptographically secure source of entropy.
 */
const struct LDKEntropySource *ChannelManagerReadArgs_get_entropy_source(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * A cryptographically secure source of entropy.
 */
void ChannelManagerReadArgs_set_entropy_source(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKEntropySource val);

/**
 * A signer that is able to perform node-scoped cryptographic operations.
 */
const struct LDKNodeSigner *ChannelManagerReadArgs_get_node_signer(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * A signer that is able to perform node-scoped cryptographic operations.
 */
void ChannelManagerReadArgs_set_node_signer(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKNodeSigner val);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
const struct LDKSignerProvider *ChannelManagerReadArgs_get_signer_provider(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The keys provider which will give us relevant keys. Some keys will be loaded during
 * deserialization and KeysInterface::read_chan_signer will be used to read per-Channel
 * signing data.
 */
void ChannelManagerReadArgs_set_signer_provider(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKSignerProvider val);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
const struct LDKFeeEstimator *ChannelManagerReadArgs_get_fee_estimator(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The fee_estimator for use in the ChannelManager in the future.
 *
 * No calls to the FeeEstimator will be made during deserialization.
 */
void ChannelManagerReadArgs_set_fee_estimator(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKFeeEstimator val);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
const struct LDKWatch *ChannelManagerReadArgs_get_chain_monitor(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The chain::Watch for use in the ChannelManager in the future.
 *
 * No calls to the chain::Watch will be made during deserialization. It is assumed that
 * you have deserialized ChannelMonitors separately and will add them to your
 * chain::Watch after deserializing this ChannelManager.
 */
void ChannelManagerReadArgs_set_chain_monitor(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKWatch val);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
const struct LDKBroadcasterInterface *ChannelManagerReadArgs_get_tx_broadcaster(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The BroadcasterInterface which will be used in the ChannelManager in the future and may be
 * used to broadcast the latest local commitment transactions of channels which must be
 * force-closed during deserialization.
 */
void ChannelManagerReadArgs_set_tx_broadcaster(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKBroadcasterInterface val);

/**
 * The router which will be used in the ChannelManager in the future for finding routes
 * on-the-fly for trampoline payments. Absent in private nodes that don't support forwarding.
 *
 * No calls to the router will be made during deserialization.
 */
const struct LDKRouter *ChannelManagerReadArgs_get_router(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The router which will be used in the ChannelManager in the future for finding routes
 * on-the-fly for trampoline payments. Absent in private nodes that don't support forwarding.
 *
 * No calls to the router will be made during deserialization.
 */
void ChannelManagerReadArgs_set_router(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKRouter val);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
const struct LDKLogger *ChannelManagerReadArgs_get_logger(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * The Logger for use in the ChannelManager and which may be used to log information during
 * deserialization.
 */
void ChannelManagerReadArgs_set_logger(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKLogger val);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
struct LDKUserConfig ChannelManagerReadArgs_get_default_config(const struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr);

/**
 * Default settings used for new channels. Any existing channels will continue to use the
 * runtime settings which were stored when the ChannelManager was serialized.
 */
void ChannelManagerReadArgs_set_default_config(struct LDKChannelManagerReadArgs *NONNULL_PTR this_ptr, struct LDKUserConfig val);

/**
 * Simple utility function to create a ChannelManagerReadArgs which creates the monitor
 * HashMap for you. This is primarily useful for C bindings where it is not practical to
 * populate a HashMap directly from C.
 */
MUST_USE_RES struct LDKChannelManagerReadArgs ChannelManagerReadArgs_new(struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKSignerProvider signer_provider, struct LDKFeeEstimator fee_estimator, struct LDKWatch chain_monitor, struct LDKBroadcasterInterface tx_broadcaster, struct LDKRouter router, struct LDKLogger logger, struct LDKUserConfig default_config, struct LDKCVec_ChannelMonitorZ channel_monitors);

/**
 * Read a C2Tuple_ThirtyTwoBytesChannelManagerZ from a byte array, created by C2Tuple_ThirtyTwoBytesChannelManagerZ_write
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesChannelManagerZDecodeErrorZ C2Tuple_ThirtyTwoBytesChannelManagerZ_read(struct LDKu8slice ser, struct LDKChannelManagerReadArgs arg);

/**
 * Frees any resources used by the ExpandedKey, if is_owned is set and inner is non-NULL.
 */
void ExpandedKey_free(struct LDKExpandedKey this_obj);

/**
 * Create a  new [`ExpandedKey`] for generating an inbound payment hash and secret.
 *
 * It is recommended to cache this value and not regenerate it for each new inbound payment.
 */
MUST_USE_RES struct LDKExpandedKey ExpandedKey_new(const uint8_t (*key_material)[32]);

/**
 * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment`], but no
 * `ChannelManager` is required. Useful for generating invoices for [phantom node payments] without
 * a `ChannelManager`.
 *
 * `keys` is generated by calling [`NodeSigner::get_inbound_payment_key_material`] and then
 * calling [`ExpandedKey::new`] with its result. It is recommended to cache this value and not
 * regenerate it for each new inbound payment.
 *
 * `current_time` is a Unix timestamp representing the current time.
 *
 * Note that if `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
 * on versions of LDK prior to 0.0.114.
 *
 * [phantom node payments]: crate::sign::PhantomKeysManager
 * [`NodeSigner::get_inbound_payment_key_material`]: crate::sign::NodeSigner::get_inbound_payment_key_material
 */
struct LDKCResult_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZNoneZ create(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, uint32_t invoice_expiry_delta_secs, const struct LDKEntropySource *NONNULL_PTR entropy_source, uint64_t current_time, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * Equivalent to [`crate::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash`],
 * but no `ChannelManager` is required. Useful for generating invoices for [phantom node payments]
 * without a `ChannelManager`.
 *
 * See [`create`] for information on the `keys` and `current_time` parameters.
 *
 * Note that if `min_final_cltv_expiry_delta` is set to some value, then the payment will not be receivable
 * on versions of LDK prior to 0.0.114.
 *
 * [phantom node payments]: crate::sign::PhantomKeysManager
 */
struct LDKCResult_ThirtyTwoBytesNoneZ create_from_hash(const struct LDKExpandedKey *NONNULL_PTR keys, struct LDKCOption_u64Z min_value_msat, struct LDKThirtyTwoBytes payment_hash, uint32_t invoice_expiry_delta_secs, uint64_t current_time, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * Frees any resources used by the DecodeError
 */
void DecodeError_free(struct LDKDecodeError this_ptr);

/**
 * Creates a copy of the DecodeError
 */
struct LDKDecodeError DecodeError_clone(const struct LDKDecodeError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new UnknownVersion-variant DecodeError
 */
struct LDKDecodeError DecodeError_unknown_version(void);

/**
 * Utility method to constructs a new UnknownRequiredFeature-variant DecodeError
 */
struct LDKDecodeError DecodeError_unknown_required_feature(void);

/**
 * Utility method to constructs a new InvalidValue-variant DecodeError
 */
struct LDKDecodeError DecodeError_invalid_value(void);

/**
 * Utility method to constructs a new ShortRead-variant DecodeError
 */
struct LDKDecodeError DecodeError_short_read(void);

/**
 * Utility method to constructs a new BadLengthDescriptor-variant DecodeError
 */
struct LDKDecodeError DecodeError_bad_length_descriptor(void);

/**
 * Utility method to constructs a new Io-variant DecodeError
 */
struct LDKDecodeError DecodeError_io(enum LDKIOError a);

/**
 * Utility method to constructs a new UnsupportedCompression-variant DecodeError
 */
struct LDKDecodeError DecodeError_unsupported_compression(void);

/**
 * Checks if two DecodeErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool DecodeError_eq(const struct LDKDecodeError *NONNULL_PTR a, const struct LDKDecodeError *NONNULL_PTR b);

/**
 * Frees any resources used by the Init, if is_owned is set and inner is non-NULL.
 */
void Init_free(struct LDKInit this_obj);

/**
 * The relevant features which the sender supports.
 */
struct LDKInitFeatures Init_get_features(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The relevant features which the sender supports.
 */
void Init_set_features(struct LDKInit *NONNULL_PTR this_ptr, struct LDKInitFeatures val);

/**
 * Indicates chains the sender is interested in.
 *
 * If there are no common chains, the connection will be closed.
 *
 * Returns a copy of the field.
 */
struct LDKCOption_CVec_ThirtyTwoBytesZZ Init_get_networks(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * Indicates chains the sender is interested in.
 *
 * If there are no common chains, the connection will be closed.
 */
void Init_set_networks(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_CVec_ThirtyTwoBytesZZ val);

/**
 * The receipient's network address.
 *
 * This adds the option to report a remote IP address back to a connecting peer using the init
 * message. A node can decide to use that information to discover a potential update to its
 * public IPv4 address (NAT) and use that for a [`NodeAnnouncement`] update message containing
 * the new address.
 */
struct LDKCOption_SocketAddressZ Init_get_remote_network_address(const struct LDKInit *NONNULL_PTR this_ptr);

/**
 * The receipient's network address.
 *
 * This adds the option to report a remote IP address back to a connecting peer using the init
 * message. A node can decide to use that information to discover a potential update to its
 * public IPv4 address (NAT) and use that for a [`NodeAnnouncement`] update message containing
 * the new address.
 */
void Init_set_remote_network_address(struct LDKInit *NONNULL_PTR this_ptr, struct LDKCOption_SocketAddressZ val);

/**
 * Constructs a new Init given each field
 */
MUST_USE_RES struct LDKInit Init_new(struct LDKInitFeatures features_arg, struct LDKCOption_CVec_ThirtyTwoBytesZZ networks_arg, struct LDKCOption_SocketAddressZ remote_network_address_arg);

/**
 * Creates a copy of the Init
 */
struct LDKInit Init_clone(const struct LDKInit *NONNULL_PTR orig);

/**
 * Checks if two Inits contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Init_eq(const struct LDKInit *NONNULL_PTR a, const struct LDKInit *NONNULL_PTR b);

/**
 * Frees any resources used by the ErrorMessage, if is_owned is set and inner is non-NULL.
 */
void ErrorMessage_free(struct LDKErrorMessage this_obj);

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
const uint8_t (*ErrorMessage_get_channel_id(const struct LDKErrorMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the error.
 *
 * All-0s indicates a general error unrelated to a specific channel, after which all channels
 * with the sending peer should be closed.
 */
void ErrorMessage_set_channel_id(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable error description.
 *
 * The string should be sanitized before it is used (e.g., emitted to logs or printed to
 * `stdout`). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr ErrorMessage_get_data(const struct LDKErrorMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable error description.
 *
 * The string should be sanitized before it is used (e.g., emitted to logs or printed to
 * `stdout`). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void ErrorMessage_set_data(struct LDKErrorMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new ErrorMessage given each field
 */
MUST_USE_RES struct LDKErrorMessage ErrorMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the ErrorMessage
 */
struct LDKErrorMessage ErrorMessage_clone(const struct LDKErrorMessage *NONNULL_PTR orig);

/**
 * Checks if two ErrorMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ErrorMessage_eq(const struct LDKErrorMessage *NONNULL_PTR a, const struct LDKErrorMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the WarningMessage, if is_owned is set and inner is non-NULL.
 */
void WarningMessage_free(struct LDKWarningMessage this_obj);

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
const uint8_t (*WarningMessage_get_channel_id(const struct LDKWarningMessage *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID involved in the warning.
 *
 * All-0s indicates a warning unrelated to a specific channel.
 */
void WarningMessage_set_channel_id(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A possibly human-readable warning description.
 *
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
struct LDKStr WarningMessage_get_data(const struct LDKWarningMessage *NONNULL_PTR this_ptr);

/**
 * A possibly human-readable warning description.
 *
 * The string should be sanitized before it is used (e.g. emitted to logs or printed to
 * stdout). Otherwise, a well crafted error message may trigger a security vulnerability in
 * the terminal emulator or the logging subsystem.
 */
void WarningMessage_set_data(struct LDKWarningMessage *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * Constructs a new WarningMessage given each field
 */
MUST_USE_RES struct LDKWarningMessage WarningMessage_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKStr data_arg);

/**
 * Creates a copy of the WarningMessage
 */
struct LDKWarningMessage WarningMessage_clone(const struct LDKWarningMessage *NONNULL_PTR orig);

/**
 * Checks if two WarningMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool WarningMessage_eq(const struct LDKWarningMessage *NONNULL_PTR a, const struct LDKWarningMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the Ping, if is_owned is set and inner is non-NULL.
 */
void Ping_free(struct LDKPing this_obj);

/**
 * The desired response length.
 */
uint16_t Ping_get_ponglen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The desired response length.
 */
void Ping_set_ponglen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The ping packet size.
 *
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Ping_get_byteslen(const struct LDKPing *NONNULL_PTR this_ptr);

/**
 * The ping packet size.
 *
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Ping_set_byteslen(struct LDKPing *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Ping given each field
 */
MUST_USE_RES struct LDKPing Ping_new(uint16_t ponglen_arg, uint16_t byteslen_arg);

/**
 * Creates a copy of the Ping
 */
struct LDKPing Ping_clone(const struct LDKPing *NONNULL_PTR orig);

/**
 * Checks if two Pings contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Ping_eq(const struct LDKPing *NONNULL_PTR a, const struct LDKPing *NONNULL_PTR b);

/**
 * Frees any resources used by the Pong, if is_owned is set and inner is non-NULL.
 */
void Pong_free(struct LDKPong this_obj);

/**
 * The pong packet size.
 *
 * This field is not sent on the wire. byteslen zeros are sent.
 */
uint16_t Pong_get_byteslen(const struct LDKPong *NONNULL_PTR this_ptr);

/**
 * The pong packet size.
 *
 * This field is not sent on the wire. byteslen zeros are sent.
 */
void Pong_set_byteslen(struct LDKPong *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new Pong given each field
 */
MUST_USE_RES struct LDKPong Pong_new(uint16_t byteslen_arg);

/**
 * Creates a copy of the Pong
 */
struct LDKPong Pong_clone(const struct LDKPong *NONNULL_PTR orig);

/**
 * Checks if two Pongs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Pong_eq(const struct LDKPong *NONNULL_PTR a, const struct LDKPong *NONNULL_PTR b);

/**
 * Frees any resources used by the OpenChannel, if is_owned is set and inner is non-NULL.
 */
void OpenChannel_free(struct LDKOpenChannel this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannel_get_chain_hash(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannel_set_chain_hash(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*OpenChannel_get_temporary_channel_id(const struct LDKOpenChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void OpenChannel_set_temporary_channel_id(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The channel value
 */
uint64_t OpenChannel_get_funding_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel value
 */
void OpenChannel_set_funding_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
uint64_t OpenChannel_get_push_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The amount to push to the counterparty as part of the open, in milli-satoshi
 */
void OpenChannel_set_push_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t OpenChannel_get_dust_limit_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void OpenChannel_set_dust_limit_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t OpenChannel_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void OpenChannel_set_max_htlc_value_in_flight_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t OpenChannel_get_channel_reserve_satoshis(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void OpenChannel_set_channel_reserve_satoshis(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t OpenChannel_get_htlc_minimum_msat(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void OpenChannel_set_htlc_minimum_msat(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by
 * [`UpdateFee`]
 */
uint32_t OpenChannel_get_feerate_per_kw(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The feerate per 1000-weight of sender generated transactions, until updated by
 * [`UpdateFee`]
 */
void OpenChannel_set_feerate_per_kw(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if
 * they broadcast a commitment transaction
 */
uint16_t OpenChannel_get_to_self_delay(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if
 * they broadcast a commitment transaction
 */
void OpenChannel_set_to_self_delay(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t OpenChannel_get_max_accepted_htlcs(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void OpenChannel_set_max_accepted_htlcs(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannel_get_funding_pubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void OpenChannel_set_funding_pubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_revocation_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannel_set_revocation_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannel_get_payment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void OpenChannel_set_payment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey OpenChannel_get_delayed_payment_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void OpenChannel_set_delayed_payment_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender
 */
struct LDKPublicKey OpenChannel_get_htlc_basepoint(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender
 */
void OpenChannel_set_htlc_basepoint(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey OpenChannel_get_first_per_commitment_point(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void OpenChannel_set_first_per_commitment_point(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The channel flags to be used
 */
uint8_t OpenChannel_get_channel_flags(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel flags to be used
 */
void OpenChannel_set_channel_flags(struct LDKOpenChannel *NONNULL_PTR this_ptr, uint8_t val);

/**
 * A request to pre-set the to-sender output's `scriptPubkey` for when we collaboratively close
 */
struct LDKCOption_CVec_u8ZZ OpenChannel_get_shutdown_scriptpubkey(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * A request to pre-set the to-sender output's `scriptPubkey` for when we collaboratively close
 */
void OpenChannel_set_shutdown_scriptpubkey(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * The channel type that this channel will represent
 *
 * If this is `None`, we derive the channel type from the intersection of our
 * feature bits with our counterparty's feature bits from the [`Init`] message.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures OpenChannel_get_channel_type(const struct LDKOpenChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent
 *
 * If this is `None`, we derive the channel type from the intersection of our
 * feature bits with our counterparty's feature bits from the [`Init`] message.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void OpenChannel_set_channel_type(struct LDKOpenChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Constructs a new OpenChannel given each field
 *
 * Note that channel_type_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKOpenChannel OpenChannel_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t funding_satoshis_arg, uint64_t push_msat_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t channel_reserve_satoshis_arg, uint64_t htlc_minimum_msat_arg, uint32_t feerate_per_kw_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, uint8_t channel_flags_arg, struct LDKCOption_CVec_u8ZZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg);

/**
 * Creates a copy of the OpenChannel
 */
struct LDKOpenChannel OpenChannel_clone(const struct LDKOpenChannel *NONNULL_PTR orig);

/**
 * Checks if two OpenChannels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OpenChannel_eq(const struct LDKOpenChannel *NONNULL_PTR a, const struct LDKOpenChannel *NONNULL_PTR b);

/**
 * Frees any resources used by the OpenChannelV2, if is_owned is set and inner is non-NULL.
 */
void OpenChannelV2_free(struct LDKOpenChannelV2 this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*OpenChannelV2_get_chain_hash(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void OpenChannelV2_set_chain_hash(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A temporary channel ID derived using a zeroed out value for the channel acceptor's revocation basepoint
 */
const uint8_t (*OpenChannelV2_get_temporary_channel_id(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID derived using a zeroed out value for the channel acceptor's revocation basepoint
 */
void OpenChannelV2_set_temporary_channel_id(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The feerate for the funding transaction set by the channel initiator
 */
uint32_t OpenChannelV2_get_funding_feerate_sat_per_1000_weight(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The feerate for the funding transaction set by the channel initiator
 */
void OpenChannelV2_set_funding_feerate_sat_per_1000_weight(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The feerate for the commitment transaction set by the channel initiator
 */
uint32_t OpenChannelV2_get_commitment_feerate_sat_per_1000_weight(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The feerate for the commitment transaction set by the channel initiator
 */
void OpenChannelV2_set_commitment_feerate_sat_per_1000_weight(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Part of the channel value contributed by the channel initiator
 */
uint64_t OpenChannelV2_get_funding_satoshis(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Part of the channel value contributed by the channel initiator
 */
void OpenChannelV2_set_funding_satoshis(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by the channel initiator will be
 * omitted
 */
uint64_t OpenChannelV2_get_dust_limit_satoshis(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by the channel initiator will be
 * omitted
 */
void OpenChannelV2_set_dust_limit_satoshis(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards channel initiator, in milli-satoshi
 */
uint64_t OpenChannelV2_get_max_htlc_value_in_flight_msat(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards channel initiator, in milli-satoshi
 */
void OpenChannelV2_set_max_htlc_value_in_flight_msat(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to channel initiator, in milli-satoshi
 */
uint64_t OpenChannelV2_get_htlc_minimum_msat(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to channel initiator, in milli-satoshi
 */
void OpenChannelV2_set_htlc_minimum_msat(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they
 * broadcast a commitment transaction
 */
uint16_t OpenChannelV2_get_to_self_delay(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they
 * broadcast a commitment transaction
 */
void OpenChannelV2_set_to_self_delay(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards channel initiator
 */
uint16_t OpenChannelV2_get_max_accepted_htlcs(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards channel initiator
 */
void OpenChannelV2_set_max_accepted_htlcs(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The locktime for the funding transaction
 */
uint32_t OpenChannelV2_get_locktime(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The locktime for the funding transaction
 */
void OpenChannelV2_set_locktime(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The channel initiator's key controlling the funding transaction
 */
struct LDKPublicKey OpenChannelV2_get_funding_pubkey(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The channel initiator's key controlling the funding transaction
 */
void OpenChannelV2_set_funding_pubkey(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannelV2_get_revocation_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void OpenChannelV2_set_revocation_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to channel initiator for transactions broadcast by counterparty
 */
struct LDKPublicKey OpenChannelV2_get_payment_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * A payment key to channel initiator for transactions broadcast by counterparty
 */
void OpenChannelV2_set_payment_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to channel initiator for transactions broadcast by channel
 * initiator
 */
struct LDKPublicKey OpenChannelV2_get_delayed_payment_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to channel initiator for transactions broadcast by channel
 * initiator
 */
void OpenChannelV2_set_delayed_payment_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to channel initiator
 */
struct LDKPublicKey OpenChannelV2_get_htlc_basepoint(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to channel initiator
 */
void OpenChannelV2_set_htlc_basepoint(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-channel-initiator transaction's per commitment point
 */
struct LDKPublicKey OpenChannelV2_get_first_per_commitment_point(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-channel-initiator transaction's per commitment point
 */
void OpenChannelV2_set_first_per_commitment_point(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The second to-be-broadcast-by-channel-initiator transaction's per commitment point
 */
struct LDKPublicKey OpenChannelV2_get_second_per_commitment_point(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The second to-be-broadcast-by-channel-initiator transaction's per commitment point
 */
void OpenChannelV2_set_second_per_commitment_point(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Channel flags
 */
uint8_t OpenChannelV2_get_channel_flags(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void OpenChannelV2_set_channel_flags(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, uint8_t val);

/**
 * Optionally, a request to pre-set the to-channel-initiator output's scriptPubkey for when we
 * collaboratively close
 */
struct LDKCOption_CVec_u8ZZ OpenChannelV2_get_shutdown_scriptpubkey(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Optionally, a request to pre-set the to-channel-initiator output's scriptPubkey for when we
 * collaboratively close
 */
void OpenChannelV2_set_shutdown_scriptpubkey(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures OpenChannelV2_get_channel_type(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void OpenChannelV2_set_channel_type(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Optionally, a requirement that only confirmed inputs can be added
 */
enum LDKCOption_NoneZ OpenChannelV2_get_require_confirmed_inputs(const struct LDKOpenChannelV2 *NONNULL_PTR this_ptr);

/**
 * Optionally, a requirement that only confirmed inputs can be added
 */
void OpenChannelV2_set_require_confirmed_inputs(struct LDKOpenChannelV2 *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);

/**
 * Constructs a new OpenChannelV2 given each field
 *
 * Note that channel_type_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKOpenChannelV2 OpenChannelV2_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKThirtyTwoBytes temporary_channel_id_arg, uint32_t funding_feerate_sat_per_1000_weight_arg, uint32_t commitment_feerate_sat_per_1000_weight_arg, uint64_t funding_satoshis_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t htlc_minimum_msat_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, uint32_t locktime_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_basepoint_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKPublicKey second_per_commitment_point_arg, uint8_t channel_flags_arg, struct LDKCOption_CVec_u8ZZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg, enum LDKCOption_NoneZ require_confirmed_inputs_arg);

/**
 * Creates a copy of the OpenChannelV2
 */
struct LDKOpenChannelV2 OpenChannelV2_clone(const struct LDKOpenChannelV2 *NONNULL_PTR orig);

/**
 * Checks if two OpenChannelV2s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OpenChannelV2_eq(const struct LDKOpenChannelV2 *NONNULL_PTR a, const struct LDKOpenChannelV2 *NONNULL_PTR b);

/**
 * Frees any resources used by the AcceptChannel, if is_owned is set and inner is non-NULL.
 */
void AcceptChannel_free(struct LDKAcceptChannel this_obj);

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
const uint8_t (*AcceptChannel_get_temporary_channel_id(const struct LDKAcceptChannel *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding outpoint is announced
 */
void AcceptChannel_set_temporary_channel_id(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
uint64_t AcceptChannel_get_dust_limit_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by sender will be omitted
 */
void AcceptChannel_set_dust_limit_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards sender, in milli-satoshi
 */
void AcceptChannel_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
uint64_t AcceptChannel_get_channel_reserve_satoshis(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum value unencumbered by HTLCs for the counterparty to keep in the channel
 */
void AcceptChannel_set_channel_reserve_satoshis(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t AcceptChannel_get_htlc_minimum_msat(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void AcceptChannel_set_htlc_minimum_msat(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannel_get_minimum_depth(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannel_set_minimum_depth(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
uint16_t AcceptChannel_get_to_self_delay(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they broadcast a commitment transaction
 */
void AcceptChannel_set_to_self_delay(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards sender
 */
uint16_t AcceptChannel_get_max_accepted_htlcs(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards sender
 */
void AcceptChannel_set_max_accepted_htlcs(struct LDKAcceptChannel *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The sender's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannel_get_funding_pubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The sender's key controlling the funding transaction
 */
void AcceptChannel_set_funding_pubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_revocation_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannel_set_revocation_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_payment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_payment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
struct LDKPublicKey AcceptChannel_get_delayed_payment_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to sender for transactions broadcast by sender
 */
void AcceptChannel_set_delayed_payment_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannel_get_htlc_basepoint(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to sender for transactions broadcast by counterparty
 */
void AcceptChannel_set_htlc_basepoint(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
struct LDKPublicKey AcceptChannel_get_first_per_commitment_point(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-sender transaction's per commitment point
 */
void AcceptChannel_set_first_per_commitment_point(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A request to pre-set the to-sender output's scriptPubkey for when we collaboratively close
 */
struct LDKCOption_CVec_u8ZZ AcceptChannel_get_shutdown_scriptpubkey(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * A request to pre-set the to-sender output's scriptPubkey for when we collaboratively close
 */
void AcceptChannel_set_shutdown_scriptpubkey(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * The channel type that this channel will represent.
 *
 * If this is `None`, we derive the channel type from the intersection of
 * our feature bits with our counterparty's feature bits from the [`Init`] message.
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures AcceptChannel_get_channel_type(const struct LDKAcceptChannel *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent.
 *
 * If this is `None`, we derive the channel type from the intersection of
 * our feature bits with our counterparty's feature bits from the [`Init`] message.
 * This is required to match the equivalent field in [`OpenChannel::channel_type`].
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void AcceptChannel_set_channel_type(struct LDKAcceptChannel *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Constructs a new AcceptChannel given each field
 *
 * Note that channel_type_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAcceptChannel AcceptChannel_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t channel_reserve_satoshis_arg, uint64_t htlc_minimum_msat_arg, uint32_t minimum_depth_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKCOption_CVec_u8ZZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg);

/**
 * Creates a copy of the AcceptChannel
 */
struct LDKAcceptChannel AcceptChannel_clone(const struct LDKAcceptChannel *NONNULL_PTR orig);

/**
 * Checks if two AcceptChannels contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AcceptChannel_eq(const struct LDKAcceptChannel *NONNULL_PTR a, const struct LDKAcceptChannel *NONNULL_PTR b);

/**
 * Frees any resources used by the AcceptChannelV2, if is_owned is set and inner is non-NULL.
 */
void AcceptChannelV2_free(struct LDKAcceptChannelV2 this_obj);

/**
 * The same `temporary_channel_id` received from the initiator's `open_channel2` message.
 */
const uint8_t (*AcceptChannelV2_get_temporary_channel_id(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr))[32];

/**
 * The same `temporary_channel_id` received from the initiator's `open_channel2` message.
 */
void AcceptChannelV2_set_temporary_channel_id(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Part of the channel value contributed by the channel acceptor
 */
uint64_t AcceptChannelV2_get_funding_satoshis(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Part of the channel value contributed by the channel acceptor
 */
void AcceptChannelV2_set_funding_satoshis(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The threshold below which outputs on transactions broadcast by the channel acceptor will be
 * omitted
 */
uint64_t AcceptChannelV2_get_dust_limit_satoshis(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The threshold below which outputs on transactions broadcast by the channel acceptor will be
 * omitted
 */
void AcceptChannelV2_set_dust_limit_satoshis(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum inbound HTLC value in flight towards channel acceptor, in milli-satoshi
 */
uint64_t AcceptChannelV2_get_max_htlc_value_in_flight_msat(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The maximum inbound HTLC value in flight towards channel acceptor, in milli-satoshi
 */
void AcceptChannelV2_set_max_htlc_value_in_flight_msat(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The minimum HTLC size incoming to channel acceptor, in milli-satoshi
 */
uint64_t AcceptChannelV2_get_htlc_minimum_msat(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to channel acceptor, in milli-satoshi
 */
void AcceptChannelV2_set_htlc_minimum_msat(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
uint32_t AcceptChannelV2_get_minimum_depth(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Minimum depth of the funding transaction before the channel is considered open
 */
void AcceptChannelV2_set_minimum_depth(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they
 * broadcast a commitment transaction
 */
uint16_t AcceptChannelV2_get_to_self_delay(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The number of blocks which the counterparty will have to wait to claim on-chain funds if they
 * broadcast a commitment transaction
 */
void AcceptChannelV2_set_to_self_delay(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The maximum number of inbound HTLCs towards channel acceptor
 */
uint16_t AcceptChannelV2_get_max_accepted_htlcs(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The maximum number of inbound HTLCs towards channel acceptor
 */
void AcceptChannelV2_set_max_accepted_htlcs(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The channel acceptor's key controlling the funding transaction
 */
struct LDKPublicKey AcceptChannelV2_get_funding_pubkey(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The channel acceptor's key controlling the funding transaction
 */
void AcceptChannelV2_set_funding_pubkey(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannelV2_get_revocation_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive a revocation key for transactions broadcast by counterparty
 */
void AcceptChannelV2_set_revocation_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * A payment key to channel acceptor for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannelV2_get_payment_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * A payment key to channel acceptor for transactions broadcast by counterparty
 */
void AcceptChannelV2_set_payment_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive a payment key to channel acceptor for transactions broadcast by channel
 * acceptor
 */
struct LDKPublicKey AcceptChannelV2_get_delayed_payment_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive a payment key to channel acceptor for transactions broadcast by channel
 * acceptor
 */
void AcceptChannelV2_set_delayed_payment_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used to derive an HTLC payment key to channel acceptor for transactions broadcast by counterparty
 */
struct LDKPublicKey AcceptChannelV2_get_htlc_basepoint(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Used to derive an HTLC payment key to channel acceptor for transactions broadcast by counterparty
 */
void AcceptChannelV2_set_htlc_basepoint(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The first to-be-broadcast-by-channel-acceptor transaction's per commitment point
 */
struct LDKPublicKey AcceptChannelV2_get_first_per_commitment_point(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The first to-be-broadcast-by-channel-acceptor transaction's per commitment point
 */
void AcceptChannelV2_set_first_per_commitment_point(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The second to-be-broadcast-by-channel-acceptor transaction's per commitment point
 */
struct LDKPublicKey AcceptChannelV2_get_second_per_commitment_point(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The second to-be-broadcast-by-channel-acceptor transaction's per commitment point
 */
void AcceptChannelV2_set_second_per_commitment_point(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Optionally, a request to pre-set the to-channel-acceptor output's scriptPubkey for when we
 * collaboratively close
 */
struct LDKCOption_CVec_u8ZZ AcceptChannelV2_get_shutdown_scriptpubkey(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Optionally, a request to pre-set the to-channel-acceptor output's scriptPubkey for when we
 * collaboratively close
 */
void AcceptChannelV2_set_shutdown_scriptpubkey(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannelV2::channel_type`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTypeFeatures AcceptChannelV2_get_channel_type(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * The channel type that this channel will represent. If none is set, we derive the channel
 * type from the intersection of our feature bits with our counterparty's feature bits from
 * the Init message.
 *
 * This is required to match the equivalent field in [`OpenChannelV2::channel_type`].
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void AcceptChannelV2_set_channel_type(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Optionally, a requirement that only confirmed inputs can be added
 */
enum LDKCOption_NoneZ AcceptChannelV2_get_require_confirmed_inputs(const struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr);

/**
 * Optionally, a requirement that only confirmed inputs can be added
 */
void AcceptChannelV2_set_require_confirmed_inputs(struct LDKAcceptChannelV2 *NONNULL_PTR this_ptr, enum LDKCOption_NoneZ val);

/**
 * Constructs a new AcceptChannelV2 given each field
 *
 * Note that channel_type_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAcceptChannelV2 AcceptChannelV2_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, uint64_t funding_satoshis_arg, uint64_t dust_limit_satoshis_arg, uint64_t max_htlc_value_in_flight_msat_arg, uint64_t htlc_minimum_msat_arg, uint32_t minimum_depth_arg, uint16_t to_self_delay_arg, uint16_t max_accepted_htlcs_arg, struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_basepoint_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg, struct LDKPublicKey first_per_commitment_point_arg, struct LDKPublicKey second_per_commitment_point_arg, struct LDKCOption_CVec_u8ZZ shutdown_scriptpubkey_arg, struct LDKChannelTypeFeatures channel_type_arg, enum LDKCOption_NoneZ require_confirmed_inputs_arg);

/**
 * Creates a copy of the AcceptChannelV2
 */
struct LDKAcceptChannelV2 AcceptChannelV2_clone(const struct LDKAcceptChannelV2 *NONNULL_PTR orig);

/**
 * Checks if two AcceptChannelV2s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AcceptChannelV2_eq(const struct LDKAcceptChannelV2 *NONNULL_PTR a, const struct LDKAcceptChannelV2 *NONNULL_PTR b);

/**
 * Frees any resources used by the FundingCreated, if is_owned is set and inner is non-NULL.
 */
void FundingCreated_free(struct LDKFundingCreated this_obj);

/**
 * A temporary channel ID, until the funding is established
 */
const uint8_t (*FundingCreated_get_temporary_channel_id(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * A temporary channel ID, until the funding is established
 */
void FundingCreated_set_temporary_channel_id(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The funding transaction ID
 */
const uint8_t (*FundingCreated_get_funding_txid(const struct LDKFundingCreated *NONNULL_PTR this_ptr))[32];

/**
 * The funding transaction ID
 */
void FundingCreated_set_funding_txid(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The specific output index funding this channel
 */
uint16_t FundingCreated_get_funding_output_index(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The specific output index funding this channel
 */
void FundingCreated_set_funding_output_index(struct LDKFundingCreated *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
struct LDKECDSASignature FundingCreated_get_signature(const struct LDKFundingCreated *NONNULL_PTR this_ptr);

/**
 * The signature of the channel initiator (funder) on the initial commitment transaction
 */
void FundingCreated_set_signature(struct LDKFundingCreated *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Constructs a new FundingCreated given each field
 */
MUST_USE_RES struct LDKFundingCreated FundingCreated_new(struct LDKThirtyTwoBytes temporary_channel_id_arg, struct LDKThirtyTwoBytes funding_txid_arg, uint16_t funding_output_index_arg, struct LDKECDSASignature signature_arg);

/**
 * Creates a copy of the FundingCreated
 */
struct LDKFundingCreated FundingCreated_clone(const struct LDKFundingCreated *NONNULL_PTR orig);

/**
 * Checks if two FundingCreateds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool FundingCreated_eq(const struct LDKFundingCreated *NONNULL_PTR a, const struct LDKFundingCreated *NONNULL_PTR b);

/**
 * Frees any resources used by the FundingSigned, if is_owned is set and inner is non-NULL.
 */
void FundingSigned_free(struct LDKFundingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*FundingSigned_get_channel_id(const struct LDKFundingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void FundingSigned_set_channel_id(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
struct LDKECDSASignature FundingSigned_get_signature(const struct LDKFundingSigned *NONNULL_PTR this_ptr);

/**
 * The signature of the channel acceptor (fundee) on the initial commitment transaction
 */
void FundingSigned_set_signature(struct LDKFundingSigned *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Constructs a new FundingSigned given each field
 */
MUST_USE_RES struct LDKFundingSigned FundingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKECDSASignature signature_arg);

/**
 * Creates a copy of the FundingSigned
 */
struct LDKFundingSigned FundingSigned_clone(const struct LDKFundingSigned *NONNULL_PTR orig);

/**
 * Checks if two FundingSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool FundingSigned_eq(const struct LDKFundingSigned *NONNULL_PTR a, const struct LDKFundingSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelReady, if is_owned is set and inner is non-NULL.
 */
void ChannelReady_free(struct LDKChannelReady this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReady_get_channel_id(const struct LDKChannelReady *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReady_set_channel_id(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The per-commitment point of the second commitment transaction
 */
struct LDKPublicKey ChannelReady_get_next_per_commitment_point(const struct LDKChannelReady *NONNULL_PTR this_ptr);

/**
 * The per-commitment point of the second commitment transaction
 */
void ChannelReady_set_next_per_commitment_point(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * If set, provides a `short_channel_id` alias for this channel.
 *
 * The sender will accept payments to be forwarded over this SCID and forward them to this
 * messages' recipient.
 */
struct LDKCOption_u64Z ChannelReady_get_short_channel_id_alias(const struct LDKChannelReady *NONNULL_PTR this_ptr);

/**
 * If set, provides a `short_channel_id` alias for this channel.
 *
 * The sender will accept payments to be forwarded over this SCID and forward them to this
 * messages' recipient.
 */
void ChannelReady_set_short_channel_id_alias(struct LDKChannelReady *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new ChannelReady given each field
 */
MUST_USE_RES struct LDKChannelReady ChannelReady_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKPublicKey next_per_commitment_point_arg, struct LDKCOption_u64Z short_channel_id_alias_arg);

/**
 * Creates a copy of the ChannelReady
 */
struct LDKChannelReady ChannelReady_clone(const struct LDKChannelReady *NONNULL_PTR orig);

/**
 * Checks if two ChannelReadys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelReady_eq(const struct LDKChannelReady *NONNULL_PTR a, const struct LDKChannelReady *NONNULL_PTR b);

/**
 * Frees any resources used by the TxAddInput, if is_owned is set and inner is non-NULL.
 */
void TxAddInput_free(struct LDKTxAddInput this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxAddInput_get_channel_id(const struct LDKTxAddInput *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxAddInput_set_channel_id(struct LDKTxAddInput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A randomly chosen unique identifier for this input, which is even for initiators and odd for
 * non-initiators.
 */
uint64_t TxAddInput_get_serial_id(const struct LDKTxAddInput *NONNULL_PTR this_ptr);

/**
 * A randomly chosen unique identifier for this input, which is even for initiators and odd for
 * non-initiators.
 */
void TxAddInput_set_serial_id(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Serialized transaction that contains the output this input spends to verify that it is non
 * malleable.
 */
struct LDKTransactionU16LenLimited TxAddInput_get_prevtx(const struct LDKTxAddInput *NONNULL_PTR this_ptr);

/**
 * Serialized transaction that contains the output this input spends to verify that it is non
 * malleable.
 */
void TxAddInput_set_prevtx(struct LDKTxAddInput *NONNULL_PTR this_ptr, struct LDKTransactionU16LenLimited val);

/**
 * The index of the output being spent
 */
uint32_t TxAddInput_get_prevtx_out(const struct LDKTxAddInput *NONNULL_PTR this_ptr);

/**
 * The index of the output being spent
 */
void TxAddInput_set_prevtx_out(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The sequence number of this input
 */
uint32_t TxAddInput_get_sequence(const struct LDKTxAddInput *NONNULL_PTR this_ptr);

/**
 * The sequence number of this input
 */
void TxAddInput_set_sequence(struct LDKTxAddInput *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new TxAddInput given each field
 */
MUST_USE_RES struct LDKTxAddInput TxAddInput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg, struct LDKTransactionU16LenLimited prevtx_arg, uint32_t prevtx_out_arg, uint32_t sequence_arg);

/**
 * Creates a copy of the TxAddInput
 */
struct LDKTxAddInput TxAddInput_clone(const struct LDKTxAddInput *NONNULL_PTR orig);

/**
 * Checks if two TxAddInputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxAddInput_eq(const struct LDKTxAddInput *NONNULL_PTR a, const struct LDKTxAddInput *NONNULL_PTR b);

/**
 * Frees any resources used by the TxAddOutput, if is_owned is set and inner is non-NULL.
 */
void TxAddOutput_free(struct LDKTxAddOutput this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxAddOutput_get_channel_id(const struct LDKTxAddOutput *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxAddOutput_set_channel_id(struct LDKTxAddOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A randomly chosen unique identifier for this output, which is even for initiators and odd for
 * non-initiators.
 */
uint64_t TxAddOutput_get_serial_id(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);

/**
 * A randomly chosen unique identifier for this output, which is even for initiators and odd for
 * non-initiators.
 */
void TxAddOutput_set_serial_id(struct LDKTxAddOutput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The satoshi value of the output
 */
uint64_t TxAddOutput_get_sats(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);

/**
 * The satoshi value of the output
 */
void TxAddOutput_set_sats(struct LDKTxAddOutput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The scriptPubKey for the output
 */
struct LDKu8slice TxAddOutput_get_script(const struct LDKTxAddOutput *NONNULL_PTR this_ptr);

/**
 * The scriptPubKey for the output
 */
void TxAddOutput_set_script(struct LDKTxAddOutput *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new TxAddOutput given each field
 */
MUST_USE_RES struct LDKTxAddOutput TxAddOutput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg, uint64_t sats_arg, struct LDKCVec_u8Z script_arg);

/**
 * Creates a copy of the TxAddOutput
 */
struct LDKTxAddOutput TxAddOutput_clone(const struct LDKTxAddOutput *NONNULL_PTR orig);

/**
 * Checks if two TxAddOutputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxAddOutput_eq(const struct LDKTxAddOutput *NONNULL_PTR a, const struct LDKTxAddOutput *NONNULL_PTR b);

/**
 * Frees any resources used by the TxRemoveInput, if is_owned is set and inner is non-NULL.
 */
void TxRemoveInput_free(struct LDKTxRemoveInput this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxRemoveInput_get_channel_id(const struct LDKTxRemoveInput *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxRemoveInput_set_channel_id(struct LDKTxRemoveInput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The serial ID of the input to be removed
 */
uint64_t TxRemoveInput_get_serial_id(const struct LDKTxRemoveInput *NONNULL_PTR this_ptr);

/**
 * The serial ID of the input to be removed
 */
void TxRemoveInput_set_serial_id(struct LDKTxRemoveInput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new TxRemoveInput given each field
 */
MUST_USE_RES struct LDKTxRemoveInput TxRemoveInput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg);

/**
 * Creates a copy of the TxRemoveInput
 */
struct LDKTxRemoveInput TxRemoveInput_clone(const struct LDKTxRemoveInput *NONNULL_PTR orig);

/**
 * Checks if two TxRemoveInputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxRemoveInput_eq(const struct LDKTxRemoveInput *NONNULL_PTR a, const struct LDKTxRemoveInput *NONNULL_PTR b);

/**
 * Frees any resources used by the TxRemoveOutput, if is_owned is set and inner is non-NULL.
 */
void TxRemoveOutput_free(struct LDKTxRemoveOutput this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxRemoveOutput_get_channel_id(const struct LDKTxRemoveOutput *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxRemoveOutput_set_channel_id(struct LDKTxRemoveOutput *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The serial ID of the output to be removed
 */
uint64_t TxRemoveOutput_get_serial_id(const struct LDKTxRemoveOutput *NONNULL_PTR this_ptr);

/**
 * The serial ID of the output to be removed
 */
void TxRemoveOutput_set_serial_id(struct LDKTxRemoveOutput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new TxRemoveOutput given each field
 */
MUST_USE_RES struct LDKTxRemoveOutput TxRemoveOutput_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t serial_id_arg);

/**
 * Creates a copy of the TxRemoveOutput
 */
struct LDKTxRemoveOutput TxRemoveOutput_clone(const struct LDKTxRemoveOutput *NONNULL_PTR orig);

/**
 * Checks if two TxRemoveOutputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxRemoveOutput_eq(const struct LDKTxRemoveOutput *NONNULL_PTR a, const struct LDKTxRemoveOutput *NONNULL_PTR b);

/**
 * Frees any resources used by the TxComplete, if is_owned is set and inner is non-NULL.
 */
void TxComplete_free(struct LDKTxComplete this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxComplete_get_channel_id(const struct LDKTxComplete *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxComplete_set_channel_id(struct LDKTxComplete *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new TxComplete given each field
 */
MUST_USE_RES struct LDKTxComplete TxComplete_new(struct LDKThirtyTwoBytes channel_id_arg);

/**
 * Creates a copy of the TxComplete
 */
struct LDKTxComplete TxComplete_clone(const struct LDKTxComplete *NONNULL_PTR orig);

/**
 * Checks if two TxCompletes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxComplete_eq(const struct LDKTxComplete *NONNULL_PTR a, const struct LDKTxComplete *NONNULL_PTR b);

/**
 * Frees any resources used by the TxSignatures, if is_owned is set and inner is non-NULL.
 */
void TxSignatures_free(struct LDKTxSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxSignatures_get_channel_id(const struct LDKTxSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxSignatures_set_channel_id(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The TXID
 */
const uint8_t (*TxSignatures_get_tx_hash(const struct LDKTxSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The TXID
 */
void TxSignatures_set_tx_hash(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The list of witnesses
 *
 * Returns a copy of the field.
 */
struct LDKCVec_WitnessZ TxSignatures_get_witnesses(const struct LDKTxSignatures *NONNULL_PTR this_ptr);

/**
 * The list of witnesses
 */
void TxSignatures_set_witnesses(struct LDKTxSignatures *NONNULL_PTR this_ptr, struct LDKCVec_WitnessZ val);

/**
 * Constructs a new TxSignatures given each field
 */
MUST_USE_RES struct LDKTxSignatures TxSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes tx_hash_arg, struct LDKCVec_WitnessZ witnesses_arg);

/**
 * Creates a copy of the TxSignatures
 */
struct LDKTxSignatures TxSignatures_clone(const struct LDKTxSignatures *NONNULL_PTR orig);

/**
 * Checks if two TxSignaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxSignatures_eq(const struct LDKTxSignatures *NONNULL_PTR a, const struct LDKTxSignatures *NONNULL_PTR b);

/**
 * Frees any resources used by the TxInitRbf, if is_owned is set and inner is non-NULL.
 */
void TxInitRbf_free(struct LDKTxInitRbf this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxInitRbf_get_channel_id(const struct LDKTxInitRbf *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxInitRbf_set_channel_id(struct LDKTxInitRbf *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The locktime of the transaction
 */
uint32_t TxInitRbf_get_locktime(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);

/**
 * The locktime of the transaction
 */
void TxInitRbf_set_locktime(struct LDKTxInitRbf *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The feerate of the transaction
 */
uint32_t TxInitRbf_get_feerate_sat_per_1000_weight(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);

/**
 * The feerate of the transaction
 */
void TxInitRbf_set_feerate_sat_per_1000_weight(struct LDKTxInitRbf *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of satoshis the sender will contribute to or, if negative, remove from
 * (e.g. splice-out) the funding output of the transaction
 */
struct LDKCOption_i64Z TxInitRbf_get_funding_output_contribution(const struct LDKTxInitRbf *NONNULL_PTR this_ptr);

/**
 * The number of satoshis the sender will contribute to or, if negative, remove from
 * (e.g. splice-out) the funding output of the transaction
 */
void TxInitRbf_set_funding_output_contribution(struct LDKTxInitRbf *NONNULL_PTR this_ptr, struct LDKCOption_i64Z val);

/**
 * Constructs a new TxInitRbf given each field
 */
MUST_USE_RES struct LDKTxInitRbf TxInitRbf_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t locktime_arg, uint32_t feerate_sat_per_1000_weight_arg, struct LDKCOption_i64Z funding_output_contribution_arg);

/**
 * Creates a copy of the TxInitRbf
 */
struct LDKTxInitRbf TxInitRbf_clone(const struct LDKTxInitRbf *NONNULL_PTR orig);

/**
 * Checks if two TxInitRbfs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxInitRbf_eq(const struct LDKTxInitRbf *NONNULL_PTR a, const struct LDKTxInitRbf *NONNULL_PTR b);

/**
 * Frees any resources used by the TxAckRbf, if is_owned is set and inner is non-NULL.
 */
void TxAckRbf_free(struct LDKTxAckRbf this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxAckRbf_get_channel_id(const struct LDKTxAckRbf *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxAckRbf_set_channel_id(struct LDKTxAckRbf *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The number of satoshis the sender will contribute to or, if negative, remove from
 * (e.g. splice-out) the funding output of the transaction
 */
struct LDKCOption_i64Z TxAckRbf_get_funding_output_contribution(const struct LDKTxAckRbf *NONNULL_PTR this_ptr);

/**
 * The number of satoshis the sender will contribute to or, if negative, remove from
 * (e.g. splice-out) the funding output of the transaction
 */
void TxAckRbf_set_funding_output_contribution(struct LDKTxAckRbf *NONNULL_PTR this_ptr, struct LDKCOption_i64Z val);

/**
 * Constructs a new TxAckRbf given each field
 */
MUST_USE_RES struct LDKTxAckRbf TxAckRbf_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCOption_i64Z funding_output_contribution_arg);

/**
 * Creates a copy of the TxAckRbf
 */
struct LDKTxAckRbf TxAckRbf_clone(const struct LDKTxAckRbf *NONNULL_PTR orig);

/**
 * Checks if two TxAckRbfs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxAckRbf_eq(const struct LDKTxAckRbf *NONNULL_PTR a, const struct LDKTxAckRbf *NONNULL_PTR b);

/**
 * Frees any resources used by the TxAbort, if is_owned is set and inner is non-NULL.
 */
void TxAbort_free(struct LDKTxAbort this_obj);

/**
 * The channel ID
 */
const uint8_t (*TxAbort_get_channel_id(const struct LDKTxAbort *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void TxAbort_set_channel_id(struct LDKTxAbort *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Message data
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z TxAbort_get_data(const struct LDKTxAbort *NONNULL_PTR this_ptr);

/**
 * Message data
 */
void TxAbort_set_data(struct LDKTxAbort *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new TxAbort given each field
 */
MUST_USE_RES struct LDKTxAbort TxAbort_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z data_arg);

/**
 * Creates a copy of the TxAbort
 */
struct LDKTxAbort TxAbort_clone(const struct LDKTxAbort *NONNULL_PTR orig);

/**
 * Checks if two TxAborts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxAbort_eq(const struct LDKTxAbort *NONNULL_PTR a, const struct LDKTxAbort *NONNULL_PTR b);

/**
 * Frees any resources used by the Shutdown, if is_owned is set and inner is non-NULL.
 */
void Shutdown_free(struct LDKShutdown this_obj);

/**
 * The channel ID
 */
const uint8_t (*Shutdown_get_channel_id(const struct LDKShutdown *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void Shutdown_set_channel_id(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The destination of this peer's funds on closing.
 *
 * Must be in one of these forms: P2PKH, P2SH, P2WPKH, P2WSH, P2TR.
 */
struct LDKu8slice Shutdown_get_scriptpubkey(const struct LDKShutdown *NONNULL_PTR this_ptr);

/**
 * The destination of this peer's funds on closing.
 *
 * Must be in one of these forms: P2PKH, P2SH, P2WPKH, P2WSH, P2TR.
 */
void Shutdown_set_scriptpubkey(struct LDKShutdown *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new Shutdown given each field
 */
MUST_USE_RES struct LDKShutdown Shutdown_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKCVec_u8Z scriptpubkey_arg);

/**
 * Creates a copy of the Shutdown
 */
struct LDKShutdown Shutdown_clone(const struct LDKShutdown *NONNULL_PTR orig);

/**
 * Checks if two Shutdowns contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Shutdown_eq(const struct LDKShutdown *NONNULL_PTR a, const struct LDKShutdown *NONNULL_PTR b);

/**
 * Frees any resources used by the ClosingSignedFeeRange, if is_owned is set and inner is non-NULL.
 */
void ClosingSignedFeeRange_free(struct LDKClosingSignedFeeRange this_obj);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_min_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The minimum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_min_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
uint64_t ClosingSignedFeeRange_get_max_fee_satoshis(const struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr);

/**
 * The maximum absolute fee, in satoshis, which the sender is willing to place on the closing
 * transaction.
 */
void ClosingSignedFeeRange_set_max_fee_satoshis(struct LDKClosingSignedFeeRange *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ClosingSignedFeeRange given each field
 */
MUST_USE_RES struct LDKClosingSignedFeeRange ClosingSignedFeeRange_new(uint64_t min_fee_satoshis_arg, uint64_t max_fee_satoshis_arg);

/**
 * Creates a copy of the ClosingSignedFeeRange
 */
struct LDKClosingSignedFeeRange ClosingSignedFeeRange_clone(const struct LDKClosingSignedFeeRange *NONNULL_PTR orig);

/**
 * Checks if two ClosingSignedFeeRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingSignedFeeRange_eq(const struct LDKClosingSignedFeeRange *NONNULL_PTR a, const struct LDKClosingSignedFeeRange *NONNULL_PTR b);

/**
 * Frees any resources used by the ClosingSigned, if is_owned is set and inner is non-NULL.
 */
void ClosingSigned_free(struct LDKClosingSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*ClosingSigned_get_channel_id(const struct LDKClosingSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ClosingSigned_set_channel_id(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The proposed total fee for the closing transaction
 */
uint64_t ClosingSigned_get_fee_satoshis(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The proposed total fee for the closing transaction
 */
void ClosingSigned_set_fee_satoshis(struct LDKClosingSigned *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature on the closing transaction
 */
struct LDKECDSASignature ClosingSigned_get_signature(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the closing transaction
 */
void ClosingSigned_set_signature(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKClosingSignedFeeRange ClosingSigned_get_fee_range(const struct LDKClosingSigned *NONNULL_PTR this_ptr);

/**
 * The minimum and maximum fees which the sender is willing to accept, provided only by new
 * nodes.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ClosingSigned_set_fee_range(struct LDKClosingSigned *NONNULL_PTR this_ptr, struct LDKClosingSignedFeeRange val);

/**
 * Constructs a new ClosingSigned given each field
 *
 * Note that fee_range_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKClosingSigned ClosingSigned_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t fee_satoshis_arg, struct LDKECDSASignature signature_arg, struct LDKClosingSignedFeeRange fee_range_arg);

/**
 * Creates a copy of the ClosingSigned
 */
struct LDKClosingSigned ClosingSigned_clone(const struct LDKClosingSigned *NONNULL_PTR orig);

/**
 * Checks if two ClosingSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingSigned_eq(const struct LDKClosingSigned *NONNULL_PTR a, const struct LDKClosingSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateAddHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateAddHTLC_free(struct LDKUpdateAddHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateAddHTLC_get_channel_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateAddHTLC_set_channel_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateAddHTLC_get_htlc_id(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateAddHTLC_set_htlc_id(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The HTLC value in milli-satoshi
 */
uint64_t UpdateAddHTLC_get_amount_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC value in milli-satoshi
 */
void UpdateAddHTLC_set_amount_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
const uint8_t (*UpdateAddHTLC_get_payment_hash(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The payment hash, the pre-image of which controls HTLC redemption
 */
void UpdateAddHTLC_set_payment_hash(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The expiry height of the HTLC
 */
uint32_t UpdateAddHTLC_get_cltv_expiry(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The expiry height of the HTLC
 */
void UpdateAddHTLC_set_cltv_expiry(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The extra fee skimmed by the sender of this message. See
 * [`ChannelConfig::accept_underpaying_htlcs`].
 *
 * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
 */
struct LDKCOption_u64Z UpdateAddHTLC_get_skimmed_fee_msat(const struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr);

/**
 * The extra fee skimmed by the sender of this message. See
 * [`ChannelConfig::accept_underpaying_htlcs`].
 *
 * [`ChannelConfig::accept_underpaying_htlcs`]: crate::util::config::ChannelConfig::accept_underpaying_htlcs
 */
void UpdateAddHTLC_set_skimmed_fee_msat(struct LDKUpdateAddHTLC *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Creates a copy of the UpdateAddHTLC
 */
struct LDKUpdateAddHTLC UpdateAddHTLC_clone(const struct LDKUpdateAddHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateAddHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateAddHTLC_eq(const struct LDKUpdateAddHTLC *NONNULL_PTR a, const struct LDKUpdateAddHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the OnionMessage, if is_owned is set and inner is non-NULL.
 */
void OnionMessage_free(struct LDKOnionMessage this_obj);

/**
 * Used in decrypting the onion packet's payload.
 */
struct LDKPublicKey OnionMessage_get_blinding_point(const struct LDKOnionMessage *NONNULL_PTR this_ptr);

/**
 * Used in decrypting the onion packet's payload.
 */
void OnionMessage_set_blinding_point(struct LDKOnionMessage *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The full onion packet including hop data, pubkey, and hmac
 */
struct LDKPacket OnionMessage_get_onion_routing_packet(const struct LDKOnionMessage *NONNULL_PTR this_ptr);

/**
 * The full onion packet including hop data, pubkey, and hmac
 */
void OnionMessage_set_onion_routing_packet(struct LDKOnionMessage *NONNULL_PTR this_ptr, struct LDKPacket val);

/**
 * Constructs a new OnionMessage given each field
 */
MUST_USE_RES struct LDKOnionMessage OnionMessage_new(struct LDKPublicKey blinding_point_arg, struct LDKPacket onion_routing_packet_arg);

/**
 * Creates a copy of the OnionMessage
 */
struct LDKOnionMessage OnionMessage_clone(const struct LDKOnionMessage *NONNULL_PTR orig);

/**
 * Checks if two OnionMessages contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OnionMessage_eq(const struct LDKOnionMessage *NONNULL_PTR a, const struct LDKOnionMessage *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFulfillHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFulfillHTLC_free(struct LDKUpdateFulfillHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFulfillHTLC_get_channel_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFulfillHTLC_set_channel_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFulfillHTLC_get_htlc_id(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFulfillHTLC_set_htlc_id(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
const uint8_t (*UpdateFulfillHTLC_get_payment_preimage(const struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The pre-image of the payment hash, allowing HTLC redemption
 */
void UpdateFulfillHTLC_set_payment_preimage(struct LDKUpdateFulfillHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new UpdateFulfillHTLC given each field
 */
MUST_USE_RES struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t htlc_id_arg, struct LDKThirtyTwoBytes payment_preimage_arg);

/**
 * Creates a copy of the UpdateFulfillHTLC
 */
struct LDKUpdateFulfillHTLC UpdateFulfillHTLC_clone(const struct LDKUpdateFulfillHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFulfillHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFulfillHTLC_eq(const struct LDKUpdateFulfillHTLC *NONNULL_PTR a, const struct LDKUpdateFulfillHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFailHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailHTLC_free(struct LDKUpdateFailHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailHTLC_get_channel_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailHTLC_set_channel_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailHTLC_get_htlc_id(const struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailHTLC_set_htlc_id(struct LDKUpdateFailHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Creates a copy of the UpdateFailHTLC
 */
struct LDKUpdateFailHTLC UpdateFailHTLC_clone(const struct LDKUpdateFailHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFailHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFailHTLC_eq(const struct LDKUpdateFailHTLC *NONNULL_PTR a, const struct LDKUpdateFailHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFailMalformedHTLC, if is_owned is set and inner is non-NULL.
 */
void UpdateFailMalformedHTLC_free(struct LDKUpdateFailMalformedHTLC this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFailMalformedHTLC_get_channel_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFailMalformedHTLC_set_channel_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The HTLC ID
 */
uint64_t UpdateFailMalformedHTLC_get_htlc_id(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The HTLC ID
 */
void UpdateFailMalformedHTLC_set_htlc_id(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The failure code
 */
uint16_t UpdateFailMalformedHTLC_get_failure_code(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr);

/**
 * The failure code
 */
void UpdateFailMalformedHTLC_set_failure_code(struct LDKUpdateFailMalformedHTLC *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Creates a copy of the UpdateFailMalformedHTLC
 */
struct LDKUpdateFailMalformedHTLC UpdateFailMalformedHTLC_clone(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR orig);

/**
 * Checks if two UpdateFailMalformedHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFailMalformedHTLC_eq(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR a, const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR b);

/**
 * Frees any resources used by the CommitmentSigned, if is_owned is set and inner is non-NULL.
 */
void CommitmentSigned_free(struct LDKCommitmentSigned this_obj);

/**
 * The channel ID
 */
const uint8_t (*CommitmentSigned_get_channel_id(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void CommitmentSigned_set_channel_id(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * A signature on the commitment transaction
 */
struct LDKECDSASignature CommitmentSigned_get_signature(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * A signature on the commitment transaction
 */
void CommitmentSigned_set_signature(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Signatures on the HTLC transactions
 *
 * Returns a copy of the field.
 */
struct LDKCVec_ECDSASignatureZ CommitmentSigned_get_htlc_signatures(const struct LDKCommitmentSigned *NONNULL_PTR this_ptr);

/**
 * Signatures on the HTLC transactions
 */
void CommitmentSigned_set_htlc_signatures(struct LDKCommitmentSigned *NONNULL_PTR this_ptr, struct LDKCVec_ECDSASignatureZ val);

/**
 * Constructs a new CommitmentSigned given each field
 */
MUST_USE_RES struct LDKCommitmentSigned CommitmentSigned_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKECDSASignature signature_arg, struct LDKCVec_ECDSASignatureZ htlc_signatures_arg);

/**
 * Creates a copy of the CommitmentSigned
 */
struct LDKCommitmentSigned CommitmentSigned_clone(const struct LDKCommitmentSigned *NONNULL_PTR orig);

/**
 * Checks if two CommitmentSigneds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool CommitmentSigned_eq(const struct LDKCommitmentSigned *NONNULL_PTR a, const struct LDKCommitmentSigned *NONNULL_PTR b);

/**
 * Frees any resources used by the RevokeAndACK, if is_owned is set and inner is non-NULL.
 */
void RevokeAndACK_free(struct LDKRevokeAndACK this_obj);

/**
 * The channel ID
 */
const uint8_t (*RevokeAndACK_get_channel_id(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void RevokeAndACK_set_channel_id(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The secret corresponding to the per-commitment point
 */
const uint8_t (*RevokeAndACK_get_per_commitment_secret(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr))[32];

/**
 * The secret corresponding to the per-commitment point
 */
void RevokeAndACK_set_per_commitment_secret(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
struct LDKPublicKey RevokeAndACK_get_next_per_commitment_point(const struct LDKRevokeAndACK *NONNULL_PTR this_ptr);

/**
 * The next sender-broadcast commitment transaction's per-commitment point
 */
void RevokeAndACK_set_next_per_commitment_point(struct LDKRevokeAndACK *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new RevokeAndACK given each field
 */
MUST_USE_RES struct LDKRevokeAndACK RevokeAndACK_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKThirtyTwoBytes per_commitment_secret_arg, struct LDKPublicKey next_per_commitment_point_arg);

/**
 * Creates a copy of the RevokeAndACK
 */
struct LDKRevokeAndACK RevokeAndACK_clone(const struct LDKRevokeAndACK *NONNULL_PTR orig);

/**
 * Checks if two RevokeAndACKs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RevokeAndACK_eq(const struct LDKRevokeAndACK *NONNULL_PTR a, const struct LDKRevokeAndACK *NONNULL_PTR b);

/**
 * Frees any resources used by the UpdateFee, if is_owned is set and inner is non-NULL.
 */
void UpdateFee_free(struct LDKUpdateFee this_obj);

/**
 * The channel ID
 */
const uint8_t (*UpdateFee_get_channel_id(const struct LDKUpdateFee *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void UpdateFee_set_channel_id(struct LDKUpdateFee *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Fee rate per 1000-weight of the transaction
 */
uint32_t UpdateFee_get_feerate_per_kw(const struct LDKUpdateFee *NONNULL_PTR this_ptr);

/**
 * Fee rate per 1000-weight of the transaction
 */
void UpdateFee_set_feerate_per_kw(struct LDKUpdateFee *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new UpdateFee given each field
 */
MUST_USE_RES struct LDKUpdateFee UpdateFee_new(struct LDKThirtyTwoBytes channel_id_arg, uint32_t feerate_per_kw_arg);

/**
 * Creates a copy of the UpdateFee
 */
struct LDKUpdateFee UpdateFee_clone(const struct LDKUpdateFee *NONNULL_PTR orig);

/**
 * Checks if two UpdateFees contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UpdateFee_eq(const struct LDKUpdateFee *NONNULL_PTR a, const struct LDKUpdateFee *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelReestablish, if is_owned is set and inner is non-NULL.
 */
void ChannelReestablish_free(struct LDKChannelReestablish this_obj);

/**
 * The channel ID
 */
const uint8_t (*ChannelReestablish_get_channel_id(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void ChannelReestablish_set_channel_id(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The next commitment number for the sender
 */
uint64_t ChannelReestablish_get_next_local_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the sender
 */
void ChannelReestablish_set_next_local_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The next commitment number for the recipient
 */
uint64_t ChannelReestablish_get_next_remote_commitment_number(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next commitment number for the recipient
 */
void ChannelReestablish_set_next_remote_commitment_number(struct LDKChannelReestablish *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
const uint8_t (*ChannelReestablish_get_your_last_per_commitment_secret(const struct LDKChannelReestablish *NONNULL_PTR this_ptr))[32];

/**
 * Proof that the sender knows the per-commitment secret of a specific commitment transaction
 * belonging to the recipient
 */
void ChannelReestablish_set_your_last_per_commitment_secret(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
struct LDKPublicKey ChannelReestablish_get_my_current_per_commitment_point(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The sender's per-commitment point for their current commitment transaction
 */
void ChannelReestablish_set_my_current_per_commitment_point(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The next funding transaction ID
 */
struct LDKCOption_ThirtyTwoBytesZ ChannelReestablish_get_next_funding_txid(const struct LDKChannelReestablish *NONNULL_PTR this_ptr);

/**
 * The next funding transaction ID
 */
void ChannelReestablish_set_next_funding_txid(struct LDKChannelReestablish *NONNULL_PTR this_ptr, struct LDKCOption_ThirtyTwoBytesZ val);

/**
 * Constructs a new ChannelReestablish given each field
 */
MUST_USE_RES struct LDKChannelReestablish ChannelReestablish_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t next_local_commitment_number_arg, uint64_t next_remote_commitment_number_arg, struct LDKThirtyTwoBytes your_last_per_commitment_secret_arg, struct LDKPublicKey my_current_per_commitment_point_arg, struct LDKCOption_ThirtyTwoBytesZ next_funding_txid_arg);

/**
 * Creates a copy of the ChannelReestablish
 */
struct LDKChannelReestablish ChannelReestablish_clone(const struct LDKChannelReestablish *NONNULL_PTR orig);

/**
 * Checks if two ChannelReestablishs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelReestablish_eq(const struct LDKChannelReestablish *NONNULL_PTR a, const struct LDKChannelReestablish *NONNULL_PTR b);

/**
 * Frees any resources used by the AnnouncementSignatures, if is_owned is set and inner is non-NULL.
 */
void AnnouncementSignatures_free(struct LDKAnnouncementSignatures this_obj);

/**
 * The channel ID
 */
const uint8_t (*AnnouncementSignatures_get_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr))[32];

/**
 * The channel ID
 */
void AnnouncementSignatures_set_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t AnnouncementSignatures_get_short_channel_id(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void AnnouncementSignatures_set_short_channel_id(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A signature by the node key
 */
struct LDKECDSASignature AnnouncementSignatures_get_node_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the node key
 */
void AnnouncementSignatures_set_node_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * A signature by the funding key
 */
struct LDKECDSASignature AnnouncementSignatures_get_bitcoin_signature(const struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr);

/**
 * A signature by the funding key
 */
void AnnouncementSignatures_set_bitcoin_signature(struct LDKAnnouncementSignatures *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Constructs a new AnnouncementSignatures given each field
 */
MUST_USE_RES struct LDKAnnouncementSignatures AnnouncementSignatures_new(struct LDKThirtyTwoBytes channel_id_arg, uint64_t short_channel_id_arg, struct LDKECDSASignature node_signature_arg, struct LDKECDSASignature bitcoin_signature_arg);

/**
 * Creates a copy of the AnnouncementSignatures
 */
struct LDKAnnouncementSignatures AnnouncementSignatures_clone(const struct LDKAnnouncementSignatures *NONNULL_PTR orig);

/**
 * Checks if two AnnouncementSignaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AnnouncementSignatures_eq(const struct LDKAnnouncementSignatures *NONNULL_PTR a, const struct LDKAnnouncementSignatures *NONNULL_PTR b);

/**
 * Frees any resources used by the SocketAddress
 */
void SocketAddress_free(struct LDKSocketAddress this_ptr);

/**
 * Creates a copy of the SocketAddress
 */
struct LDKSocketAddress SocketAddress_clone(const struct LDKSocketAddress *NONNULL_PTR orig);

/**
 * Utility method to constructs a new TcpIpV4-variant SocketAddress
 */
struct LDKSocketAddress SocketAddress_tcp_ip_v4(struct LDKFourBytes addr, uint16_t port);

/**
 * Utility method to constructs a new TcpIpV6-variant SocketAddress
 */
struct LDKSocketAddress SocketAddress_tcp_ip_v6(struct LDKSixteenBytes addr, uint16_t port);

/**
 * Utility method to constructs a new OnionV2-variant SocketAddress
 */
struct LDKSocketAddress SocketAddress_onion_v2(struct LDKTwelveBytes a);

/**
 * Utility method to constructs a new OnionV3-variant SocketAddress
 */
struct LDKSocketAddress SocketAddress_onion_v3(struct LDKThirtyTwoBytes ed25519_pubkey, uint16_t checksum, uint8_t version, uint16_t port);

/**
 * Utility method to constructs a new Hostname-variant SocketAddress
 */
struct LDKSocketAddress SocketAddress_hostname(struct LDKHostname hostname, uint16_t port);

/**
 * Checks if two SocketAddresss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SocketAddress_eq(const struct LDKSocketAddress *NONNULL_PTR a, const struct LDKSocketAddress *NONNULL_PTR b);

/**
 * Serialize the SocketAddress object into a byte array which can be read by SocketAddress_read
 */
struct LDKCVec_u8Z SocketAddress_write(const struct LDKSocketAddress *NONNULL_PTR obj);

/**
 * Read a SocketAddress from a byte array, created by SocketAddress_write
 */
struct LDKCResult_SocketAddressDecodeErrorZ SocketAddress_read(struct LDKu8slice ser);

/**
 * Creates a copy of the SocketAddressParseError
 */
enum LDKSocketAddressParseError SocketAddressParseError_clone(const enum LDKSocketAddressParseError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SocketAddrParse-variant SocketAddressParseError
 */
enum LDKSocketAddressParseError SocketAddressParseError_socket_addr_parse(void);

/**
 * Utility method to constructs a new InvalidInput-variant SocketAddressParseError
 */
enum LDKSocketAddressParseError SocketAddressParseError_invalid_input(void);

/**
 * Utility method to constructs a new InvalidPort-variant SocketAddressParseError
 */
enum LDKSocketAddressParseError SocketAddressParseError_invalid_port(void);

/**
 * Utility method to constructs a new InvalidOnionV3-variant SocketAddressParseError
 */
enum LDKSocketAddressParseError SocketAddressParseError_invalid_onion_v3(void);

/**
 * Checks if two SocketAddressParseErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SocketAddressParseError_eq(const enum LDKSocketAddressParseError *NONNULL_PTR a, const enum LDKSocketAddressParseError *NONNULL_PTR b);

/**
 * Parses an OnionV3 host and port into a [`SocketAddress::OnionV3`].
 *
 * The host part must end with \".onion\".
 */
struct LDKCResult_SocketAddressSocketAddressParseErrorZ parse_onion_address(struct LDKStr host, uint16_t port);

/**
 * Read a SocketAddress object from a string
 */
struct LDKCResult_SocketAddressSocketAddressParseErrorZ SocketAddress_from_str(struct LDKStr s);

/**
 * Frees any resources used by the UnsignedGossipMessage
 */
void UnsignedGossipMessage_free(struct LDKUnsignedGossipMessage this_ptr);

/**
 * Creates a copy of the UnsignedGossipMessage
 */
struct LDKUnsignedGossipMessage UnsignedGossipMessage_clone(const struct LDKUnsignedGossipMessage *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ChannelAnnouncement-variant UnsignedGossipMessage
 */
struct LDKUnsignedGossipMessage UnsignedGossipMessage_channel_announcement(struct LDKUnsignedChannelAnnouncement a);

/**
 * Utility method to constructs a new ChannelUpdate-variant UnsignedGossipMessage
 */
struct LDKUnsignedGossipMessage UnsignedGossipMessage_channel_update(struct LDKUnsignedChannelUpdate a);

/**
 * Utility method to constructs a new NodeAnnouncement-variant UnsignedGossipMessage
 */
struct LDKUnsignedGossipMessage UnsignedGossipMessage_node_announcement(struct LDKUnsignedNodeAnnouncement a);

/**
 * Serialize the UnsignedGossipMessage object into a byte array which can be read by UnsignedGossipMessage_read
 */
struct LDKCVec_u8Z UnsignedGossipMessage_write(const struct LDKUnsignedGossipMessage *NONNULL_PTR obj);

/**
 * Frees any resources used by the UnsignedNodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedNodeAnnouncement_free(struct LDKUnsignedNodeAnnouncement this_obj);

/**
 * The advertised features
 */
struct LDKNodeFeatures UnsignedNodeAnnouncement_get_features(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised features
 */
void UnsignedNodeAnnouncement_set_features(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
uint32_t UnsignedNodeAnnouncement_get_timestamp(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed
 */
void UnsignedNodeAnnouncement_set_timestamp(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The `node_id` this announcement originated from (don't rebroadcast the `node_announcement` back
 * to this node).
 */
struct LDKNodeId UnsignedNodeAnnouncement_get_node_id(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The `node_id` this announcement originated from (don't rebroadcast the `node_announcement` back
 * to this node).
 */
void UnsignedNodeAnnouncement_set_node_id(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * An RGB color for UI purposes
 */
const uint8_t (*UnsignedNodeAnnouncement_get_rgb(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr))[3];

/**
 * An RGB color for UI purposes
 */
void UnsignedNodeAnnouncement_set_rgb(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * An alias, for UI purposes.
 *
 * This should be sanitized before use. There is no guarantee of uniqueness.
 */
struct LDKNodeAlias UnsignedNodeAnnouncement_get_alias(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * An alias, for UI purposes.
 *
 * This should be sanitized before use. There is no guarantee of uniqueness.
 */
void UnsignedNodeAnnouncement_set_alias(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeAlias val);

/**
 * List of addresses on which this node is reachable
 *
 * Returns a copy of the field.
 */
struct LDKCVec_SocketAddressZ UnsignedNodeAnnouncement_get_addresses(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * List of addresses on which this node is reachable
 */
void UnsignedNodeAnnouncement_set_addresses(struct LDKUnsignedNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_SocketAddressZ val);

/**
 * Creates a copy of the UnsignedNodeAnnouncement
 */
struct LDKUnsignedNodeAnnouncement UnsignedNodeAnnouncement_clone(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two UnsignedNodeAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedNodeAnnouncement_eq(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR a, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the NodeAnnouncement, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncement_free(struct LDKNodeAnnouncement this_obj);

/**
 * The signature by the node key
 */
struct LDKECDSASignature NodeAnnouncement_get_signature(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The signature by the node key
 */
void NodeAnnouncement_set_signature(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * The actual content of the announcement
 */
struct LDKUnsignedNodeAnnouncement NodeAnnouncement_get_contents(const struct LDKNodeAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual content of the announcement
 */
void NodeAnnouncement_set_contents(struct LDKNodeAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncement given each field
 */
MUST_USE_RES struct LDKNodeAnnouncement NodeAnnouncement_new(struct LDKECDSASignature signature_arg, struct LDKUnsignedNodeAnnouncement contents_arg);

/**
 * Creates a copy of the NodeAnnouncement
 */
struct LDKNodeAnnouncement NodeAnnouncement_clone(const struct LDKNodeAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two NodeAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAnnouncement_eq(const struct LDKNodeAnnouncement *NONNULL_PTR a, const struct LDKNodeAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the UnsignedChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelAnnouncement_free(struct LDKUnsignedChannelAnnouncement this_obj);

/**
 * The advertised channel features
 */
struct LDKChannelFeatures UnsignedChannelAnnouncement_get_features(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The advertised channel features
 */
void UnsignedChannelAnnouncement_set_features(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelAnnouncement_get_chain_hash(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelAnnouncement_set_chain_hash(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelAnnouncement_get_short_channel_id(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelAnnouncement_set_short_channel_id(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, uint64_t val);

/**
 * One of the two `node_id`s which are endpoints of this channel
 */
struct LDKNodeId UnsignedChannelAnnouncement_get_node_id_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * One of the two `node_id`s which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * The other of the two `node_id`s which are endpoints of this channel
 */
struct LDKNodeId UnsignedChannelAnnouncement_get_node_id_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The other of the two `node_id`s which are endpoints of this channel
 */
void UnsignedChannelAnnouncement_set_node_id_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * The funding key for the first node
 */
struct LDKNodeId UnsignedChannelAnnouncement_get_bitcoin_key_1(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the first node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_1(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * The funding key for the second node
 */
struct LDKNodeId UnsignedChannelAnnouncement_get_bitcoin_key_2(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The funding key for the second node
 */
void UnsignedChannelAnnouncement_set_bitcoin_key_2(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode.
 *
 * This is stored to ensure forward-compatibility as new fields are added to the lightning gossip protocol.
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_get_excess_data(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode.
 *
 * This is stored to ensure forward-compatibility as new fields are added to the lightning gossip protocol.
 */
void UnsignedChannelAnnouncement_set_excess_data(struct LDKUnsignedChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new UnsignedChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_new(struct LDKChannelFeatures features_arg, struct LDKThirtyTwoBytes chain_hash_arg, uint64_t short_channel_id_arg, struct LDKNodeId node_id_1_arg, struct LDKNodeId node_id_2_arg, struct LDKNodeId bitcoin_key_1_arg, struct LDKNodeId bitcoin_key_2_arg, struct LDKCVec_u8Z excess_data_arg);

/**
 * Creates a copy of the UnsignedChannelAnnouncement
 */
struct LDKUnsignedChannelAnnouncement UnsignedChannelAnnouncement_clone(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two UnsignedChannelAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedChannelAnnouncement_eq(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR a, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelAnnouncement, if is_owned is set and inner is non-NULL.
 */
void ChannelAnnouncement_free(struct LDKChannelAnnouncement this_obj);

/**
 * Authentication of the announcement by the first public node
 */
struct LDKECDSASignature ChannelAnnouncement_get_node_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the first public node
 */
void ChannelAnnouncement_set_node_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Authentication of the announcement by the second public node
 */
struct LDKECDSASignature ChannelAnnouncement_get_node_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Authentication of the announcement by the second public node
 */
void ChannelAnnouncement_set_node_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Proof of funding UTXO ownership by the first public node
 */
struct LDKECDSASignature ChannelAnnouncement_get_bitcoin_signature_1(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the first public node
 */
void ChannelAnnouncement_set_bitcoin_signature_1(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Proof of funding UTXO ownership by the second public node
 */
struct LDKECDSASignature ChannelAnnouncement_get_bitcoin_signature_2(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * Proof of funding UTXO ownership by the second public node
 */
void ChannelAnnouncement_set_bitcoin_signature_2(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * The actual announcement
 */
struct LDKUnsignedChannelAnnouncement ChannelAnnouncement_get_contents(const struct LDKChannelAnnouncement *NONNULL_PTR this_ptr);

/**
 * The actual announcement
 */
void ChannelAnnouncement_set_contents(struct LDKChannelAnnouncement *NONNULL_PTR this_ptr, struct LDKUnsignedChannelAnnouncement val);

/**
 * Constructs a new ChannelAnnouncement given each field
 */
MUST_USE_RES struct LDKChannelAnnouncement ChannelAnnouncement_new(struct LDKECDSASignature node_signature_1_arg, struct LDKECDSASignature node_signature_2_arg, struct LDKECDSASignature bitcoin_signature_1_arg, struct LDKECDSASignature bitcoin_signature_2_arg, struct LDKUnsignedChannelAnnouncement contents_arg);

/**
 * Creates a copy of the ChannelAnnouncement
 */
struct LDKChannelAnnouncement ChannelAnnouncement_clone(const struct LDKChannelAnnouncement *NONNULL_PTR orig);

/**
 * Checks if two ChannelAnnouncements contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelAnnouncement_eq(const struct LDKChannelAnnouncement *NONNULL_PTR a, const struct LDKChannelAnnouncement *NONNULL_PTR b);

/**
 * Frees any resources used by the UnsignedChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void UnsignedChannelUpdate_free(struct LDKUnsignedChannelUpdate this_obj);

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
const uint8_t (*UnsignedChannelUpdate_get_chain_hash(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain where the channel is to be opened
 */
void UnsignedChannelUpdate_set_chain_hash(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short channel ID
 */
uint64_t UnsignedChannelUpdate_get_short_channel_id(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The short channel ID
 */
void UnsignedChannelUpdate_set_short_channel_id(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
uint32_t UnsignedChannelUpdate_get_timestamp(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A strictly monotonic announcement counter, with gaps allowed, specific to this channel
 */
void UnsignedChannelUpdate_set_timestamp(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Channel flags
 */
uint8_t UnsignedChannelUpdate_get_flags(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Channel flags
 */
void UnsignedChannelUpdate_set_flags(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint8_t val);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, `cltv_expiry_delta` determines
 * the outgoing HTLC's minimum `cltv_expiry` value -- so, if an incoming HTLC comes in with a
 * `cltv_expiry` of 100000, and the node we're forwarding to has a `cltv_expiry_delta` value of 10,
 * then we'll check that the outgoing HTLC's `cltv_expiry` value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
uint16_t UnsignedChannelUpdate_get_cltv_expiry_delta(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The number of blocks such that if:
 * `incoming_htlc.cltv_expiry < outgoing_htlc.cltv_expiry + cltv_expiry_delta`
 * then we need to fail the HTLC backwards. When forwarding an HTLC, `cltv_expiry_delta` determines
 * the outgoing HTLC's minimum `cltv_expiry` value -- so, if an incoming HTLC comes in with a
 * `cltv_expiry` of 100000, and the node we're forwarding to has a `cltv_expiry_delta` value of 10,
 * then we'll check that the outgoing HTLC's `cltv_expiry` value is at least 100010 before
 * forwarding. Note that the HTLC sender is the one who originally sets this value when
 * constructing the route.
 */
void UnsignedChannelUpdate_set_cltv_expiry_delta(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
uint64_t UnsignedChannelUpdate_get_htlc_minimum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC size incoming to sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_htlc_minimum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum HTLC value incoming to sender, in milli-satoshi.
 *
 * This used to be optional.
 */
uint64_t UnsignedChannelUpdate_get_htlc_maximum_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The maximum HTLC value incoming to sender, in milli-satoshi.
 *
 * This used to be optional.
 */
void UnsignedChannelUpdate_set_htlc_maximum_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_base_msat(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The base HTLC fee charged by sender, in milli-satoshi
 */
void UnsignedChannelUpdate_set_fee_base_msat(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
uint32_t UnsignedChannelUpdate_get_fee_proportional_millionths(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The amount to fee multiplier, in micro-satoshi
 */
void UnsignedChannelUpdate_set_fee_proportional_millionths(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode.
 *
 * This is stored to ensure forward-compatibility as new fields are added to the lightning gossip protocol.
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_get_excess_data(const struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr);

/**
 * Excess data which was signed as a part of the message which we do not (yet) understand how
 * to decode.
 *
 * This is stored to ensure forward-compatibility as new fields are added to the lightning gossip protocol.
 */
void UnsignedChannelUpdate_set_excess_data(struct LDKUnsignedChannelUpdate *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new UnsignedChannelUpdate given each field
 */
MUST_USE_RES struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_new(struct LDKThirtyTwoBytes chain_hash_arg, uint64_t short_channel_id_arg, uint32_t timestamp_arg, uint8_t flags_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, struct LDKCVec_u8Z excess_data_arg);

/**
 * Creates a copy of the UnsignedChannelUpdate
 */
struct LDKUnsignedChannelUpdate UnsignedChannelUpdate_clone(const struct LDKUnsignedChannelUpdate *NONNULL_PTR orig);

/**
 * Checks if two UnsignedChannelUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool UnsignedChannelUpdate_eq(const struct LDKUnsignedChannelUpdate *NONNULL_PTR a, const struct LDKUnsignedChannelUpdate *NONNULL_PTR b);

/**
 * Frees any resources used by the ChannelUpdate, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdate_free(struct LDKChannelUpdate this_obj);

/**
 * A signature of the channel update
 */
struct LDKECDSASignature ChannelUpdate_get_signature(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * A signature of the channel update
 */
void ChannelUpdate_set_signature(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * The actual channel update
 */
struct LDKUnsignedChannelUpdate ChannelUpdate_get_contents(const struct LDKChannelUpdate *NONNULL_PTR this_ptr);

/**
 * The actual channel update
 */
void ChannelUpdate_set_contents(struct LDKChannelUpdate *NONNULL_PTR this_ptr, struct LDKUnsignedChannelUpdate val);

/**
 * Constructs a new ChannelUpdate given each field
 */
MUST_USE_RES struct LDKChannelUpdate ChannelUpdate_new(struct LDKECDSASignature signature_arg, struct LDKUnsignedChannelUpdate contents_arg);

/**
 * Creates a copy of the ChannelUpdate
 */
struct LDKChannelUpdate ChannelUpdate_clone(const struct LDKChannelUpdate *NONNULL_PTR orig);

/**
 * Checks if two ChannelUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelUpdate_eq(const struct LDKChannelUpdate *NONNULL_PTR a, const struct LDKChannelUpdate *NONNULL_PTR b);

/**
 * Frees any resources used by the QueryChannelRange, if is_owned is set and inner is non-NULL.
 */
void QueryChannelRange_free(struct LDKQueryChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryChannelRange_get_chain_hash(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryChannelRange_set_chain_hash(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block for the channel UTXOs being queried
 */
uint32_t QueryChannelRange_get_first_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block for the channel UTXOs being queried
 */
void QueryChannelRange_set_first_blocknum(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks to include in the query results
 */
uint32_t QueryChannelRange_get_number_of_blocks(const struct LDKQueryChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks to include in the query results
 */
void QueryChannelRange_set_number_of_blocks(struct LDKQueryChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new QueryChannelRange given each field
 */
MUST_USE_RES struct LDKQueryChannelRange QueryChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg);

/**
 * Creates a copy of the QueryChannelRange
 */
struct LDKQueryChannelRange QueryChannelRange_clone(const struct LDKQueryChannelRange *NONNULL_PTR orig);

/**
 * Checks if two QueryChannelRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool QueryChannelRange_eq(const struct LDKQueryChannelRange *NONNULL_PTR a, const struct LDKQueryChannelRange *NONNULL_PTR b);

/**
 * Frees any resources used by the ReplyChannelRange, if is_owned is set and inner is non-NULL.
 */
void ReplyChannelRange_free(struct LDKReplyChannelRange this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*ReplyChannelRange_get_chain_hash(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void ReplyChannelRange_set_chain_hash(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The height of the first block in the range of the reply
 */
uint32_t ReplyChannelRange_get_first_blocknum(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The height of the first block in the range of the reply
 */
void ReplyChannelRange_set_first_blocknum(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The number of blocks included in the range of the reply
 */
uint32_t ReplyChannelRange_get_number_of_blocks(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The number of blocks included in the range of the reply
 */
void ReplyChannelRange_set_number_of_blocks(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, uint32_t val);

/**
 * True when this is the final reply for a query
 */
bool ReplyChannelRange_get_sync_complete(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * True when this is the final reply for a query
 */
void ReplyChannelRange_set_sync_complete(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, bool val);

/**
 * The `short_channel_id`s in the channel range
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z ReplyChannelRange_get_short_channel_ids(const struct LDKReplyChannelRange *NONNULL_PTR this_ptr);

/**
 * The `short_channel_id`s in the channel range
 */
void ReplyChannelRange_set_short_channel_ids(struct LDKReplyChannelRange *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new ReplyChannelRange given each field
 */
MUST_USE_RES struct LDKReplyChannelRange ReplyChannelRange_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_blocknum_arg, uint32_t number_of_blocks_arg, bool sync_complete_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the ReplyChannelRange
 */
struct LDKReplyChannelRange ReplyChannelRange_clone(const struct LDKReplyChannelRange *NONNULL_PTR orig);

/**
 * Checks if two ReplyChannelRanges contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ReplyChannelRange_eq(const struct LDKReplyChannelRange *NONNULL_PTR a, const struct LDKReplyChannelRange *NONNULL_PTR b);

/**
 * Frees any resources used by the QueryShortChannelIds, if is_owned is set and inner is non-NULL.
 */
void QueryShortChannelIds_free(struct LDKQueryShortChannelIds this_obj);

/**
 * The genesis hash of the blockchain being queried
 */
const uint8_t (*QueryShortChannelIds_get_chain_hash(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain being queried
 */
void QueryShortChannelIds_set_chain_hash(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The short_channel_ids that are being queried
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z QueryShortChannelIds_get_short_channel_ids(const struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr);

/**
 * The short_channel_ids that are being queried
 */
void QueryShortChannelIds_set_short_channel_ids(struct LDKQueryShortChannelIds *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new QueryShortChannelIds given each field
 */
MUST_USE_RES struct LDKQueryShortChannelIds QueryShortChannelIds_new(struct LDKThirtyTwoBytes chain_hash_arg, struct LDKCVec_u64Z short_channel_ids_arg);

/**
 * Creates a copy of the QueryShortChannelIds
 */
struct LDKQueryShortChannelIds QueryShortChannelIds_clone(const struct LDKQueryShortChannelIds *NONNULL_PTR orig);

/**
 * Checks if two QueryShortChannelIdss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool QueryShortChannelIds_eq(const struct LDKQueryShortChannelIds *NONNULL_PTR a, const struct LDKQueryShortChannelIds *NONNULL_PTR b);

/**
 * Frees any resources used by the ReplyShortChannelIdsEnd, if is_owned is set and inner is non-NULL.
 */
void ReplyShortChannelIdsEnd_free(struct LDKReplyShortChannelIdsEnd this_obj);

/**
 * The genesis hash of the blockchain that was queried
 */
const uint8_t (*ReplyShortChannelIdsEnd_get_chain_hash(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain that was queried
 */
void ReplyShortChannelIdsEnd_set_chain_hash(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the `chain_hash`
 */
bool ReplyShortChannelIdsEnd_get_full_information(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr);

/**
 * Indicates if the query recipient maintains up-to-date channel
 * information for the `chain_hash`
 */
void ReplyShortChannelIdsEnd_set_full_information(struct LDKReplyShortChannelIdsEnd *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new ReplyShortChannelIdsEnd given each field
 */
MUST_USE_RES struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_new(struct LDKThirtyTwoBytes chain_hash_arg, bool full_information_arg);

/**
 * Creates a copy of the ReplyShortChannelIdsEnd
 */
struct LDKReplyShortChannelIdsEnd ReplyShortChannelIdsEnd_clone(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR orig);

/**
 * Checks if two ReplyShortChannelIdsEnds contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ReplyShortChannelIdsEnd_eq(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR a, const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR b);

/**
 * Frees any resources used by the GossipTimestampFilter, if is_owned is set and inner is non-NULL.
 */
void GossipTimestampFilter_free(struct LDKGossipTimestampFilter this_obj);

/**
 * The genesis hash of the blockchain for channel and node information
 */
const uint8_t (*GossipTimestampFilter_get_chain_hash(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr))[32];

/**
 * The genesis hash of the blockchain for channel and node information
 */
void GossipTimestampFilter_set_chain_hash(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The starting unix timestamp
 */
uint32_t GossipTimestampFilter_get_first_timestamp(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The starting unix timestamp
 */
void GossipTimestampFilter_set_first_timestamp(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The range of information in seconds
 */
uint32_t GossipTimestampFilter_get_timestamp_range(const struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr);

/**
 * The range of information in seconds
 */
void GossipTimestampFilter_set_timestamp_range(struct LDKGossipTimestampFilter *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new GossipTimestampFilter given each field
 */
MUST_USE_RES struct LDKGossipTimestampFilter GossipTimestampFilter_new(struct LDKThirtyTwoBytes chain_hash_arg, uint32_t first_timestamp_arg, uint32_t timestamp_range_arg);

/**
 * Creates a copy of the GossipTimestampFilter
 */
struct LDKGossipTimestampFilter GossipTimestampFilter_clone(const struct LDKGossipTimestampFilter *NONNULL_PTR orig);

/**
 * Checks if two GossipTimestampFilters contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool GossipTimestampFilter_eq(const struct LDKGossipTimestampFilter *NONNULL_PTR a, const struct LDKGossipTimestampFilter *NONNULL_PTR b);

/**
 * Frees any resources used by the ErrorAction
 */
void ErrorAction_free(struct LDKErrorAction this_ptr);

/**
 * Creates a copy of the ErrorAction
 */
struct LDKErrorAction ErrorAction_clone(const struct LDKErrorAction *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DisconnectPeer-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_disconnect_peer(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new DisconnectPeerWithWarning-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_disconnect_peer_with_warning(struct LDKWarningMessage msg);

/**
 * Utility method to constructs a new IgnoreError-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_error(void);

/**
 * Utility method to constructs a new IgnoreAndLog-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_and_log(enum LDKLevel a);

/**
 * Utility method to constructs a new IgnoreDuplicateGossip-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_ignore_duplicate_gossip(void);

/**
 * Utility method to constructs a new SendErrorMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_error_message(struct LDKErrorMessage msg);

/**
 * Utility method to constructs a new SendWarningMessage-variant ErrorAction
 */
struct LDKErrorAction ErrorAction_send_warning_message(struct LDKWarningMessage msg, enum LDKLevel log_level);

/**
 * Frees any resources used by the LightningError, if is_owned is set and inner is non-NULL.
 */
void LightningError_free(struct LDKLightningError this_obj);

/**
 * A human-readable message describing the error
 */
struct LDKStr LightningError_get_err(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * A human-readable message describing the error
 */
void LightningError_set_err(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKStr val);

/**
 * The action which should be taken against the offending peer.
 */
struct LDKErrorAction LightningError_get_action(const struct LDKLightningError *NONNULL_PTR this_ptr);

/**
 * The action which should be taken against the offending peer.
 */
void LightningError_set_action(struct LDKLightningError *NONNULL_PTR this_ptr, struct LDKErrorAction val);

/**
 * Constructs a new LightningError given each field
 */
MUST_USE_RES struct LDKLightningError LightningError_new(struct LDKStr err_arg, struct LDKErrorAction action_arg);

/**
 * Creates a copy of the LightningError
 */
struct LDKLightningError LightningError_clone(const struct LDKLightningError *NONNULL_PTR orig);

/**
 * Frees any resources used by the CommitmentUpdate, if is_owned is set and inner is non-NULL.
 */
void CommitmentUpdate_free(struct LDKCommitmentUpdate this_obj);

/**
 * `update_add_htlc` messages which should be sent
 */
struct LDKCVec_UpdateAddHTLCZ CommitmentUpdate_get_update_add_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * `update_add_htlc` messages which should be sent
 */
void CommitmentUpdate_set_update_add_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateAddHTLCZ val);

/**
 * `update_fulfill_htlc` messages which should be sent
 */
struct LDKCVec_UpdateFulfillHTLCZ CommitmentUpdate_get_update_fulfill_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * `update_fulfill_htlc` messages which should be sent
 */
void CommitmentUpdate_set_update_fulfill_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFulfillHTLCZ val);

/**
 * `update_fail_htlc` messages which should be sent
 */
struct LDKCVec_UpdateFailHTLCZ CommitmentUpdate_get_update_fail_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * `update_fail_htlc` messages which should be sent
 */
void CommitmentUpdate_set_update_fail_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailHTLCZ val);

/**
 * `update_fail_malformed_htlc` messages which should be sent
 */
struct LDKCVec_UpdateFailMalformedHTLCZ CommitmentUpdate_get_update_fail_malformed_htlcs(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * `update_fail_malformed_htlc` messages which should be sent
 */
void CommitmentUpdate_set_update_fail_malformed_htlcs(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCVec_UpdateFailMalformedHTLCZ val);

/**
 * An `update_fee` message which should be sent
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKUpdateFee CommitmentUpdate_get_update_fee(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * An `update_fee` message which should be sent
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void CommitmentUpdate_set_update_fee(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKUpdateFee val);

/**
 * A `commitment_signed` message which should be sent
 */
struct LDKCommitmentSigned CommitmentUpdate_get_commitment_signed(const struct LDKCommitmentUpdate *NONNULL_PTR this_ptr);

/**
 * A `commitment_signed` message which should be sent
 */
void CommitmentUpdate_set_commitment_signed(struct LDKCommitmentUpdate *NONNULL_PTR this_ptr, struct LDKCommitmentSigned val);

/**
 * Constructs a new CommitmentUpdate given each field
 *
 * Note that update_fee_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCommitmentUpdate CommitmentUpdate_new(struct LDKCVec_UpdateAddHTLCZ update_add_htlcs_arg, struct LDKCVec_UpdateFulfillHTLCZ update_fulfill_htlcs_arg, struct LDKCVec_UpdateFailHTLCZ update_fail_htlcs_arg, struct LDKCVec_UpdateFailMalformedHTLCZ update_fail_malformed_htlcs_arg, struct LDKUpdateFee update_fee_arg, struct LDKCommitmentSigned commitment_signed_arg);

/**
 * Creates a copy of the CommitmentUpdate
 */
struct LDKCommitmentUpdate CommitmentUpdate_clone(const struct LDKCommitmentUpdate *NONNULL_PTR orig);

/**
 * Checks if two CommitmentUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool CommitmentUpdate_eq(const struct LDKCommitmentUpdate *NONNULL_PTR a, const struct LDKCommitmentUpdate *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void ChannelMessageHandler_free(struct LDKChannelMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void RoutingMessageHandler_free(struct LDKRoutingMessageHandler this_ptr);

/**
 * Calls the free function if one is set
 */
void OnionMessageHandler_free(struct LDKOnionMessageHandler this_ptr);

/**
 * Serialize the AcceptChannel object into a byte array which can be read by AcceptChannel_read
 */
struct LDKCVec_u8Z AcceptChannel_write(const struct LDKAcceptChannel *NONNULL_PTR obj);

/**
 * Read a AcceptChannel from a byte array, created by AcceptChannel_write
 */
struct LDKCResult_AcceptChannelDecodeErrorZ AcceptChannel_read(struct LDKu8slice ser);

/**
 * Serialize the AcceptChannelV2 object into a byte array which can be read by AcceptChannelV2_read
 */
struct LDKCVec_u8Z AcceptChannelV2_write(const struct LDKAcceptChannelV2 *NONNULL_PTR obj);

/**
 * Read a AcceptChannelV2 from a byte array, created by AcceptChannelV2_write
 */
struct LDKCResult_AcceptChannelV2DecodeErrorZ AcceptChannelV2_read(struct LDKu8slice ser);

/**
 * Serialize the TxAddInput object into a byte array which can be read by TxAddInput_read
 */
struct LDKCVec_u8Z TxAddInput_write(const struct LDKTxAddInput *NONNULL_PTR obj);

/**
 * Read a TxAddInput from a byte array, created by TxAddInput_write
 */
struct LDKCResult_TxAddInputDecodeErrorZ TxAddInput_read(struct LDKu8slice ser);

/**
 * Serialize the TxAddOutput object into a byte array which can be read by TxAddOutput_read
 */
struct LDKCVec_u8Z TxAddOutput_write(const struct LDKTxAddOutput *NONNULL_PTR obj);

/**
 * Read a TxAddOutput from a byte array, created by TxAddOutput_write
 */
struct LDKCResult_TxAddOutputDecodeErrorZ TxAddOutput_read(struct LDKu8slice ser);

/**
 * Serialize the TxRemoveInput object into a byte array which can be read by TxRemoveInput_read
 */
struct LDKCVec_u8Z TxRemoveInput_write(const struct LDKTxRemoveInput *NONNULL_PTR obj);

/**
 * Read a TxRemoveInput from a byte array, created by TxRemoveInput_write
 */
struct LDKCResult_TxRemoveInputDecodeErrorZ TxRemoveInput_read(struct LDKu8slice ser);

/**
 * Serialize the TxRemoveOutput object into a byte array which can be read by TxRemoveOutput_read
 */
struct LDKCVec_u8Z TxRemoveOutput_write(const struct LDKTxRemoveOutput *NONNULL_PTR obj);

/**
 * Read a TxRemoveOutput from a byte array, created by TxRemoveOutput_write
 */
struct LDKCResult_TxRemoveOutputDecodeErrorZ TxRemoveOutput_read(struct LDKu8slice ser);

/**
 * Serialize the TxComplete object into a byte array which can be read by TxComplete_read
 */
struct LDKCVec_u8Z TxComplete_write(const struct LDKTxComplete *NONNULL_PTR obj);

/**
 * Read a TxComplete from a byte array, created by TxComplete_write
 */
struct LDKCResult_TxCompleteDecodeErrorZ TxComplete_read(struct LDKu8slice ser);

/**
 * Serialize the TxSignatures object into a byte array which can be read by TxSignatures_read
 */
struct LDKCVec_u8Z TxSignatures_write(const struct LDKTxSignatures *NONNULL_PTR obj);

/**
 * Read a TxSignatures from a byte array, created by TxSignatures_write
 */
struct LDKCResult_TxSignaturesDecodeErrorZ TxSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the TxInitRbf object into a byte array which can be read by TxInitRbf_read
 */
struct LDKCVec_u8Z TxInitRbf_write(const struct LDKTxInitRbf *NONNULL_PTR obj);

/**
 * Read a TxInitRbf from a byte array, created by TxInitRbf_write
 */
struct LDKCResult_TxInitRbfDecodeErrorZ TxInitRbf_read(struct LDKu8slice ser);

/**
 * Serialize the TxAckRbf object into a byte array which can be read by TxAckRbf_read
 */
struct LDKCVec_u8Z TxAckRbf_write(const struct LDKTxAckRbf *NONNULL_PTR obj);

/**
 * Read a TxAckRbf from a byte array, created by TxAckRbf_write
 */
struct LDKCResult_TxAckRbfDecodeErrorZ TxAckRbf_read(struct LDKu8slice ser);

/**
 * Serialize the TxAbort object into a byte array which can be read by TxAbort_read
 */
struct LDKCVec_u8Z TxAbort_write(const struct LDKTxAbort *NONNULL_PTR obj);

/**
 * Read a TxAbort from a byte array, created by TxAbort_write
 */
struct LDKCResult_TxAbortDecodeErrorZ TxAbort_read(struct LDKu8slice ser);

/**
 * Serialize the AnnouncementSignatures object into a byte array which can be read by AnnouncementSignatures_read
 */
struct LDKCVec_u8Z AnnouncementSignatures_write(const struct LDKAnnouncementSignatures *NONNULL_PTR obj);

/**
 * Read a AnnouncementSignatures from a byte array, created by AnnouncementSignatures_write
 */
struct LDKCResult_AnnouncementSignaturesDecodeErrorZ AnnouncementSignatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReestablish object into a byte array which can be read by ChannelReestablish_read
 */
struct LDKCVec_u8Z ChannelReestablish_write(const struct LDKChannelReestablish *NONNULL_PTR obj);

/**
 * Read a ChannelReestablish from a byte array, created by ChannelReestablish_write
 */
struct LDKCResult_ChannelReestablishDecodeErrorZ ChannelReestablish_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSigned object into a byte array which can be read by ClosingSigned_read
 */
struct LDKCVec_u8Z ClosingSigned_write(const struct LDKClosingSigned *NONNULL_PTR obj);

/**
 * Read a ClosingSigned from a byte array, created by ClosingSigned_write
 */
struct LDKCResult_ClosingSignedDecodeErrorZ ClosingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the ClosingSignedFeeRange object into a byte array which can be read by ClosingSignedFeeRange_read
 */
struct LDKCVec_u8Z ClosingSignedFeeRange_write(const struct LDKClosingSignedFeeRange *NONNULL_PTR obj);

/**
 * Read a ClosingSignedFeeRange from a byte array, created by ClosingSignedFeeRange_write
 */
struct LDKCResult_ClosingSignedFeeRangeDecodeErrorZ ClosingSignedFeeRange_read(struct LDKu8slice ser);

/**
 * Serialize the CommitmentSigned object into a byte array which can be read by CommitmentSigned_read
 */
struct LDKCVec_u8Z CommitmentSigned_write(const struct LDKCommitmentSigned *NONNULL_PTR obj);

/**
 * Read a CommitmentSigned from a byte array, created by CommitmentSigned_write
 */
struct LDKCResult_CommitmentSignedDecodeErrorZ CommitmentSigned_read(struct LDKu8slice ser);

/**
 * Serialize the FundingCreated object into a byte array which can be read by FundingCreated_read
 */
struct LDKCVec_u8Z FundingCreated_write(const struct LDKFundingCreated *NONNULL_PTR obj);

/**
 * Read a FundingCreated from a byte array, created by FundingCreated_write
 */
struct LDKCResult_FundingCreatedDecodeErrorZ FundingCreated_read(struct LDKu8slice ser);

/**
 * Serialize the FundingSigned object into a byte array which can be read by FundingSigned_read
 */
struct LDKCVec_u8Z FundingSigned_write(const struct LDKFundingSigned *NONNULL_PTR obj);

/**
 * Read a FundingSigned from a byte array, created by FundingSigned_write
 */
struct LDKCResult_FundingSignedDecodeErrorZ FundingSigned_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelReady object into a byte array which can be read by ChannelReady_read
 */
struct LDKCVec_u8Z ChannelReady_write(const struct LDKChannelReady *NONNULL_PTR obj);

/**
 * Read a ChannelReady from a byte array, created by ChannelReady_write
 */
struct LDKCResult_ChannelReadyDecodeErrorZ ChannelReady_read(struct LDKu8slice ser);

/**
 * Serialize the Init object into a byte array which can be read by Init_read
 */
struct LDKCVec_u8Z Init_write(const struct LDKInit *NONNULL_PTR obj);

/**
 * Read a Init from a byte array, created by Init_write
 */
struct LDKCResult_InitDecodeErrorZ Init_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannel object into a byte array which can be read by OpenChannel_read
 */
struct LDKCVec_u8Z OpenChannel_write(const struct LDKOpenChannel *NONNULL_PTR obj);

/**
 * Read a OpenChannel from a byte array, created by OpenChannel_write
 */
struct LDKCResult_OpenChannelDecodeErrorZ OpenChannel_read(struct LDKu8slice ser);

/**
 * Serialize the OpenChannelV2 object into a byte array which can be read by OpenChannelV2_read
 */
struct LDKCVec_u8Z OpenChannelV2_write(const struct LDKOpenChannelV2 *NONNULL_PTR obj);

/**
 * Read a OpenChannelV2 from a byte array, created by OpenChannelV2_write
 */
struct LDKCResult_OpenChannelV2DecodeErrorZ OpenChannelV2_read(struct LDKu8slice ser);

/**
 * Serialize the RevokeAndACK object into a byte array which can be read by RevokeAndACK_read
 */
struct LDKCVec_u8Z RevokeAndACK_write(const struct LDKRevokeAndACK *NONNULL_PTR obj);

/**
 * Read a RevokeAndACK from a byte array, created by RevokeAndACK_write
 */
struct LDKCResult_RevokeAndACKDecodeErrorZ RevokeAndACK_read(struct LDKu8slice ser);

/**
 * Serialize the Shutdown object into a byte array which can be read by Shutdown_read
 */
struct LDKCVec_u8Z Shutdown_write(const struct LDKShutdown *NONNULL_PTR obj);

/**
 * Read a Shutdown from a byte array, created by Shutdown_write
 */
struct LDKCResult_ShutdownDecodeErrorZ Shutdown_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailHTLC object into a byte array which can be read by UpdateFailHTLC_read
 */
struct LDKCVec_u8Z UpdateFailHTLC_write(const struct LDKUpdateFailHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailHTLC from a byte array, created by UpdateFailHTLC_write
 */
struct LDKCResult_UpdateFailHTLCDecodeErrorZ UpdateFailHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFailMalformedHTLC object into a byte array which can be read by UpdateFailMalformedHTLC_read
 */
struct LDKCVec_u8Z UpdateFailMalformedHTLC_write(const struct LDKUpdateFailMalformedHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFailMalformedHTLC from a byte array, created by UpdateFailMalformedHTLC_write
 */
struct LDKCResult_UpdateFailMalformedHTLCDecodeErrorZ UpdateFailMalformedHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFee object into a byte array which can be read by UpdateFee_read
 */
struct LDKCVec_u8Z UpdateFee_write(const struct LDKUpdateFee *NONNULL_PTR obj);

/**
 * Read a UpdateFee from a byte array, created by UpdateFee_write
 */
struct LDKCResult_UpdateFeeDecodeErrorZ UpdateFee_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateFulfillHTLC object into a byte array which can be read by UpdateFulfillHTLC_read
 */
struct LDKCVec_u8Z UpdateFulfillHTLC_write(const struct LDKUpdateFulfillHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateFulfillHTLC from a byte array, created by UpdateFulfillHTLC_write
 */
struct LDKCResult_UpdateFulfillHTLCDecodeErrorZ UpdateFulfillHTLC_read(struct LDKu8slice ser);

/**
 * Serialize the UpdateAddHTLC object into a byte array which can be read by UpdateAddHTLC_read
 */
struct LDKCVec_u8Z UpdateAddHTLC_write(const struct LDKUpdateAddHTLC *NONNULL_PTR obj);

/**
 * Read a UpdateAddHTLC from a byte array, created by UpdateAddHTLC_write
 */
struct LDKCResult_UpdateAddHTLCDecodeErrorZ UpdateAddHTLC_read(struct LDKu8slice ser);

/**
 * Read a OnionMessage from a byte array, created by OnionMessage_write
 */
struct LDKCResult_OnionMessageDecodeErrorZ OnionMessage_read(struct LDKu8slice ser);

/**
 * Serialize the OnionMessage object into a byte array which can be read by OnionMessage_read
 */
struct LDKCVec_u8Z OnionMessage_write(const struct LDKOnionMessage *NONNULL_PTR obj);

/**
 * Serialize the Ping object into a byte array which can be read by Ping_read
 */
struct LDKCVec_u8Z Ping_write(const struct LDKPing *NONNULL_PTR obj);

/**
 * Read a Ping from a byte array, created by Ping_write
 */
struct LDKCResult_PingDecodeErrorZ Ping_read(struct LDKu8slice ser);

/**
 * Serialize the Pong object into a byte array which can be read by Pong_read
 */
struct LDKCVec_u8Z Pong_write(const struct LDKPong *NONNULL_PTR obj);

/**
 * Read a Pong from a byte array, created by Pong_write
 */
struct LDKCResult_PongDecodeErrorZ Pong_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelAnnouncement object into a byte array which can be read by UnsignedChannelAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedChannelAnnouncement_write(const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelAnnouncement from a byte array, created by UnsignedChannelAnnouncement_write
 */
struct LDKCResult_UnsignedChannelAnnouncementDecodeErrorZ UnsignedChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelAnnouncement object into a byte array which can be read by ChannelAnnouncement_read
 */
struct LDKCVec_u8Z ChannelAnnouncement_write(const struct LDKChannelAnnouncement *NONNULL_PTR obj);

/**
 * Read a ChannelAnnouncement from a byte array, created by ChannelAnnouncement_write
 */
struct LDKCResult_ChannelAnnouncementDecodeErrorZ ChannelAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedChannelUpdate object into a byte array which can be read by UnsignedChannelUpdate_read
 */
struct LDKCVec_u8Z UnsignedChannelUpdate_write(const struct LDKUnsignedChannelUpdate *NONNULL_PTR obj);

/**
 * Read a UnsignedChannelUpdate from a byte array, created by UnsignedChannelUpdate_write
 */
struct LDKCResult_UnsignedChannelUpdateDecodeErrorZ UnsignedChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelUpdate object into a byte array which can be read by ChannelUpdate_read
 */
struct LDKCVec_u8Z ChannelUpdate_write(const struct LDKChannelUpdate *NONNULL_PTR obj);

/**
 * Read a ChannelUpdate from a byte array, created by ChannelUpdate_write
 */
struct LDKCResult_ChannelUpdateDecodeErrorZ ChannelUpdate_read(struct LDKu8slice ser);

/**
 * Serialize the ErrorMessage object into a byte array which can be read by ErrorMessage_read
 */
struct LDKCVec_u8Z ErrorMessage_write(const struct LDKErrorMessage *NONNULL_PTR obj);

/**
 * Read a ErrorMessage from a byte array, created by ErrorMessage_write
 */
struct LDKCResult_ErrorMessageDecodeErrorZ ErrorMessage_read(struct LDKu8slice ser);

/**
 * Serialize the WarningMessage object into a byte array which can be read by WarningMessage_read
 */
struct LDKCVec_u8Z WarningMessage_write(const struct LDKWarningMessage *NONNULL_PTR obj);

/**
 * Read a WarningMessage from a byte array, created by WarningMessage_write
 */
struct LDKCResult_WarningMessageDecodeErrorZ WarningMessage_read(struct LDKu8slice ser);

/**
 * Serialize the UnsignedNodeAnnouncement object into a byte array which can be read by UnsignedNodeAnnouncement_read
 */
struct LDKCVec_u8Z UnsignedNodeAnnouncement_write(const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a UnsignedNodeAnnouncement from a byte array, created by UnsignedNodeAnnouncement_write
 */
struct LDKCResult_UnsignedNodeAnnouncementDecodeErrorZ UnsignedNodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Serialize the NodeAnnouncement object into a byte array which can be read by NodeAnnouncement_read
 */
struct LDKCVec_u8Z NodeAnnouncement_write(const struct LDKNodeAnnouncement *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncement from a byte array, created by NodeAnnouncement_write
 */
struct LDKCResult_NodeAnnouncementDecodeErrorZ NodeAnnouncement_read(struct LDKu8slice ser);

/**
 * Read a QueryShortChannelIds from a byte array, created by QueryShortChannelIds_write
 */
struct LDKCResult_QueryShortChannelIdsDecodeErrorZ QueryShortChannelIds_read(struct LDKu8slice ser);

/**
 * Serialize the QueryShortChannelIds object into a byte array which can be read by QueryShortChannelIds_read
 */
struct LDKCVec_u8Z QueryShortChannelIds_write(const struct LDKQueryShortChannelIds *NONNULL_PTR obj);

/**
 * Serialize the ReplyShortChannelIdsEnd object into a byte array which can be read by ReplyShortChannelIdsEnd_read
 */
struct LDKCVec_u8Z ReplyShortChannelIdsEnd_write(const struct LDKReplyShortChannelIdsEnd *NONNULL_PTR obj);

/**
 * Read a ReplyShortChannelIdsEnd from a byte array, created by ReplyShortChannelIdsEnd_write
 */
struct LDKCResult_ReplyShortChannelIdsEndDecodeErrorZ ReplyShortChannelIdsEnd_read(struct LDKu8slice ser);

/**
 * Calculates the overflow safe ending block height for the query.
 *
 * Overflow returns `0xffffffff`, otherwise returns `first_blocknum + number_of_blocks`.
 */
MUST_USE_RES uint32_t QueryChannelRange_end_blocknum(const struct LDKQueryChannelRange *NONNULL_PTR this_arg);

/**
 * Serialize the QueryChannelRange object into a byte array which can be read by QueryChannelRange_read
 */
struct LDKCVec_u8Z QueryChannelRange_write(const struct LDKQueryChannelRange *NONNULL_PTR obj);

/**
 * Read a QueryChannelRange from a byte array, created by QueryChannelRange_write
 */
struct LDKCResult_QueryChannelRangeDecodeErrorZ QueryChannelRange_read(struct LDKu8slice ser);

/**
 * Read a ReplyChannelRange from a byte array, created by ReplyChannelRange_write
 */
struct LDKCResult_ReplyChannelRangeDecodeErrorZ ReplyChannelRange_read(struct LDKu8slice ser);

/**
 * Serialize the ReplyChannelRange object into a byte array which can be read by ReplyChannelRange_read
 */
struct LDKCVec_u8Z ReplyChannelRange_write(const struct LDKReplyChannelRange *NONNULL_PTR obj);

/**
 * Serialize the GossipTimestampFilter object into a byte array which can be read by GossipTimestampFilter_read
 */
struct LDKCVec_u8Z GossipTimestampFilter_write(const struct LDKGossipTimestampFilter *NONNULL_PTR obj);

/**
 * Read a GossipTimestampFilter from a byte array, created by GossipTimestampFilter_write
 */
struct LDKCResult_GossipTimestampFilterDecodeErrorZ GossipTimestampFilter_read(struct LDKu8slice ser);

/**
 * Calls the free function if one is set
 */
void CustomMessageHandler_free(struct LDKCustomMessageHandler this_ptr);

/**
 * Frees any resources used by the IgnoringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void IgnoringMessageHandler_free(struct LDKIgnoringMessageHandler this_obj);

/**
 * Constructs a new IgnoringMessageHandler given each field
 */
MUST_USE_RES struct LDKIgnoringMessageHandler IgnoringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider IgnoringMessageHandler_as_MessageSendEventsProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler IgnoringMessageHandler_as_RoutingMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageProvider must be freed before this_arg is
 */
struct LDKOnionMessageProvider IgnoringMessageHandler_as_OnionMessageProvider(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
 */
struct LDKOnionMessageHandler IgnoringMessageHandler_as_OnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new OffersMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OffersMessageHandler must be freed before this_arg is
 */
struct LDKOffersMessageHandler IgnoringMessageHandler_as_OffersMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomOnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomOnionMessageHandler must be freed before this_arg is
 */
struct LDKCustomOnionMessageHandler IgnoringMessageHandler_as_CustomOnionMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageReader which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageReader must be freed before this_arg is
 */
struct LDKCustomMessageReader IgnoringMessageHandler_as_CustomMessageReader(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new CustomMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CustomMessageHandler must be freed before this_arg is
 */
struct LDKCustomMessageHandler IgnoringMessageHandler_as_CustomMessageHandler(const struct LDKIgnoringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ErroringMessageHandler, if is_owned is set and inner is non-NULL.
 */
void ErroringMessageHandler_free(struct LDKErroringMessageHandler this_obj);

/**
 * Constructs a new ErroringMessageHandler
 */
MUST_USE_RES struct LDKErroringMessageHandler ErroringMessageHandler_new(void);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider ErroringMessageHandler_as_MessageSendEventsProvider(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelMessageHandler must be freed before this_arg is
 */
struct LDKChannelMessageHandler ErroringMessageHandler_as_ChannelMessageHandler(const struct LDKErroringMessageHandler *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the MessageHandler, if is_owned is set and inner is non-NULL.
 */
void MessageHandler_free(struct LDKMessageHandler this_obj);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
const struct LDKChannelMessageHandler *MessageHandler_get_chan_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages specific to channels. Usually this is just a
 * [`ChannelManager`] object or an [`ErroringMessageHandler`].
 *
 * [`ChannelManager`]: crate::ln::channelmanager::ChannelManager
 */
void MessageHandler_set_chan_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKChannelMessageHandler val);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
 *
 * [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
 */
const struct LDKRoutingMessageHandler *MessageHandler_get_route_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles messages updating our knowledge of the network channel
 * graph. Usually this is just a [`P2PGossipSync`] object or an [`IgnoringMessageHandler`].
 *
 * [`P2PGossipSync`]: crate::routing::gossip::P2PGossipSync
 */
void MessageHandler_set_route_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKRoutingMessageHandler val);

/**
 * A message handler which handles onion messages. This should generally be an
 * [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
 *
 * [`OnionMessenger`]: crate::onion_message::OnionMessenger
 */
const struct LDKOnionMessageHandler *MessageHandler_get_onion_message_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles onion messages. This should generally be an
 * [`OnionMessenger`], but can also be an [`IgnoringMessageHandler`].
 *
 * [`OnionMessenger`]: crate::onion_message::OnionMessenger
 */
void MessageHandler_set_onion_message_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKOnionMessageHandler val);

/**
 * A message handler which handles custom messages. The only LDK-provided implementation is
 * [`IgnoringMessageHandler`].
 */
const struct LDKCustomMessageHandler *MessageHandler_get_custom_message_handler(const struct LDKMessageHandler *NONNULL_PTR this_ptr);

/**
 * A message handler which handles custom messages. The only LDK-provided implementation is
 * [`IgnoringMessageHandler`].
 */
void MessageHandler_set_custom_message_handler(struct LDKMessageHandler *NONNULL_PTR this_ptr, struct LDKCustomMessageHandler val);

/**
 * Constructs a new MessageHandler given each field
 */
MUST_USE_RES struct LDKMessageHandler MessageHandler_new(struct LDKChannelMessageHandler chan_handler_arg, struct LDKRoutingMessageHandler route_handler_arg, struct LDKOnionMessageHandler onion_message_handler_arg, struct LDKCustomMessageHandler custom_message_handler_arg);

/**
 * Creates a copy of a SocketDescriptor
 */
struct LDKSocketDescriptor SocketDescriptor_clone(const struct LDKSocketDescriptor *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void SocketDescriptor_free(struct LDKSocketDescriptor this_ptr);

/**
 * Frees any resources used by the PeerHandleError, if is_owned is set and inner is non-NULL.
 */
void PeerHandleError_free(struct LDKPeerHandleError this_obj);

/**
 * Constructs a new PeerHandleError given each field
 */
MUST_USE_RES struct LDKPeerHandleError PeerHandleError_new(void);

/**
 * Creates a copy of the PeerHandleError
 */
struct LDKPeerHandleError PeerHandleError_clone(const struct LDKPeerHandleError *NONNULL_PTR orig);

/**
 * Frees any resources used by the PeerManager, if is_owned is set and inner is non-NULL.
 */
void PeerManager_free(struct LDKPeerManager this_obj);

/**
 * Constructs a new `PeerManager` with the given message handlers.
 *
 * `ephemeral_random_data` is used to derive per-connection ephemeral keys and must be
 * cryptographically secure random bytes.
 *
 * `current_time` is used as an always-increasing counter that survives across restarts and is
 * incremented irregularly internally. In general it is best to simply use the current UNIX
 * timestamp, however if it is not available a persistent counter that increases once per
 * minute should suffice.
 */
MUST_USE_RES struct LDKPeerManager PeerManager_new(struct LDKMessageHandler message_handler, uint32_t current_time, const uint8_t (*ephemeral_random_data)[32], struct LDKLogger logger, struct LDKNodeSigner node_signer);

/**
 * Get a list of tuples mapping from node id to network addresses for peers which have
 * completed the initial handshake.
 *
 * For outbound connections, the [`PublicKey`] will be the same as the `their_node_id` parameter
 * passed in to [`Self::new_outbound_connection`], however entries will only appear once the initial
 * handshake has completed and we are sure the remote peer has the private key for the given
 * [`PublicKey`].
 *
 * The returned `Option`s will only be `Some` if an address had been previously given via
 * [`Self::new_outbound_connection`] or [`Self::new_inbound_connection`].
 */
MUST_USE_RES struct LDKCVec_C2Tuple_PublicKeyCOption_SocketAddressZZZ PeerManager_get_peer_node_ids(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates a new outbound connection has been established to a node with the given `node_id`
 * and an optional remote network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * If an `Err` is returned here you must disconnect the connection immediately.
 *
 * Returns a small number of bytes to send to the remote node (currently always 50).
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected`].
 *
 * [`socket_disconnected`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZPeerHandleErrorZ PeerManager_new_outbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey their_node_id, struct LDKSocketDescriptor descriptor, struct LDKCOption_SocketAddressZ remote_network_address);

/**
 * Indicates a new inbound connection has been established to a node with an optional remote
 * network address.
 *
 * The remote network address adds the option to report a remote IP address back to a connecting
 * peer using the init message.
 * The user should pass the remote network address of the host they are connected to.
 *
 * May refuse the connection by returning an Err, but will never write bytes to the remote end
 * (outbound connector always speaks first). If an `Err` is returned here you must disconnect
 * the connection immediately.
 *
 * Panics if descriptor is duplicative with some other descriptor which has not yet been
 * [`socket_disconnected`].
 *
 * [`socket_disconnected`]: PeerManager::socket_disconnected
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_new_inbound_connection(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor descriptor, struct LDKCOption_SocketAddressZ remote_network_address);

/**
 * Indicates that there is room to write data to the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * May call [`send_data`] on the descriptor passed in (or an equal descriptor) before
 * returning. Thus, be very careful with reentrancy issues! The invariants around calling
 * [`write_buffer_space_avail`] in case a write did not fully complete must still hold - be
 * ready to call [`write_buffer_space_avail`] again if a write call generated here isn't
 * sufficient!
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`write_buffer_space_avail`]: PeerManager::write_buffer_space_avail
 */
MUST_USE_RES struct LDKCResult_NonePeerHandleErrorZ PeerManager_write_buffer_space_avail(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Indicates that data was read from the given socket descriptor.
 *
 * May return an Err to indicate that the connection should be closed.
 *
 * Will *not* call back into [`send_data`] on any descriptors to avoid reentrancy complexity.
 * Thus, however, you should call [`process_events`] after any `read_event` to generate
 * [`send_data`] calls to handle responses.
 *
 * If `Ok(true)` is returned, further read_events should not be triggered until a
 * [`send_data`] call on this descriptor has `resume_read` set (preventing DoS issues in the
 * send buffer).
 *
 * In order to avoid processing too many messages at once per peer, `data` should be on the
 * order of 4KiB.
 *
 * [`send_data`]: SocketDescriptor::send_data
 * [`process_events`]: PeerManager::process_events
 */
MUST_USE_RES struct LDKCResult_boolPeerHandleErrorZ PeerManager_read_event(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKSocketDescriptor *NONNULL_PTR peer_descriptor, struct LDKu8slice data);

/**
 * Checks for any events generated by our handlers and processes them. Includes sending most
 * response messages as well as messages generated by calls to handler functions directly (eg
 * functions like [`ChannelManager::process_pending_htlc_forwards`] or [`send_payment`]).
 *
 * May call [`send_data`] on [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * You don't have to call this function explicitly if you are using [`lightning-net-tokio`]
 * or one of the other clients provided in our language bindings.
 *
 * Note that if there are any other calls to this function waiting on lock(s) this may return
 * without doing any work. All available events that need handling will be handled before the
 * other calls return.
 *
 * [`send_payment`]: crate::ln::channelmanager::ChannelManager::send_payment
 * [`ChannelManager::process_pending_htlc_forwards`]: crate::ln::channelmanager::ChannelManager::process_pending_htlc_forwards
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_process_events(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Indicates that the given socket descriptor's connection is now closed.
 */
void PeerManager_socket_disconnected(const struct LDKPeerManager *NONNULL_PTR this_arg, const struct LDKSocketDescriptor *NONNULL_PTR descriptor);

/**
 * Disconnect a peer given its node id.
 *
 * If a peer is connected, this will call [`disconnect_socket`] on the descriptor for the
 * peer. Thus, be very careful about reentrancy issues.
 *
 * [`disconnect_socket`]: SocketDescriptor::disconnect_socket
 */
void PeerManager_disconnect_by_node_id(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKPublicKey node_id);

/**
 * Disconnects all currently-connected peers. This is useful on platforms where there may be
 * an indication that TCP sockets have stalled even if we weren't around to time them out
 * using regular ping/pongs.
 */
void PeerManager_disconnect_all_peers(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Send pings to each peer and disconnect those which did not respond to the last round of
 * pings.
 *
 * This may be called on any timescale you want, however, roughly once every ten seconds is
 * preferred. The call rate determines both how often we send a ping to our peers and how much
 * time they have to respond before we disconnect them.
 *
 * May call [`send_data`] on all [`SocketDescriptor`]s. Thus, be very careful with reentrancy
 * issues!
 *
 * [`send_data`]: SocketDescriptor::send_data
 */
void PeerManager_timer_tick_occurred(const struct LDKPeerManager *NONNULL_PTR this_arg);

/**
 * Generates a signed node_announcement from the given arguments, sending it to all connected
 * peers. Note that peers will likely ignore this message unless we have at least one public
 * channel which has at least six confirmations on-chain.
 *
 * `rgb` is a node \"color\" and `alias` is a printable human-readable string to describe this
 * node to humans. They carry no in-protocol meaning.
 *
 * `addresses` represent the set (possibly empty) of socket addresses on which this node
 * accepts incoming connections. These will be included in the node_announcement, publicly
 * tying these addresses together and to this node. If you wish to preserve user privacy,
 * addresses should likely contain only Tor Onion addresses.
 *
 * Panics if `addresses` is absurdly large (more than 100).
 *
 * [`get_and_clear_pending_msg_events`]: MessageSendEventsProvider::get_and_clear_pending_msg_events
 */
void PeerManager_broadcast_node_announcement(const struct LDKPeerManager *NONNULL_PTR this_arg, struct LDKThreeBytes rgb, struct LDKThirtyTwoBytes alias, struct LDKCVec_SocketAddressZ addresses);

/**
 * Gets the weight for an HTLC-Success transaction.
 */
uint64_t htlc_success_tx_weight(const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);

/**
 * Gets the weight for an HTLC-Timeout transaction.
 */
uint64_t htlc_timeout_tx_weight(const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);

/**
 * Creates a copy of the HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_clone(const enum LDKHTLCClaim *NONNULL_PTR orig);

/**
 * Utility method to constructs a new OfferedTimeout-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_offered_timeout(void);

/**
 * Utility method to constructs a new OfferedPreimage-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_offered_preimage(void);

/**
 * Utility method to constructs a new AcceptedTimeout-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_accepted_timeout(void);

/**
 * Utility method to constructs a new AcceptedPreimage-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_accepted_preimage(void);

/**
 * Utility method to constructs a new Revocation-variant HTLCClaim
 */
enum LDKHTLCClaim HTLCClaim_revocation(void);

/**
 * Checks if two HTLCClaims contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool HTLCClaim_eq(const enum LDKHTLCClaim *NONNULL_PTR a, const enum LDKHTLCClaim *NONNULL_PTR b);

/**
 * Check if a given input witness attempts to claim a HTLC.
 */
MUST_USE_RES struct LDKCOption_HTLCClaimZ HTLCClaim_from_witness(struct LDKWitness witness);

/**
 * Build the commitment secret from the seed and the commitment number
 */
struct LDKThirtyTwoBytes build_commitment_secret(const uint8_t (*commitment_seed)[32], uint64_t idx);

/**
 * Build a closing transaction
 */
struct LDKTransaction build_closing_transaction(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Frees any resources used by the CounterpartyCommitmentSecrets, if is_owned is set and inner is non-NULL.
 */
void CounterpartyCommitmentSecrets_free(struct LDKCounterpartyCommitmentSecrets this_obj);

/**
 * Creates a copy of the CounterpartyCommitmentSecrets
 */
struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_clone(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR orig);

/**
 * Creates a new empty `CounterpartyCommitmentSecrets` structure.
 */
MUST_USE_RES struct LDKCounterpartyCommitmentSecrets CounterpartyCommitmentSecrets_new(void);

/**
 * Returns the minimum index of all stored secrets. Note that indexes start
 * at 1 << 48 and get decremented by one for each new secret.
 */
MUST_USE_RES uint64_t CounterpartyCommitmentSecrets_get_min_seen_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg);

/**
 * Inserts the `secret` at `idx`. Returns `Ok(())` if the secret
 * was generated in accordance with BOLT 3 and is consistent with previous secrets.
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ CounterpartyCommitmentSecrets_provide_secret(struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx, struct LDKThirtyTwoBytes secret);

/**
 * Returns the secret at `idx`.
 * Returns `None` if `idx` is < [`CounterpartyCommitmentSecrets::get_min_seen_secret`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKThirtyTwoBytes CounterpartyCommitmentSecrets_get_secret(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR this_arg, uint64_t idx);

/**
 * Serialize the CounterpartyCommitmentSecrets object into a byte array which can be read by CounterpartyCommitmentSecrets_read
 */
struct LDKCVec_u8Z CounterpartyCommitmentSecrets_write(const struct LDKCounterpartyCommitmentSecrets *NONNULL_PTR obj);

/**
 * Read a CounterpartyCommitmentSecrets from a byte array, created by CounterpartyCommitmentSecrets_write
 */
struct LDKCResult_CounterpartyCommitmentSecretsDecodeErrorZ CounterpartyCommitmentSecrets_read(struct LDKu8slice ser);

/**
 * Derives a per-commitment-transaction private key (eg an htlc key or delayed_payment key)
 * from the base secret and the per_commitment_point.
 */
struct LDKSecretKey derive_private_key(struct LDKPublicKey per_commitment_point, const uint8_t (*base_secret)[32]);

/**
 * Derives a per-commitment-transaction public key (eg an htlc key or a delayed_payment key)
 * from the base point and the per_commitment_key. This is the public equivalent of
 * derive_private_key - using only public keys to derive a public key instead of private keys.
 */
struct LDKPublicKey derive_public_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey base_point);

/**
 * Derives a per-commitment-transaction revocation key from its constituent parts.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_secret always come from cheater
 * and revocation_base_secret always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 */
struct LDKSecretKey derive_private_revocation_key(const uint8_t (*per_commitment_secret)[32], const uint8_t (*countersignatory_revocation_base_secret)[32]);

/**
 * Derives a per-commitment-transaction revocation public key from its constituent parts. This is
 * the public equivalend of derive_private_revocation_key - using only public keys to derive a
 * public key instead of private keys.
 *
 * Only the cheating participant owns a valid witness to propagate a revoked
 * commitment transaction, thus per_commitment_point always come from cheater
 * and revocation_base_point always come from punisher, which is the broadcaster
 * of the transaction spending with this key knowledge.
 *
 * Note that this is infallible iff we trust that at least one of the two input keys are randomly
 * generated (ie our own).
 */
struct LDKPublicKey derive_public_revocation_key(struct LDKPublicKey per_commitment_point, struct LDKPublicKey countersignatory_revocation_base_point);

/**
 * Frees any resources used by the TxCreationKeys, if is_owned is set and inner is non-NULL.
 */
void TxCreationKeys_free(struct LDKTxCreationKeys this_obj);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
struct LDKPublicKey TxCreationKeys_get_per_commitment_point(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The broadcaster's per-commitment public key which was used to derive the other keys.
 */
void TxCreationKeys_set_per_commitment_point(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
struct LDKPublicKey TxCreationKeys_get_revocation_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * The revocation key which is used to allow the broadcaster of the commitment
 * transaction to provide their counterparty the ability to punish them if they broadcast
 * an old state.
 */
void TxCreationKeys_set_revocation_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's HTLC Key
 */
void TxCreationKeys_set_broadcaster_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Countersignatory's HTLC Key
 */
struct LDKPublicKey TxCreationKeys_get_countersignatory_htlc_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Countersignatory's HTLC Key
 */
void TxCreationKeys_set_countersignatory_htlc_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
struct LDKPublicKey TxCreationKeys_get_broadcaster_delayed_payment_key(const struct LDKTxCreationKeys *NONNULL_PTR this_ptr);

/**
 * Broadcaster's Payment Key (which isn't allowed to be spent from for some delay)
 */
void TxCreationKeys_set_broadcaster_delayed_payment_key(struct LDKTxCreationKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new TxCreationKeys given each field
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_new(struct LDKPublicKey per_commitment_point_arg, struct LDKPublicKey revocation_key_arg, struct LDKPublicKey broadcaster_htlc_key_arg, struct LDKPublicKey countersignatory_htlc_key_arg, struct LDKPublicKey broadcaster_delayed_payment_key_arg);

/**
 * Checks if two TxCreationKeyss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool TxCreationKeys_eq(const struct LDKTxCreationKeys *NONNULL_PTR a, const struct LDKTxCreationKeys *NONNULL_PTR b);

/**
 * Creates a copy of the TxCreationKeys
 */
struct LDKTxCreationKeys TxCreationKeys_clone(const struct LDKTxCreationKeys *NONNULL_PTR orig);

/**
 * Serialize the TxCreationKeys object into a byte array which can be read by TxCreationKeys_read
 */
struct LDKCVec_u8Z TxCreationKeys_write(const struct LDKTxCreationKeys *NONNULL_PTR obj);

/**
 * Read a TxCreationKeys from a byte array, created by TxCreationKeys_write
 */
struct LDKCResult_TxCreationKeysDecodeErrorZ TxCreationKeys_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelPublicKeys, if is_owned is set and inner is non-NULL.
 */
void ChannelPublicKeys_free(struct LDKChannelPublicKeys this_obj);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
struct LDKPublicKey ChannelPublicKeys_get_funding_pubkey(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key which is used to sign all commitment transactions, as it appears in the
 * on-chain channel lock-in 2-of-2 multisig output.
 */
void ChannelPublicKeys_set_funding_pubkey(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
struct LDKPublicKey ChannelPublicKeys_get_revocation_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_revocation_key) to derive per-commitment
 * revocation keys. This is combined with the per-commitment-secret generated by the
 * counterparty to create a secret which the counterparty can reveal to revoke previous
 * states.
 */
void ChannelPublicKeys_set_revocation_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
struct LDKPublicKey ChannelPublicKeys_get_payment_point(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The public key on which the non-broadcaster (ie the countersignatory) receives an immediately
 * spendable primary channel balance on the broadcaster's commitment transaction. This key is
 * static across every commitment transaction.
 */
void ChannelPublicKeys_set_payment_point(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
struct LDKPublicKey ChannelPublicKeys_get_delayed_payment_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment payment
 * public key which receives non-HTLC-encumbered funds which are only available for spending
 * after some delay (or can be claimed via the revocation path).
 */
void ChannelPublicKeys_set_delayed_payment_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
struct LDKPublicKey ChannelPublicKeys_get_htlc_basepoint(const struct LDKChannelPublicKeys *NONNULL_PTR this_ptr);

/**
 * The base point which is used (with derive_public_key) to derive a per-commitment public key
 * which is used to encumber HTLC-in-flight outputs.
 */
void ChannelPublicKeys_set_htlc_basepoint(struct LDKChannelPublicKeys *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new ChannelPublicKeys given each field
 */
MUST_USE_RES struct LDKChannelPublicKeys ChannelPublicKeys_new(struct LDKPublicKey funding_pubkey_arg, struct LDKPublicKey revocation_basepoint_arg, struct LDKPublicKey payment_point_arg, struct LDKPublicKey delayed_payment_basepoint_arg, struct LDKPublicKey htlc_basepoint_arg);

/**
 * Creates a copy of the ChannelPublicKeys
 */
struct LDKChannelPublicKeys ChannelPublicKeys_clone(const struct LDKChannelPublicKeys *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the ChannelPublicKeys.
 */
uint64_t ChannelPublicKeys_hash(const struct LDKChannelPublicKeys *NONNULL_PTR o);

/**
 * Checks if two ChannelPublicKeyss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelPublicKeys_eq(const struct LDKChannelPublicKeys *NONNULL_PTR a, const struct LDKChannelPublicKeys *NONNULL_PTR b);

/**
 * Serialize the ChannelPublicKeys object into a byte array which can be read by ChannelPublicKeys_read
 */
struct LDKCVec_u8Z ChannelPublicKeys_write(const struct LDKChannelPublicKeys *NONNULL_PTR obj);

/**
 * Read a ChannelPublicKeys from a byte array, created by ChannelPublicKeys_write
 */
struct LDKCResult_ChannelPublicKeysDecodeErrorZ ChannelPublicKeys_read(struct LDKu8slice ser);

/**
 * Create per-state keys from channel base points and the per-commitment point.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_derive_new(struct LDKPublicKey per_commitment_point, struct LDKPublicKey broadcaster_delayed_payment_base, struct LDKPublicKey broadcaster_htlc_base, struct LDKPublicKey countersignatory_revocation_base, struct LDKPublicKey countersignatory_htlc_base);

/**
 * Generate per-state keys from channel static keys.
 * Key set is asymmetric and can't be used as part of counter-signatory set of transactions.
 */
MUST_USE_RES struct LDKTxCreationKeys TxCreationKeys_from_channel_static_keys(struct LDKPublicKey per_commitment_point, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * A script either spendable by the revocation
 * key or the broadcaster_delayed_payment_key and satisfying the relative-locktime OP_CSV constrain.
 * Encumbering a `to_holder` output on a commitment transaction or 2nd-stage HTLC transactions.
 */
struct LDKCVec_u8Z get_revokeable_redeemscript(struct LDKPublicKey revocation_key, uint16_t contest_delay, struct LDKPublicKey broadcaster_delayed_payment_key);

/**
 * Returns the script for the counterparty's output on a holder's commitment transaction based on
 * the channel type.
 */
struct LDKCVec_u8Z get_counterparty_payment_script(const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features, struct LDKPublicKey payment_key);

/**
 * Frees any resources used by the HTLCOutputInCommitment, if is_owned is set and inner is non-NULL.
 */
void HTLCOutputInCommitment_free(struct LDKHTLCOutputInCommitment this_obj);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
bool HTLCOutputInCommitment_get_offered(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * Whether the HTLC was \"offered\" (ie outbound in relation to this commitment transaction).
 * Note that this is not the same as whether it is ountbound *from us*. To determine that you
 * need to compare this value to whether the commitment transaction in question is that of
 * the counterparty or our own.
 */
void HTLCOutputInCommitment_set_offered(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, bool val);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
uint64_t HTLCOutputInCommitment_get_amount_msat(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The value, in msat, of the HTLC. The value as it appears in the commitment transaction is
 * this divided by 1000.
 */
void HTLCOutputInCommitment_set_amount_msat(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
uint32_t HTLCOutputInCommitment_get_cltv_expiry(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The CLTV lock-time at which this HTLC expires.
 */
void HTLCOutputInCommitment_set_cltv_expiry(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The hash of the preimage which unlocks this HTLC.
 */
const uint8_t (*HTLCOutputInCommitment_get_payment_hash(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr))[32];

/**
 * The hash of the preimage which unlocks this HTLC.
 */
void HTLCOutputInCommitment_set_payment_hash(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
struct LDKCOption_u32Z HTLCOutputInCommitment_get_transaction_output_index(const struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr);

/**
 * The position within the commitment transactions' outputs. This may be None if the value is
 * below the dust limit (in which case no output appears in the commitment transaction and the
 * value is spent to additional transaction fees).
 */
void HTLCOutputInCommitment_set_transaction_output_index(struct LDKHTLCOutputInCommitment *NONNULL_PTR this_ptr, struct LDKCOption_u32Z val);

/**
 * Constructs a new HTLCOutputInCommitment given each field
 */
MUST_USE_RES struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_new(bool offered_arg, uint64_t amount_msat_arg, uint32_t cltv_expiry_arg, struct LDKThirtyTwoBytes payment_hash_arg, struct LDKCOption_u32Z transaction_output_index_arg);

/**
 * Creates a copy of the HTLCOutputInCommitment
 */
struct LDKHTLCOutputInCommitment HTLCOutputInCommitment_clone(const struct LDKHTLCOutputInCommitment *NONNULL_PTR orig);

/**
 * Checks if two HTLCOutputInCommitments contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool HTLCOutputInCommitment_eq(const struct LDKHTLCOutputInCommitment *NONNULL_PTR a, const struct LDKHTLCOutputInCommitment *NONNULL_PTR b);

/**
 * Serialize the HTLCOutputInCommitment object into a byte array which can be read by HTLCOutputInCommitment_read
 */
struct LDKCVec_u8Z HTLCOutputInCommitment_write(const struct LDKHTLCOutputInCommitment *NONNULL_PTR obj);

/**
 * Read a HTLCOutputInCommitment from a byte array, created by HTLCOutputInCommitment_write
 */
struct LDKCResult_HTLCOutputInCommitmentDecodeErrorZ HTLCOutputInCommitment_read(struct LDKu8slice ser);

/**
 * Gets the witness redeemscript for an HTLC output in a commitment transaction. Note that htlc
 * does not need to have its previous_output_index filled.
 */
struct LDKCVec_u8Z get_htlc_redeemscript(const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features, const struct LDKTxCreationKeys *NONNULL_PTR keys);

/**
 * Gets the redeemscript for a funding output from the two funding public keys.
 * Note that the order of funding public keys does not matter.
 */
struct LDKCVec_u8Z make_funding_redeemscript(struct LDKPublicKey broadcaster, struct LDKPublicKey countersignatory);

/**
 * Builds an unsigned HTLC-Success or HTLC-Timeout transaction from the given channel and HTLC
 * parameters. This is used by [`TrustedCommitmentTransaction::get_htlc_sigs`] to fetch the
 * transaction which needs signing, and can be used to construct an HTLC transaction which is
 * broadcastable given a counterparty HTLC signature.
 *
 * Panics if htlc.transaction_output_index.is_none() (as such HTLCs do not appear in the
 * commitment transaction).
 */
struct LDKTransaction build_htlc_transaction(const uint8_t (*commitment_txid)[32], uint32_t feerate_per_kw, uint16_t contest_delay, const struct LDKHTLCOutputInCommitment *NONNULL_PTR htlc, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features, struct LDKPublicKey broadcaster_delayed_payment_key, struct LDKPublicKey revocation_key);

/**
 * Returns the witness required to satisfy and spend a HTLC input.
 */
struct LDKWitness build_htlc_input_witness(struct LDKECDSASignature local_sig, struct LDKECDSASignature remote_sig, struct LDKCOption_ThirtyTwoBytesZ preimage, struct LDKu8slice redeem_script, const struct LDKChannelTypeFeatures *NONNULL_PTR channel_type_features);

/**
 * Gets the witnessScript for the to_remote output when anchors are enabled.
 */
struct LDKCVec_u8Z get_to_countersignatory_with_anchors_redeemscript(struct LDKPublicKey payment_point);

/**
 * Gets the witnessScript for an anchor output from the funding public key.
 * The witness in the spending input must be:
 * <BIP 143 funding_signature>
 * After 16 blocks of confirmation, an alternative satisfying witness could be:
 * <>
 * (empty vector required to satisfy compliance with MINIMALIF-standard rule)
 */
struct LDKCVec_u8Z get_anchor_redeemscript(struct LDKPublicKey funding_pubkey);

/**
 * Returns the witness required to satisfy and spend an anchor input.
 */
struct LDKWitness build_anchor_input_witness(struct LDKPublicKey funding_key, struct LDKECDSASignature funding_sig);

/**
 * Frees any resources used by the ChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelTransactionParameters_free(struct LDKChannelTransactionParameters this_obj);

/**
 * Holder public keys
 */
struct LDKChannelPublicKeys ChannelTransactionParameters_get_holder_pubkeys(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Holder public keys
 */
void ChannelTransactionParameters_set_holder_pubkeys(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
uint16_t ChannelTransactionParameters_get_holder_selected_contest_delay(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the holder, which applies to counterparty-broadcast transactions
 */
void ChannelTransactionParameters_set_holder_selected_contest_delay(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
bool ChannelTransactionParameters_get_is_outbound_from_holder(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Whether the holder is the initiator of this channel.
 * This is an input to the commitment number obscure factor computation.
 */
void ChannelTransactionParameters_set_is_outbound_from_holder(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, bool val);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCounterpartyChannelTransactionParameters ChannelTransactionParameters_get_counterparty_parameters(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound counterparty channel transaction parameters.
 * These parameters are populated at the point in the protocol where the counterparty provides them.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_counterparty_parameters(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKCounterpartyChannelTransactionParameters val);

/**
 * The late-bound funding outpoint
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKOutPoint ChannelTransactionParameters_get_funding_outpoint(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The late-bound funding outpoint
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelTransactionParameters_set_funding_outpoint(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * This channel's type, as negotiated during channel open. For old objects where this field
 * wasn't serialized, it will default to static_remote_key at deserialization.
 */
struct LDKChannelTypeFeatures ChannelTransactionParameters_get_channel_type_features(const struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * This channel's type, as negotiated during channel open. For old objects where this field
 * wasn't serialized, it will default to static_remote_key at deserialization.
 */
void ChannelTransactionParameters_set_channel_type_features(struct LDKChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelTypeFeatures val);

/**
 * Constructs a new ChannelTransactionParameters given each field
 *
 * Note that counterparty_parameters_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 * Note that funding_outpoint_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelTransactionParameters ChannelTransactionParameters_new(struct LDKChannelPublicKeys holder_pubkeys_arg, uint16_t holder_selected_contest_delay_arg, bool is_outbound_from_holder_arg, struct LDKCounterpartyChannelTransactionParameters counterparty_parameters_arg, struct LDKOutPoint funding_outpoint_arg, struct LDKChannelTypeFeatures channel_type_features_arg);

/**
 * Creates a copy of the ChannelTransactionParameters
 */
struct LDKChannelTransactionParameters ChannelTransactionParameters_clone(const struct LDKChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the ChannelTransactionParameters.
 */
uint64_t ChannelTransactionParameters_hash(const struct LDKChannelTransactionParameters *NONNULL_PTR o);

/**
 * Checks if two ChannelTransactionParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelTransactionParameters_eq(const struct LDKChannelTransactionParameters *NONNULL_PTR a, const struct LDKChannelTransactionParameters *NONNULL_PTR b);

/**
 * Frees any resources used by the CounterpartyChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void CounterpartyChannelTransactionParameters_free(struct LDKCounterpartyChannelTransactionParameters this_obj);

/**
 * Counter-party public keys
 */
struct LDKChannelPublicKeys CounterpartyChannelTransactionParameters_get_pubkeys(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * Counter-party public keys
 */
void CounterpartyChannelTransactionParameters_set_pubkeys(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, struct LDKChannelPublicKeys val);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
uint16_t CounterpartyChannelTransactionParameters_get_selected_contest_delay(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr);

/**
 * The contest delay selected by the counterparty, which applies to holder-broadcast transactions
 */
void CounterpartyChannelTransactionParameters_set_selected_contest_delay(struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Constructs a new CounterpartyChannelTransactionParameters given each field
 */
MUST_USE_RES struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_new(struct LDKChannelPublicKeys pubkeys_arg, uint16_t selected_contest_delay_arg);

/**
 * Creates a copy of the CounterpartyChannelTransactionParameters
 */
struct LDKCounterpartyChannelTransactionParameters CounterpartyChannelTransactionParameters_clone(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the CounterpartyChannelTransactionParameters.
 */
uint64_t CounterpartyChannelTransactionParameters_hash(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR o);

/**
 * Checks if two CounterpartyChannelTransactionParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool CounterpartyChannelTransactionParameters_eq(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR a, const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR b);

/**
 * Whether the late bound parameters are populated.
 */
MUST_USE_RES bool ChannelTransactionParameters_is_populated(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the holder is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_holder_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Convert the holder/counterparty parameters to broadcaster/countersignatory-organized parameters,
 * given that the counterparty is the broadcaster.
 *
 * self.is_populated() must be true before calling this function.
 */
MUST_USE_RES struct LDKDirectedChannelTransactionParameters ChannelTransactionParameters_as_counterparty_broadcastable(const struct LDKChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Serialize the CounterpartyChannelTransactionParameters object into a byte array which can be read by CounterpartyChannelTransactionParameters_read
 */
struct LDKCVec_u8Z CounterpartyChannelTransactionParameters_write(const struct LDKCounterpartyChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a CounterpartyChannelTransactionParameters from a byte array, created by CounterpartyChannelTransactionParameters_write
 */
struct LDKCResult_CounterpartyChannelTransactionParametersDecodeErrorZ CounterpartyChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTransactionParameters object into a byte array which can be read by ChannelTransactionParameters_read
 */
struct LDKCVec_u8Z ChannelTransactionParameters_write(const struct LDKChannelTransactionParameters *NONNULL_PTR obj);

/**
 * Read a ChannelTransactionParameters from a byte array, created by ChannelTransactionParameters_write
 */
struct LDKCResult_ChannelTransactionParametersDecodeErrorZ ChannelTransactionParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelTransactionParameters, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelTransactionParameters_free(struct LDKDirectedChannelTransactionParameters this_obj);

/**
 * Get the channel pubkeys for the broadcaster
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_broadcaster_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the channel pubkeys for the countersignatory
 */
MUST_USE_RES struct LDKChannelPublicKeys DirectedChannelTransactionParameters_countersignatory_pubkeys(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Get the contest delay applicable to the transactions.
 * Note that the contest delay was selected by the countersignatory.
 */
MUST_USE_RES uint16_t DirectedChannelTransactionParameters_contest_delay(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether the channel is outbound from the broadcaster.
 *
 * The boolean representing the side that initiated the channel is
 * an input to the commitment number obscure factor computation.
 */
MUST_USE_RES bool DirectedChannelTransactionParameters_is_outbound(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * The funding outpoint
 */
MUST_USE_RES struct LDKOutPoint DirectedChannelTransactionParameters_funding_outpoint(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Whether to use anchors for this channel
 */
MUST_USE_RES struct LDKChannelTypeFeatures DirectedChannelTransactionParameters_channel_type_features(const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the HolderCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void HolderCommitmentTransaction_free(struct LDKHolderCommitmentTransaction this_obj);

/**
 * Our counterparty's signature for the transaction
 */
struct LDKECDSASignature HolderCommitmentTransaction_get_counterparty_sig(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * Our counterparty's signature for the transaction
 */
void HolderCommitmentTransaction_set_counterparty_sig(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 *
 * Returns a copy of the field.
 */
struct LDKCVec_ECDSASignatureZ HolderCommitmentTransaction_get_counterparty_htlc_sigs(const struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * All non-dust counterparty HTLC signatures, in the order they appear in the transaction
 */
void HolderCommitmentTransaction_set_counterparty_htlc_sigs(struct LDKHolderCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKCVec_ECDSASignatureZ val);

/**
 * Creates a copy of the HolderCommitmentTransaction
 */
struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_clone(const struct LDKHolderCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the HolderCommitmentTransaction object into a byte array which can be read by HolderCommitmentTransaction_read
 */
struct LDKCVec_u8Z HolderCommitmentTransaction_write(const struct LDKHolderCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a HolderCommitmentTransaction from a byte array, created by HolderCommitmentTransaction_write
 */
struct LDKCResult_HolderCommitmentTransactionDecodeErrorZ HolderCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Create a new holder transaction with the given counterparty signatures.
 * The funding keys are used to figure out which signature should go first when building the transaction for broadcast.
 */
MUST_USE_RES struct LDKHolderCommitmentTransaction HolderCommitmentTransaction_new(struct LDKCommitmentTransaction commitment_tx, struct LDKECDSASignature counterparty_sig, struct LDKCVec_ECDSASignatureZ counterparty_htlc_sigs, struct LDKPublicKey holder_funding_key, struct LDKPublicKey counterparty_funding_key);

/**
 * Frees any resources used by the BuiltCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void BuiltCommitmentTransaction_free(struct LDKBuiltCommitmentTransaction this_obj);

/**
 * The commitment transaction
 */
struct LDKTransaction BuiltCommitmentTransaction_get_transaction(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr);

/**
 * The commitment transaction
 */
void BuiltCommitmentTransaction_set_transaction(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKTransaction val);

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
const uint8_t (*BuiltCommitmentTransaction_get_txid(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr))[32];

/**
 * The txid for the commitment transaction.
 *
 * This is provided as a performance optimization, instead of calling transaction.txid()
 * multiple times.
 */
void BuiltCommitmentTransaction_set_txid(struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new BuiltCommitmentTransaction given each field
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_new(struct LDKTransaction transaction_arg, struct LDKThirtyTwoBytes txid_arg);

/**
 * Creates a copy of the BuiltCommitmentTransaction
 */
struct LDKBuiltCommitmentTransaction BuiltCommitmentTransaction_clone(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the BuiltCommitmentTransaction object into a byte array which can be read by BuiltCommitmentTransaction_read
 */
struct LDKCVec_u8Z BuiltCommitmentTransaction_write(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a BuiltCommitmentTransaction from a byte array, created by BuiltCommitmentTransaction_write
 */
struct LDKCResult_BuiltCommitmentTransactionDecodeErrorZ BuiltCommitmentTransaction_read(struct LDKu8slice ser);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes BuiltCommitmentTransaction_get_sighash_all(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Signs the counterparty's commitment transaction.
 */
MUST_USE_RES struct LDKECDSASignature BuiltCommitmentTransaction_sign_counterparty_commitment(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Signs the holder commitment transaction because we are about to broadcast it.
 */
MUST_USE_RES struct LDKECDSASignature BuiltCommitmentTransaction_sign_holder_commitment(const struct LDKBuiltCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis, const struct LDKEntropySource *NONNULL_PTR entropy_source);

/**
 * Frees any resources used by the ClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void ClosingTransaction_free(struct LDKClosingTransaction this_obj);

/**
 * Creates a copy of the ClosingTransaction
 */
struct LDKClosingTransaction ClosingTransaction_clone(const struct LDKClosingTransaction *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the ClosingTransaction.
 */
uint64_t ClosingTransaction_hash(const struct LDKClosingTransaction *NONNULL_PTR o);

/**
 * Checks if two ClosingTransactions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClosingTransaction_eq(const struct LDKClosingTransaction *NONNULL_PTR a, const struct LDKClosingTransaction *NONNULL_PTR b);

/**
 * Construct an object of the class
 */
MUST_USE_RES struct LDKClosingTransaction ClosingTransaction_new(uint64_t to_holder_value_sat, uint64_t to_counterparty_value_sat, struct LDKCVec_u8Z to_holder_script, struct LDKCVec_u8Z to_counterparty_script, struct LDKOutPoint funding_outpoint);

/**
 * Trust our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * This should only be used if you fully trust the builder of this object. It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedClosingTransaction ClosingTransaction_trust(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction.
 *
 * Applies a wrapper which allows access to the transaction.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedClosingTransactionNoneZ ClosingTransaction_verify(const struct LDKClosingTransaction *NONNULL_PTR this_arg, struct LDKOutPoint funding_outpoint);

/**
 * The value to be sent to the holder, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_holder_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty, or zero if the output will be omitted
 */
MUST_USE_RES uint64_t ClosingTransaction_to_counterparty_value_sat(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the holder's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_holder_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * The destination of the counterparty's output
 */
MUST_USE_RES struct LDKu8slice ClosingTransaction_to_counterparty_script(const struct LDKClosingTransaction *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the TrustedClosingTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedClosingTransaction_free(struct LDKTrustedClosingTransaction this_obj);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKTransaction TrustedClosingTransaction_built_transaction(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg);

/**
 * Get the SIGHASH_ALL sighash value of the transaction.
 *
 * This can be used to verify a signature.
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedClosingTransaction_get_sighash_all(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Sign a transaction, either because we are counter-signing the counterparty's transaction or
 * because we are about to broadcast a holder transaction.
 */
MUST_USE_RES struct LDKECDSASignature TrustedClosingTransaction_sign(const struct LDKTrustedClosingTransaction *NONNULL_PTR this_arg, const uint8_t (*funding_key)[32], struct LDKu8slice funding_redeemscript, uint64_t channel_value_satoshis);

/**
 * Frees any resources used by the CommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void CommitmentTransaction_free(struct LDKCommitmentTransaction this_obj);

/**
 * Creates a copy of the CommitmentTransaction
 */
struct LDKCommitmentTransaction CommitmentTransaction_clone(const struct LDKCommitmentTransaction *NONNULL_PTR orig);

/**
 * Serialize the CommitmentTransaction object into a byte array which can be read by CommitmentTransaction_read
 */
struct LDKCVec_u8Z CommitmentTransaction_write(const struct LDKCommitmentTransaction *NONNULL_PTR obj);

/**
 * Read a CommitmentTransaction from a byte array, created by CommitmentTransaction_write
 */
struct LDKCResult_CommitmentTransactionDecodeErrorZ CommitmentTransaction_read(struct LDKu8slice ser);

/**
 * The backwards-counting commitment number
 */
MUST_USE_RES uint64_t CommitmentTransaction_commitment_number(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the broadcaster
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_broadcaster_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The value to be sent to the counterparty
 */
MUST_USE_RES uint64_t CommitmentTransaction_to_countersignatory_value_sat(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The feerate paid per 1000-weight-unit in this commitment transaction.
 */
MUST_USE_RES uint32_t CommitmentTransaction_feerate_per_kw(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Trust our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * This should only be used if you fully trust the builder of this object.  It should not
 * be used by an external signer - instead use the verify function.
 */
MUST_USE_RES struct LDKTrustedCommitmentTransaction CommitmentTransaction_trust(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Verify our pre-built transaction and derived transaction creation public keys.
 *
 * Applies a wrapper which allows access to these fields.
 *
 * An external validating signer must call this method before signing
 * or using the built transaction.
 */
MUST_USE_RES struct LDKCResult_TrustedCommitmentTransactionNoneZ CommitmentTransaction_verify(const struct LDKCommitmentTransaction *NONNULL_PTR this_arg, const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKChannelPublicKeys *NONNULL_PTR broadcaster_keys, const struct LDKChannelPublicKeys *NONNULL_PTR countersignatory_keys);

/**
 * Frees any resources used by the TrustedCommitmentTransaction, if is_owned is set and inner is non-NULL.
 */
void TrustedCommitmentTransaction_free(struct LDKTrustedCommitmentTransaction this_obj);

/**
 * The transaction ID of the built Bitcoin transaction
 */
MUST_USE_RES struct LDKThirtyTwoBytes TrustedCommitmentTransaction_txid(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-built Bitcoin commitment transaction
 */
MUST_USE_RES struct LDKBuiltCommitmentTransaction TrustedCommitmentTransaction_built_transaction(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * The pre-calculated transaction creation public keys.
 */
MUST_USE_RES struct LDKTxCreationKeys TrustedCommitmentTransaction_keys(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Should anchors be used.
 */
MUST_USE_RES struct LDKChannelTypeFeatures TrustedCommitmentTransaction_channel_type_features(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Get a signature for each HTLC which was included in the commitment transaction (ie for
 * which HTLCOutputInCommitment::transaction_output_index.is_some()).
 *
 * The returned Vec has one entry for each HTLC, and in the same order.
 *
 * This function is only valid in the holder commitment context, it always uses EcdsaSighashType::All.
 */
MUST_USE_RES struct LDKCResult_CVec_ECDSASignatureZNoneZ TrustedCommitmentTransaction_get_htlc_sigs(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, const uint8_t (*htlc_base_key)[32], const struct LDKDirectedChannelTransactionParameters *NONNULL_PTR channel_parameters, const struct LDKEntropySource *NONNULL_PTR entropy_source);

/**
 * Returns the index of the revokeable output, i.e. the `to_local` output sending funds to
 * the broadcaster, in the built transaction, if any exists.
 *
 * There are two cases where this may return `None`:
 * - The balance of the revokeable output is below the dust limit (only found on commitments
 * early in the channel's lifetime, i.e. before the channel reserve is met).
 * - This commitment was created before LDK 0.0.117. In this case, the
 * commitment transaction previously didn't contain enough information to locate the
 * revokeable output.
 */
MUST_USE_RES struct LDKCOption_usizeZ TrustedCommitmentTransaction_revokeable_output_index(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg);

/**
 * Helper method to build an unsigned justice transaction spending the revokeable
 * `to_local` output to a destination script. Fee estimation accounts for the expected
 * revocation witness data that will be added when signed.
 *
 * This method will error if the given fee rate results in a fee greater than the value
 * of the output being spent, or if there exists no revokeable `to_local` output on this
 * commitment transaction. See [`Self::revokeable_output_index`] for more details.
 *
 * The built transaction will allow fee bumping with RBF, and this method takes
 * `feerate_per_kw` as an input such that multiple copies of a justice transaction at different
 * fee rates may be built.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ TrustedCommitmentTransaction_build_to_local_justice_tx(const struct LDKTrustedCommitmentTransaction *NONNULL_PTR this_arg, uint64_t feerate_per_kw, struct LDKCVec_u8Z destination_script);

/**
 * Commitment transaction numbers which appear in the transactions themselves are XOR'd with a
 * shared secret first. This prevents on-chain observers from discovering how many commitment
 * transactions occurred in a channel before it was closed.
 *
 * This function gets the shared secret from relevant channel public keys and can be used to
 * \"decrypt\" the commitment transaction number given a commitment transaction on-chain.
 */
uint64_t get_commitment_transaction_number_obscure_factor(struct LDKPublicKey broadcaster_payment_basepoint, struct LDKPublicKey countersignatory_payment_basepoint, bool outbound_from_broadcaster);

/**
 * Checks if two InitFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InitFeatures_eq(const struct LDKInitFeatures *NONNULL_PTR a, const struct LDKInitFeatures *NONNULL_PTR b);

/**
 * Checks if two NodeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeFeatures_eq(const struct LDKNodeFeatures *NONNULL_PTR a, const struct LDKNodeFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelFeatures_eq(const struct LDKChannelFeatures *NONNULL_PTR a, const struct LDKChannelFeatures *NONNULL_PTR b);

/**
 * Checks if two Bolt11InvoiceFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Bolt11InvoiceFeatures_eq(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR a, const struct LDKBolt11InvoiceFeatures *NONNULL_PTR b);

/**
 * Checks if two OfferFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool OfferFeatures_eq(const struct LDKOfferFeatures *NONNULL_PTR a, const struct LDKOfferFeatures *NONNULL_PTR b);

/**
 * Checks if two InvoiceRequestFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool InvoiceRequestFeatures_eq(const struct LDKInvoiceRequestFeatures *NONNULL_PTR a, const struct LDKInvoiceRequestFeatures *NONNULL_PTR b);

/**
 * Checks if two Bolt12InvoiceFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Bolt12InvoiceFeatures_eq(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR a, const struct LDKBolt12InvoiceFeatures *NONNULL_PTR b);

/**
 * Checks if two BlindedHopFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BlindedHopFeatures_eq(const struct LDKBlindedHopFeatures *NONNULL_PTR a, const struct LDKBlindedHopFeatures *NONNULL_PTR b);

/**
 * Checks if two ChannelTypeFeaturess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelTypeFeatures_eq(const struct LDKChannelTypeFeatures *NONNULL_PTR a, const struct LDKChannelTypeFeatures *NONNULL_PTR b);

/**
 * Creates a copy of the InitFeatures
 */
struct LDKInitFeatures InitFeatures_clone(const struct LDKInitFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the NodeFeatures
 */
struct LDKNodeFeatures NodeFeatures_clone(const struct LDKNodeFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelFeatures
 */
struct LDKChannelFeatures ChannelFeatures_clone(const struct LDKChannelFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the Bolt11InvoiceFeatures
 */
struct LDKBolt11InvoiceFeatures Bolt11InvoiceFeatures_clone(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the OfferFeatures
 */
struct LDKOfferFeatures OfferFeatures_clone(const struct LDKOfferFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the InvoiceRequestFeatures
 */
struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_clone(const struct LDKInvoiceRequestFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the Bolt12InvoiceFeatures
 */
struct LDKBolt12InvoiceFeatures Bolt12InvoiceFeatures_clone(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the BlindedHopFeatures
 */
struct LDKBlindedHopFeatures BlindedHopFeatures_clone(const struct LDKBlindedHopFeatures *NONNULL_PTR orig);

/**
 * Creates a copy of the ChannelTypeFeatures
 */
struct LDKChannelTypeFeatures ChannelTypeFeatures_clone(const struct LDKChannelTypeFeatures *NONNULL_PTR orig);

/**
 * Frees any resources used by the InitFeatures, if is_owned is set and inner is non-NULL.
 */
void InitFeatures_free(struct LDKInitFeatures this_obj);

/**
 * Frees any resources used by the NodeFeatures, if is_owned is set and inner is non-NULL.
 */
void NodeFeatures_free(struct LDKNodeFeatures this_obj);

/**
 * Frees any resources used by the ChannelFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelFeatures_free(struct LDKChannelFeatures this_obj);

/**
 * Frees any resources used by the Bolt11InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void Bolt11InvoiceFeatures_free(struct LDKBolt11InvoiceFeatures this_obj);

/**
 * Frees any resources used by the OfferFeatures, if is_owned is set and inner is non-NULL.
 */
void OfferFeatures_free(struct LDKOfferFeatures this_obj);

/**
 * Frees any resources used by the InvoiceRequestFeatures, if is_owned is set and inner is non-NULL.
 */
void InvoiceRequestFeatures_free(struct LDKInvoiceRequestFeatures this_obj);

/**
 * Frees any resources used by the Bolt12InvoiceFeatures, if is_owned is set and inner is non-NULL.
 */
void Bolt12InvoiceFeatures_free(struct LDKBolt12InvoiceFeatures this_obj);

/**
 * Frees any resources used by the BlindedHopFeatures, if is_owned is set and inner is non-NULL.
 */
void BlindedHopFeatures_free(struct LDKBlindedHopFeatures this_obj);

/**
 * Frees any resources used by the ChannelTypeFeatures, if is_owned is set and inner is non-NULL.
 */
void ChannelTypeFeatures_free(struct LDKChannelTypeFeatures this_obj);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInitFeatures InitFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool InitFeatures_requires_unknown_bits_from(const struct LDKInitFeatures *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InitFeatures_requires_unknown_bits(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_required_feature_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_optional_feature_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_required_custom_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InitFeatures_set_optional_custom_bit(struct LDKInitFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKNodeFeatures NodeFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool NodeFeatures_requires_unknown_bits_from(const struct LDKNodeFeatures *NONNULL_PTR this_arg, const struct LDKNodeFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool NodeFeatures_requires_unknown_bits(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_required_feature_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_optional_feature_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_required_custom_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ NodeFeatures_set_optional_custom_bit(struct LDKNodeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelFeatures ChannelFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool ChannelFeatures_requires_unknown_bits_from(const struct LDKChannelFeatures *NONNULL_PTR this_arg, const struct LDKChannelFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelFeatures_requires_unknown_bits(const struct LDKChannelFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_required_feature_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_optional_feature_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_required_custom_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelFeatures_set_optional_custom_bit(struct LDKChannelFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKBolt11InvoiceFeatures Bolt11InvoiceFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_unknown_bits_from(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, const struct LDKBolt11InvoiceFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_unknown_bits(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_required_feature_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_optional_feature_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_required_custom_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt11InvoiceFeatures_set_optional_custom_bit(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKOfferFeatures OfferFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool OfferFeatures_requires_unknown_bits_from(const struct LDKOfferFeatures *NONNULL_PTR this_arg, const struct LDKOfferFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool OfferFeatures_requires_unknown_bits(const struct LDKOfferFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_required_feature_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_optional_feature_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_required_custom_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ OfferFeatures_set_optional_custom_bit(struct LDKOfferFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures InvoiceRequestFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool InvoiceRequestFeatures_requires_unknown_bits_from(const struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, const struct LDKInvoiceRequestFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool InvoiceRequestFeatures_requires_unknown_bits(const struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_required_feature_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_optional_feature_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_required_custom_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ InvoiceRequestFeatures_set_optional_custom_bit(struct LDKInvoiceRequestFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKBolt12InvoiceFeatures Bolt12InvoiceFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool Bolt12InvoiceFeatures_requires_unknown_bits_from(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, const struct LDKBolt12InvoiceFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool Bolt12InvoiceFeatures_requires_unknown_bits(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_required_feature_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_optional_feature_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_required_custom_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ Bolt12InvoiceFeatures_set_optional_custom_bit(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKBlindedHopFeatures BlindedHopFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool BlindedHopFeatures_requires_unknown_bits_from(const struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, const struct LDKBlindedHopFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool BlindedHopFeatures_requires_unknown_bits(const struct LDKBlindedHopFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_required_feature_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_optional_feature_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_required_custom_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ BlindedHopFeatures_set_optional_custom_bit(struct LDKBlindedHopFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Create a blank Features with no features set
 */
MUST_USE_RES struct LDKChannelTypeFeatures ChannelTypeFeatures_empty(void);

/**
 * Returns true if this `Features` object contains required features unknown by `other`.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits_from(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, const struct LDKChannelTypeFeatures *NONNULL_PTR other);

/**
 * Returns true if this `Features` object contains unknown feature flags which are set as
 * \"required\".
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_unknown_bits(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Sets a required feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_required_feature_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional feature bit. Errors if `bit` is outside the feature range as defined
 * by [BOLT 9].
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [BOLT 9]: https://github.com/lightning/bolts/blob/master/09-features.md
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_optional_feature_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets a required custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Required bits are even. If an odd bit is given, then the corresponding even bit will
 * be set instead (i.e., `bit - 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_required_custom_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Sets an optional custom feature bit. Errors if `bit` is outside the custom range as defined
 * by [bLIP 2] or if it is a known `T` feature.
 *
 * Note: Optional bits are odd. If an even bit is given, then the corresponding odd bit will be
 * set instead (i.e., `bit + 1`).
 *
 * [bLIP 2]: https://github.com/lightning/blips/blob/master/blip-0002.md#feature-bits
 */
MUST_USE_RES struct LDKCResult_NoneNoneZ ChannelTypeFeatures_set_optional_custom_bit(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg, uintptr_t bit);

/**
 * Serialize the InitFeatures object into a byte array which can be read by InitFeatures_read
 */
struct LDKCVec_u8Z InitFeatures_write(const struct LDKInitFeatures *NONNULL_PTR obj);

/**
 * Read a InitFeatures from a byte array, created by InitFeatures_write
 */
struct LDKCResult_InitFeaturesDecodeErrorZ InitFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelFeatures object into a byte array which can be read by ChannelFeatures_read
 */
struct LDKCVec_u8Z ChannelFeatures_write(const struct LDKChannelFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelFeatures from a byte array, created by ChannelFeatures_write
 */
struct LDKCResult_ChannelFeaturesDecodeErrorZ ChannelFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the NodeFeatures object into a byte array which can be read by NodeFeatures_read
 */
struct LDKCVec_u8Z NodeFeatures_write(const struct LDKNodeFeatures *NONNULL_PTR obj);

/**
 * Read a NodeFeatures from a byte array, created by NodeFeatures_write
 */
struct LDKCResult_NodeFeaturesDecodeErrorZ NodeFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the Bolt11InvoiceFeatures object into a byte array which can be read by Bolt11InvoiceFeatures_read
 */
struct LDKCVec_u8Z Bolt11InvoiceFeatures_write(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a Bolt11InvoiceFeatures from a byte array, created by Bolt11InvoiceFeatures_write
 */
struct LDKCResult_Bolt11InvoiceFeaturesDecodeErrorZ Bolt11InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the Bolt12InvoiceFeatures object into a byte array which can be read by Bolt12InvoiceFeatures_read
 */
struct LDKCVec_u8Z Bolt12InvoiceFeatures_write(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR obj);

/**
 * Read a Bolt12InvoiceFeatures from a byte array, created by Bolt12InvoiceFeatures_write
 */
struct LDKCResult_Bolt12InvoiceFeaturesDecodeErrorZ Bolt12InvoiceFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the BlindedHopFeatures object into a byte array which can be read by BlindedHopFeatures_read
 */
struct LDKCVec_u8Z BlindedHopFeatures_write(const struct LDKBlindedHopFeatures *NONNULL_PTR obj);

/**
 * Read a BlindedHopFeatures from a byte array, created by BlindedHopFeatures_write
 */
struct LDKCResult_BlindedHopFeaturesDecodeErrorZ BlindedHopFeatures_read(struct LDKu8slice ser);

/**
 * Serialize the ChannelTypeFeatures object into a byte array which can be read by ChannelTypeFeatures_read
 */
struct LDKCVec_u8Z ChannelTypeFeatures_write(const struct LDKChannelTypeFeatures *NONNULL_PTR obj);

/**
 * Read a ChannelTypeFeatures from a byte array, created by ChannelTypeFeatures_write
 */
struct LDKCResult_ChannelTypeFeaturesDecodeErrorZ ChannelTypeFeatures_read(struct LDKu8slice ser);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_data_loss_protect_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_data_loss_protect_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_data_loss_protect_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_data_loss_protect_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_data_loss_protect(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_data_loss_protect(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_initial_routing_sync_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_initial_routing_sync_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_initial_routing_sync(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_upfront_shutdown_script_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_upfront_shutdown_script_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_upfront_shutdown_script_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_upfront_shutdown_script_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_upfront_shutdown_script(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_upfront_shutdown_script(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_gossip_queries_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_gossip_queries_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_gossip_queries_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_gossip_queries_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_gossip_queries(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_gossip_queries(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_variable_length_onion_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_variable_length_onion_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_variable_length_onion_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_variable_length_onion_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void Bolt11InvoiceFeatures_set_variable_length_onion_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void Bolt11InvoiceFeatures_set_variable_length_onion_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_supports_variable_length_onion(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_variable_length_onion(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_variable_length_onion(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_variable_length_onion(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_static_remote_key_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_static_remote_key_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_static_remote_key_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_static_remote_key_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_static_remote_key_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_static_remote_key_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_static_remote_key(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_static_remote_key(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_static_remote_key(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_payment_secret_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_payment_secret_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_payment_secret_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_payment_secret_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void Bolt11InvoiceFeatures_set_payment_secret_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void Bolt11InvoiceFeatures_set_payment_secret_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_supports_payment_secret(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_payment_secret(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_payment_secret(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_payment_secret(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_basic_mpp_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_basic_mpp_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_basic_mpp_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_basic_mpp_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void Bolt11InvoiceFeatures_set_basic_mpp_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void Bolt11InvoiceFeatures_set_basic_mpp_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_supports_basic_mpp(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void Bolt12InvoiceFeatures_set_basic_mpp_optional(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void Bolt12InvoiceFeatures_set_basic_mpp_required(struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool Bolt12InvoiceFeatures_supports_basic_mpp(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_basic_mpp(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_basic_mpp(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_basic_mpp(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool Bolt12InvoiceFeatures_requires_basic_mpp(const struct LDKBolt12InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_wumbo_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_wumbo_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_wumbo_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_wumbo_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_wumbo(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_wumbo(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_anchors_nonzero_fee_htlc_tx_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_anchors_nonzero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_anchors_nonzero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_anchors_zero_fee_htlc_tx_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_anchors_zero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_anchors_zero_fee_htlc_tx(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_shutdown_any_segwit_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_shutdown_any_segwit_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_shutdown_any_segwit_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_shutdown_any_segwit_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_shutdown_anysegwit(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_shutdown_anysegwit(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_taproot_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_taproot_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_taproot(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_taproot_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_taproot_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_taproot(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_taproot_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_taproot_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_taproot(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_taproot(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_taproot(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_taproot(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_onion_messages_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_onion_messages_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_onion_messages_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_onion_messages_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_onion_messages(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_onion_messages(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_channel_type_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_channel_type_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_channel_type_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_channel_type_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_channel_type(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_channel_type(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_scid_privacy_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_scid_privacy_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_scid_privacy_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_scid_privacy_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_scid_privacy_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_scid_privacy_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_scid_privacy(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_scid_privacy(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_scid_privacy(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void Bolt11InvoiceFeatures_set_payment_metadata_optional(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void Bolt11InvoiceFeatures_set_payment_metadata_required(struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_supports_payment_metadata(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool Bolt11InvoiceFeatures_requires_payment_metadata(const struct LDKBolt11InvoiceFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void InitFeatures_set_zero_conf_optional(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void InitFeatures_set_zero_conf_required(struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool InitFeatures_supports_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_zero_conf_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_zero_conf_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void ChannelTypeFeatures_set_zero_conf_optional(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void ChannelTypeFeatures_set_zero_conf_required(struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool ChannelTypeFeatures_supports_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool InitFeatures_requires_zero_conf(const struct LDKInitFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_zero_conf(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool ChannelTypeFeatures_requires_zero_conf(const struct LDKChannelTypeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as optional.
 */
void NodeFeatures_set_keysend_optional(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Set this feature as required.
 */
void NodeFeatures_set_keysend_required(struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is supported.
 */
MUST_USE_RES bool NodeFeatures_supports_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Checks if this feature is required.
 */
MUST_USE_RES bool NodeFeatures_requires_keysend(const struct LDKNodeFeatures *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ShutdownScript, if is_owned is set and inner is non-NULL.
 */
void ShutdownScript_free(struct LDKShutdownScript this_obj);

/**
 * Creates a copy of the ShutdownScript
 */
struct LDKShutdownScript ShutdownScript_clone(const struct LDKShutdownScript *NONNULL_PTR orig);

/**
 * Checks if two ShutdownScripts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ShutdownScript_eq(const struct LDKShutdownScript *NONNULL_PTR a, const struct LDKShutdownScript *NONNULL_PTR b);

/**
 * Frees any resources used by the InvalidShutdownScript, if is_owned is set and inner is non-NULL.
 */
void InvalidShutdownScript_free(struct LDKInvalidShutdownScript this_obj);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
struct LDKu8slice InvalidShutdownScript_get_script(const struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr);

/**
 * The script that did not meet the requirements from [BOLT #2].
 *
 * [BOLT #2]: https://github.com/lightning/bolts/blob/master/02-peer-protocol.md
 */
void InvalidShutdownScript_set_script(struct LDKInvalidShutdownScript *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new InvalidShutdownScript given each field
 */
MUST_USE_RES struct LDKInvalidShutdownScript InvalidShutdownScript_new(struct LDKCVec_u8Z script_arg);

/**
 * Creates a copy of the InvalidShutdownScript
 */
struct LDKInvalidShutdownScript InvalidShutdownScript_clone(const struct LDKInvalidShutdownScript *NONNULL_PTR orig);

/**
 * Serialize the ShutdownScript object into a byte array which can be read by ShutdownScript_read
 */
struct LDKCVec_u8Z ShutdownScript_write(const struct LDKShutdownScript *NONNULL_PTR obj);

/**
 * Read a ShutdownScript from a byte array, created by ShutdownScript_write
 */
struct LDKCResult_ShutdownScriptDecodeErrorZ ShutdownScript_read(struct LDKu8slice ser);

/**
 * Generates a P2WPKH script pubkey from the given [`WPubkeyHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wpkh(const uint8_t (*pubkey_hash)[20]);

/**
 * Generates a P2WSH script pubkey from the given [`WScriptHash`].
 */
MUST_USE_RES struct LDKShutdownScript ShutdownScript_new_p2wsh(const uint8_t (*script_hash)[32]);

/**
 * Generates a witness script pubkey from the given segwit version and program.
 *
 * Note for version-zero witness scripts you must use [`ShutdownScript::new_p2wpkh`] or
 * [`ShutdownScript::new_p2wsh`] instead.
 *
 * # Errors
 *
 * This function may return an error if `program` is invalid for the segwit `version`.
 */
MUST_USE_RES struct LDKCResult_ShutdownScriptInvalidShutdownScriptZ ShutdownScript_new_witness_program(struct LDKWitnessVersion version, struct LDKu8slice program);

/**
 * Converts the shutdown script into the underlying [`Script`].
 */
MUST_USE_RES struct LDKCVec_u8Z ShutdownScript_into_inner(struct LDKShutdownScript this_arg);

/**
 * Returns the [`PublicKey`] used for a P2WPKH shutdown script if constructed directly from it.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey ShutdownScript_as_legacy_pubkey(const struct LDKShutdownScript *NONNULL_PTR this_arg);

/**
 * Returns whether the shutdown script is compatible with the features as defined by BOLT #2.
 *
 * Specifically, checks for compliance with feature `option_shutdown_anysegwit`.
 */
MUST_USE_RES bool ShutdownScript_is_compatible(const struct LDKShutdownScript *NONNULL_PTR this_arg, const struct LDKInitFeatures *NONNULL_PTR features);

/**
 * Frees any resources used by the Retry
 */
void Retry_free(struct LDKRetry this_ptr);

/**
 * Creates a copy of the Retry
 */
struct LDKRetry Retry_clone(const struct LDKRetry *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Attempts-variant Retry
 */
struct LDKRetry Retry_attempts(uint32_t a);

/**
 * Utility method to constructs a new Timeout-variant Retry
 */
struct LDKRetry Retry_timeout(uint64_t a);

/**
 * Checks if two Retrys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Retry_eq(const struct LDKRetry *NONNULL_PTR a, const struct LDKRetry *NONNULL_PTR b);

/**
 * Generates a non-cryptographic 64-bit hash of the Retry.
 */
uint64_t Retry_hash(const struct LDKRetry *NONNULL_PTR o);

/**
 * Serialize the Retry object into a byte array which can be read by Retry_read
 */
struct LDKCVec_u8Z Retry_write(const struct LDKRetry *NONNULL_PTR obj);

/**
 * Read a Retry from a byte array, created by Retry_write
 */
struct LDKCResult_RetryDecodeErrorZ Retry_read(struct LDKu8slice ser);

/**
 * Creates a copy of the RetryableSendFailure
 */
enum LDKRetryableSendFailure RetryableSendFailure_clone(const enum LDKRetryableSendFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new PaymentExpired-variant RetryableSendFailure
 */
enum LDKRetryableSendFailure RetryableSendFailure_payment_expired(void);

/**
 * Utility method to constructs a new RouteNotFound-variant RetryableSendFailure
 */
enum LDKRetryableSendFailure RetryableSendFailure_route_not_found(void);

/**
 * Utility method to constructs a new DuplicatePayment-variant RetryableSendFailure
 */
enum LDKRetryableSendFailure RetryableSendFailure_duplicate_payment(void);

/**
 * Checks if two RetryableSendFailures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool RetryableSendFailure_eq(const enum LDKRetryableSendFailure *NONNULL_PTR a, const enum LDKRetryableSendFailure *NONNULL_PTR b);

/**
 * Frees any resources used by the PaymentSendFailure
 */
void PaymentSendFailure_free(struct LDKPaymentSendFailure this_ptr);

/**
 * Creates a copy of the PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_clone(const struct LDKPaymentSendFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_parameter_error(struct LDKAPIError a);

/**
 * Utility method to constructs a new PathParameterError-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_path_parameter_error(struct LDKCVec_CResult_NoneAPIErrorZZ a);

/**
 * Utility method to constructs a new AllFailedResendSafe-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_all_failed_resend_safe(struct LDKCVec_APIErrorZ a);

/**
 * Utility method to constructs a new DuplicatePayment-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_duplicate_payment(void);

/**
 * Utility method to constructs a new PartialFailure-variant PaymentSendFailure
 */
struct LDKPaymentSendFailure PaymentSendFailure_partial_failure(struct LDKCVec_CResult_NoneAPIErrorZZ results, struct LDKRouteParameters failed_paths_retry, struct LDKThirtyTwoBytes payment_id);

/**
 * Checks if two PaymentSendFailures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool PaymentSendFailure_eq(const struct LDKPaymentSendFailure *NONNULL_PTR a, const struct LDKPaymentSendFailure *NONNULL_PTR b);

/**
 * Frees any resources used by the ProbeSendFailure
 */
void ProbeSendFailure_free(struct LDKProbeSendFailure this_ptr);

/**
 * Creates a copy of the ProbeSendFailure
 */
struct LDKProbeSendFailure ProbeSendFailure_clone(const struct LDKProbeSendFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new RouteNotFound-variant ProbeSendFailure
 */
struct LDKProbeSendFailure ProbeSendFailure_route_not_found(void);

/**
 * Utility method to constructs a new SendingFailed-variant ProbeSendFailure
 */
struct LDKProbeSendFailure ProbeSendFailure_sending_failed(struct LDKPaymentSendFailure a);

/**
 * Checks if two ProbeSendFailures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ProbeSendFailure_eq(const struct LDKProbeSendFailure *NONNULL_PTR a, const struct LDKProbeSendFailure *NONNULL_PTR b);

/**
 * Frees any resources used by the RecipientOnionFields, if is_owned is set and inner is non-NULL.
 */
void RecipientOnionFields_free(struct LDKRecipientOnionFields this_obj);

/**
 * The [`PaymentSecret`] is an arbitrary 32 bytes provided by the recipient for us to repeat
 * in the onion. It is unrelated to `payment_hash` (or [`PaymentPreimage`]) and exists to
 * authenticate the sender to the recipient and prevent payment-probing (deanonymization)
 * attacks.
 *
 * If you do not have one, the [`Route`] you pay over must not contain multiple paths as
 * multi-path payments require a recipient-provided secret.
 *
 * Some implementations may reject spontaneous payments with payment secrets, so you may only
 * want to provide a secret for a spontaneous payment if MPP is needed and you know your
 * recipient will not reject it.
 */
struct LDKCOption_ThirtyTwoBytesZ RecipientOnionFields_get_payment_secret(const struct LDKRecipientOnionFields *NONNULL_PTR this_ptr);

/**
 * The [`PaymentSecret`] is an arbitrary 32 bytes provided by the recipient for us to repeat
 * in the onion. It is unrelated to `payment_hash` (or [`PaymentPreimage`]) and exists to
 * authenticate the sender to the recipient and prevent payment-probing (deanonymization)
 * attacks.
 *
 * If you do not have one, the [`Route`] you pay over must not contain multiple paths as
 * multi-path payments require a recipient-provided secret.
 *
 * Some implementations may reject spontaneous payments with payment secrets, so you may only
 * want to provide a secret for a spontaneous payment if MPP is needed and you know your
 * recipient will not reject it.
 */
void RecipientOnionFields_set_payment_secret(struct LDKRecipientOnionFields *NONNULL_PTR this_ptr, struct LDKCOption_ThirtyTwoBytesZ val);

/**
 * The payment metadata serves a similar purpose as [`Self::payment_secret`] but is of
 * arbitrary length. This gives recipients substantially more flexibility to receive
 * additional data.
 *
 * In LDK, while the [`Self::payment_secret`] is fixed based on an internal authentication
 * scheme to authenticate received payments against expected payments and invoices, this field
 * is not used in LDK for received payments, and can be used to store arbitrary data in
 * invoices which will be received with the payment.
 *
 * Note that this field was added to the lightning specification more recently than
 * [`Self::payment_secret`] and while nearly all lightning senders support secrets, metadata
 * may not be supported as universally.
 *
 * Returns a copy of the field.
 */
struct LDKCOption_CVec_u8ZZ RecipientOnionFields_get_payment_metadata(const struct LDKRecipientOnionFields *NONNULL_PTR this_ptr);

/**
 * The payment metadata serves a similar purpose as [`Self::payment_secret`] but is of
 * arbitrary length. This gives recipients substantially more flexibility to receive
 * additional data.
 *
 * In LDK, while the [`Self::payment_secret`] is fixed based on an internal authentication
 * scheme to authenticate received payments against expected payments and invoices, this field
 * is not used in LDK for received payments, and can be used to store arbitrary data in
 * invoices which will be received with the payment.
 *
 * Note that this field was added to the lightning specification more recently than
 * [`Self::payment_secret`] and while nearly all lightning senders support secrets, metadata
 * may not be supported as universally.
 */
void RecipientOnionFields_set_payment_metadata(struct LDKRecipientOnionFields *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * Creates a copy of the RecipientOnionFields
 */
struct LDKRecipientOnionFields RecipientOnionFields_clone(const struct LDKRecipientOnionFields *NONNULL_PTR orig);

/**
 * Checks if two RecipientOnionFieldss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RecipientOnionFields_eq(const struct LDKRecipientOnionFields *NONNULL_PTR a, const struct LDKRecipientOnionFields *NONNULL_PTR b);

/**
 * Serialize the RecipientOnionFields object into a byte array which can be read by RecipientOnionFields_read
 */
struct LDKCVec_u8Z RecipientOnionFields_write(const struct LDKRecipientOnionFields *NONNULL_PTR obj);

/**
 * Read a RecipientOnionFields from a byte array, created by RecipientOnionFields_write
 */
struct LDKCResult_RecipientOnionFieldsDecodeErrorZ RecipientOnionFields_read(struct LDKu8slice ser);

/**
 * Creates a [`RecipientOnionFields`] from only a [`PaymentSecret`]. This is the most common
 * set of onion fields for today's BOLT11 invoices - most nodes require a [`PaymentSecret`]
 * but do not require or provide any further data.
 */
MUST_USE_RES struct LDKRecipientOnionFields RecipientOnionFields_secret_only(struct LDKThirtyTwoBytes payment_secret);

/**
 * Creates a new [`RecipientOnionFields`] with no fields. This generally does not create
 * payable HTLCs except for single-path spontaneous payments, i.e. this should generally
 * only be used for calls to [`ChannelManager::send_spontaneous_payment`]. If you are sending
 * a spontaneous MPP this will not work as all MPP require payment secrets; you may
 * instead want to use [`RecipientOnionFields::secret_only`].
 *
 * [`ChannelManager::send_spontaneous_payment`]: super::channelmanager::ChannelManager::send_spontaneous_payment
 * [`RecipientOnionFields::secret_only`]: RecipientOnionFields::secret_only
 */
MUST_USE_RES struct LDKRecipientOnionFields RecipientOnionFields_spontaneous_empty(void);

/**
 * Creates a new [`RecipientOnionFields`] from an existing one, adding custom TLVs. Each
 * TLV is provided as a `(u64, Vec<u8>)` for the type number and serialized value
 * respectively. TLV type numbers must be unique and within the range
 * reserved for custom types, i.e. >= 2^16, otherwise this method will return `Err(())`.
 *
 * This method will also error for types in the experimental range which have been
 * standardized within the protocol, which only includes 5482373484 (keysend) for now.
 *
 * See [`Self::custom_tlvs`] for more info.
 */
MUST_USE_RES struct LDKCResult_RecipientOnionFieldsNoneZ RecipientOnionFields_with_custom_tlvs(struct LDKRecipientOnionFields this_arg, struct LDKCVec_C2Tuple_u64CVec_u8ZZZ custom_tlvs);

/**
 * Gets the custom TLVs that will be sent or have been received.
 *
 * Custom TLVs allow sending extra application-specific data with a payment. They provide
 * additional flexibility on top of payment metadata, as while other implementations may
 * require `payment_metadata` to reflect metadata provided in an invoice, custom TLVs
 * do not have this restriction.
 *
 * Note that if this field is non-empty, it will contain strictly increasing TLVs, each
 * represented by a `(u64, Vec<u8>)` for its type number and serialized value respectively.
 * This is validated when setting this field using [`Self::with_custom_tlvs`].
 */
MUST_USE_RES struct LDKCVec_C2Tuple_u64CVec_u8ZZZ RecipientOnionFields_custom_tlvs(const struct LDKRecipientOnionFields *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void CustomMessageReader_free(struct LDKCustomMessageReader this_ptr);

/**
 * Creates a copy of a Type
 */
struct LDKType Type_clone(const struct LDKType *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void Type_free(struct LDKType this_ptr);

/**
 * Frees any resources used by the Offer, if is_owned is set and inner is non-NULL.
 */
void Offer_free(struct LDKOffer this_obj);

/**
 * Creates a copy of the Offer
 */
struct LDKOffer Offer_clone(const struct LDKOffer *NONNULL_PTR orig);

/**
 * The chains that may be used when paying a requested invoice (e.g., bitcoin mainnet).
 * Payments must be denominated in units of the minimal lightning-payable unit (e.g., msats)
 * for the selected chain.
 */
MUST_USE_RES struct LDKCVec_ThirtyTwoBytesZ Offer_chains(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originator. Useful for authentication and validating fields since it
 * is reflected in `invoice_request` messages along with all the other fields from the `offer`.
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ Offer_metadata(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount Offer_amount(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the payment. Intended to be displayed to the user
 * but with the caveat that it has not been verified in any way.
 */
MUST_USE_RES struct LDKPrintableString Offer_description(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Features pertaining to the offer.
 */
MUST_USE_RES struct LDKOfferFeatures Offer_offer_features(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * If `None`, the offer does not expire.
 */
MUST_USE_RES struct LDKCOption_u64Z Offer_absolute_expiry(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * The issuer of the offer, possibly beginning with `user@domain` or `domain`. Intended to be
 * displayed to the user but with the caveat that it has not been verified in any way.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString Offer_issuer(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes. Blinded paths provide
 * recipient privacy by obfuscating its node id.
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ Offer_paths(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 */
MUST_USE_RES struct LDKQuantity Offer_supported_quantity(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * The public key used by the recipient to sign invoices.
 */
MUST_USE_RES struct LDKPublicKey Offer_signing_pubkey(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Returns whether the given chain is supported by the offer.
 */
MUST_USE_RES bool Offer_supports_chain(const struct LDKOffer *NONNULL_PTR this_arg, struct LDKThirtyTwoBytes chain);

/**
 * Whether the offer has expired.
 */
MUST_USE_RES bool Offer_is_expired(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Returns whether the given quantity is valid for the offer.
 */
MUST_USE_RES bool Offer_is_valid_quantity(const struct LDKOffer *NONNULL_PTR this_arg, uint64_t quantity);

/**
 * Returns whether a quantity is expected in an [`InvoiceRequest`] for the offer.
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 */
MUST_USE_RES bool Offer_expects_quantity(const struct LDKOffer *NONNULL_PTR this_arg);

/**
 * Serialize the Offer object into a byte array which can be read by Offer_read
 */
struct LDKCVec_u8Z Offer_write(const struct LDKOffer *NONNULL_PTR obj);

/**
 * Frees any resources used by the Amount, if is_owned is set and inner is non-NULL.
 */
void Amount_free(struct LDKAmount this_obj);

/**
 * Creates a copy of the Amount
 */
struct LDKAmount Amount_clone(const struct LDKAmount *NONNULL_PTR orig);

/**
 * Frees any resources used by the Quantity, if is_owned is set and inner is non-NULL.
 */
void Quantity_free(struct LDKQuantity this_obj);

/**
 * Creates a copy of the Quantity
 */
struct LDKQuantity Quantity_clone(const struct LDKQuantity *NONNULL_PTR orig);

/**
 * Read a Offer object from a string
 */
struct LDKCResult_OfferBolt12ParseErrorZ Offer_from_str(struct LDKStr s);

/**
 * Frees any resources used by the UnsignedBolt12Invoice, if is_owned is set and inner is non-NULL.
 */
void UnsignedBolt12Invoice_free(struct LDKUnsignedBolt12Invoice this_obj);

/**
 * Returns the [`TaggedHash`] of the invoice to sign.
 */
MUST_USE_RES struct LDKTaggedHash UnsignedBolt12Invoice_tagged_hash(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the Bolt12Invoice, if is_owned is set and inner is non-NULL.
 */
void Bolt12Invoice_free(struct LDKBolt12Invoice this_obj);

/**
 * Creates a copy of the Bolt12Invoice
 */
struct LDKBolt12Invoice Bolt12Invoice_clone(const struct LDKBolt12Invoice *NONNULL_PTR orig);

/**
 * The chains that may be used when paying a requested invoice.
 *
 * From [`Offer::chains`]; `None` if the invoice was created in response to a [`Refund`].
 *
 * [`Offer::chains`]: crate::offers::offer::Offer::chains
 */
MUST_USE_RES struct LDKCOption_CVec_ThirtyTwoBytesZZ UnsignedBolt12Invoice_offer_chains(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The chain that must be used when paying the invoice; selected from [`offer_chains`] if the
 * invoice originated from an offer.
 *
 * From [`InvoiceRequest::chain`] or [`Refund::chain`].
 *
 * [`offer_chains`]: Self::offer_chains
 * [`InvoiceRequest::chain`]: crate::offers::invoice_request::InvoiceRequest::chain
 */
MUST_USE_RES struct LDKThirtyTwoBytes UnsignedBolt12Invoice_chain(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originating [`Offer`].
 *
 * From [`Offer::metadata`]; `None` if the invoice was created in response to a [`Refund`] or
 * if the [`Offer`] did not set it.
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::metadata`]: crate::offers::offer::Offer::metadata
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ UnsignedBolt12Invoice_metadata(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * From [`Offer::amount`]; `None` if the invoice was created in response to a [`Refund`] or if
 * the [`Offer`] did not set it.
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::amount`]: crate::offers::offer::Offer::amount
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount UnsignedBolt12Invoice_amount(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to the originating [`Offer`].
 *
 * From [`Offer::offer_features`]; `None` if the invoice was created in response to a
 * [`Refund`].
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::offer_features`]: crate::offers::offer::Offer::offer_features
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKOfferFeatures UnsignedBolt12Invoice_offer_features(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the originating offer or refund.
 *
 * From [`Offer::description`] or [`Refund::description`].
 *
 * [`Offer::description`]: crate::offers::offer::Offer::description
 */
MUST_USE_RES struct LDKPrintableString UnsignedBolt12Invoice_description(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * From [`Offer::absolute_expiry`] or [`Refund::absolute_expiry`].
 *
 * [`Offer::absolute_expiry`]: crate::offers::offer::Offer::absolute_expiry
 */
MUST_USE_RES struct LDKCOption_u64Z UnsignedBolt12Invoice_absolute_expiry(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The issuer of the offer or refund.
 *
 * From [`Offer::issuer`] or [`Refund::issuer`].
 *
 * [`Offer::issuer`]: crate::offers::offer::Offer::issuer
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString UnsignedBolt12Invoice_issuer(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes.
 *
 * From [`Offer::paths`] or [`Refund::paths`].
 *
 * [`Offer::paths`]: crate::offers::offer::Offer::paths
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ UnsignedBolt12Invoice_message_paths(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 *
 * From [`Offer::supported_quantity`]; `None` if the invoice was created in response to a
 * [`Refund`].
 *
 * [`Offer::supported_quantity`]: crate::offers::offer::Offer::supported_quantity
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKQuantity UnsignedBolt12Invoice_supported_quantity(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes from the payer.
 *
 * From [`InvoiceRequest::payer_metadata`] or [`Refund::payer_metadata`].
 */
MUST_USE_RES struct LDKu8slice UnsignedBolt12Invoice_payer_metadata(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 *
 * From [`InvoiceRequest::invoice_request_features`] or [`Refund::features`].
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures UnsignedBolt12Invoice_invoice_request_features(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The quantity of items requested or refunded for.
 *
 * From [`InvoiceRequest::quantity`] or [`Refund::quantity`].
 */
MUST_USE_RES struct LDKCOption_u64Z UnsignedBolt12Invoice_quantity(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A possibly transient pubkey used to sign the invoice request or to send an invoice for a
 * refund in case there are no [`message_paths`].
 *
 * [`message_paths`]: Self::message_paths
 */
MUST_USE_RES struct LDKPublicKey UnsignedBolt12Invoice_payer_id(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A payer-provided note reflected back in the invoice.
 *
 * From [`InvoiceRequest::payer_note`] or [`Refund::payer_note`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString UnsignedBolt12Invoice_payer_note(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when the invoice was created.
 */
MUST_USE_RES uint64_t UnsignedBolt12Invoice_created_at(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since [`Bolt12Invoice::created_at`] when the invoice has expired and therefore
 * should no longer be paid.
 */
MUST_USE_RES uint64_t UnsignedBolt12Invoice_relative_expiry(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Whether the invoice has expired.
 */
MUST_USE_RES bool UnsignedBolt12Invoice_is_expired(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * SHA256 hash of the payment preimage that will be given in return for paying the invoice.
 */
MUST_USE_RES struct LDKThirtyTwoBytes UnsignedBolt12Invoice_payment_hash(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of the invoice.
 */
MUST_USE_RES uint64_t UnsignedBolt12Invoice_amount_msats(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to paying an invoice.
 */
MUST_USE_RES struct LDKBolt12InvoiceFeatures UnsignedBolt12Invoice_invoice_features(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The public key corresponding to the key used to sign the invoice.
 */
MUST_USE_RES struct LDKPublicKey UnsignedBolt12Invoice_signing_pubkey(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The chains that may be used when paying a requested invoice.
 *
 * From [`Offer::chains`]; `None` if the invoice was created in response to a [`Refund`].
 *
 * [`Offer::chains`]: crate::offers::offer::Offer::chains
 */
MUST_USE_RES struct LDKCOption_CVec_ThirtyTwoBytesZZ Bolt12Invoice_offer_chains(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The chain that must be used when paying the invoice; selected from [`offer_chains`] if the
 * invoice originated from an offer.
 *
 * From [`InvoiceRequest::chain`] or [`Refund::chain`].
 *
 * [`offer_chains`]: Self::offer_chains
 * [`InvoiceRequest::chain`]: crate::offers::invoice_request::InvoiceRequest::chain
 */
MUST_USE_RES struct LDKThirtyTwoBytes Bolt12Invoice_chain(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originating [`Offer`].
 *
 * From [`Offer::metadata`]; `None` if the invoice was created in response to a [`Refund`] or
 * if the [`Offer`] did not set it.
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::metadata`]: crate::offers::offer::Offer::metadata
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ Bolt12Invoice_metadata(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * From [`Offer::amount`]; `None` if the invoice was created in response to a [`Refund`] or if
 * the [`Offer`] did not set it.
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::amount`]: crate::offers::offer::Offer::amount
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount Bolt12Invoice_amount(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to the originating [`Offer`].
 *
 * From [`Offer::offer_features`]; `None` if the invoice was created in response to a
 * [`Refund`].
 *
 * [`Offer`]: crate::offers::offer::Offer
 * [`Offer::offer_features`]: crate::offers::offer::Offer::offer_features
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKOfferFeatures Bolt12Invoice_offer_features(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the originating offer or refund.
 *
 * From [`Offer::description`] or [`Refund::description`].
 *
 * [`Offer::description`]: crate::offers::offer::Offer::description
 */
MUST_USE_RES struct LDKPrintableString Bolt12Invoice_description(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * From [`Offer::absolute_expiry`] or [`Refund::absolute_expiry`].
 *
 * [`Offer::absolute_expiry`]: crate::offers::offer::Offer::absolute_expiry
 */
MUST_USE_RES struct LDKCOption_u64Z Bolt12Invoice_absolute_expiry(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The issuer of the offer or refund.
 *
 * From [`Offer::issuer`] or [`Refund::issuer`].
 *
 * [`Offer::issuer`]: crate::offers::offer::Offer::issuer
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString Bolt12Invoice_issuer(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes.
 *
 * From [`Offer::paths`] or [`Refund::paths`].
 *
 * [`Offer::paths`]: crate::offers::offer::Offer::paths
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ Bolt12Invoice_message_paths(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 *
 * From [`Offer::supported_quantity`]; `None` if the invoice was created in response to a
 * [`Refund`].
 *
 * [`Offer::supported_quantity`]: crate::offers::offer::Offer::supported_quantity
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKQuantity Bolt12Invoice_supported_quantity(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes from the payer.
 *
 * From [`InvoiceRequest::payer_metadata`] or [`Refund::payer_metadata`].
 */
MUST_USE_RES struct LDKu8slice Bolt12Invoice_payer_metadata(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 *
 * From [`InvoiceRequest::invoice_request_features`] or [`Refund::features`].
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures Bolt12Invoice_invoice_request_features(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The quantity of items requested or refunded for.
 *
 * From [`InvoiceRequest::quantity`] or [`Refund::quantity`].
 */
MUST_USE_RES struct LDKCOption_u64Z Bolt12Invoice_quantity(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A possibly transient pubkey used to sign the invoice request or to send an invoice for a
 * refund in case there are no [`message_paths`].
 *
 * [`message_paths`]: Self::message_paths
 */
MUST_USE_RES struct LDKPublicKey Bolt12Invoice_payer_id(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * A payer-provided note reflected back in the invoice.
 *
 * From [`InvoiceRequest::payer_note`] or [`Refund::payer_note`].
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString Bolt12Invoice_payer_note(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when the invoice was created.
 */
MUST_USE_RES uint64_t Bolt12Invoice_created_at(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Duration since [`Bolt12Invoice::created_at`] when the invoice has expired and therefore
 * should no longer be paid.
 */
MUST_USE_RES uint64_t Bolt12Invoice_relative_expiry(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Whether the invoice has expired.
 */
MUST_USE_RES bool Bolt12Invoice_is_expired(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * SHA256 hash of the payment preimage that will be given in return for paying the invoice.
 */
MUST_USE_RES struct LDKThirtyTwoBytes Bolt12Invoice_payment_hash(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of the invoice.
 */
MUST_USE_RES uint64_t Bolt12Invoice_amount_msats(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Features pertaining to paying an invoice.
 */
MUST_USE_RES struct LDKBolt12InvoiceFeatures Bolt12Invoice_invoice_features(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * The public key corresponding to the key used to sign the invoice.
 */
MUST_USE_RES struct LDKPublicKey Bolt12Invoice_signing_pubkey(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Signature of the invoice verified using [`Bolt12Invoice::signing_pubkey`].
 */
MUST_USE_RES struct LDKSchnorrSignature Bolt12Invoice_signature(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Hash that was used for signing the invoice.
 */
MUST_USE_RES struct LDKThirtyTwoBytes Bolt12Invoice_signable_hash(const struct LDKBolt12Invoice *NONNULL_PTR this_arg);

/**
 * Verifies that the invoice was for a request or refund created using the given key. Returns
 * the associated [`PaymentId`] to use when sending the payment.
 */
MUST_USE_RES struct LDKCResult_ThirtyTwoBytesNoneZ Bolt12Invoice_verify(const struct LDKBolt12Invoice *NONNULL_PTR this_arg, const struct LDKExpandedKey *NONNULL_PTR key);

/**
 * Serialize the UnsignedBolt12Invoice object into a byte array which can be read by UnsignedBolt12Invoice_read
 */
struct LDKCVec_u8Z UnsignedBolt12Invoice_write(const struct LDKUnsignedBolt12Invoice *NONNULL_PTR obj);

/**
 * Serialize the Bolt12Invoice object into a byte array which can be read by Bolt12Invoice_read
 */
struct LDKCVec_u8Z Bolt12Invoice_write(const struct LDKBolt12Invoice *NONNULL_PTR obj);

/**
 * Frees any resources used by the BlindedPayInfo, if is_owned is set and inner is non-NULL.
 */
void BlindedPayInfo_free(struct LDKBlindedPayInfo this_obj);

/**
 * Base fee charged (in millisatoshi) for the entire blinded path.
 */
uint32_t BlindedPayInfo_get_fee_base_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * Base fee charged (in millisatoshi) for the entire blinded path.
 */
void BlindedPayInfo_set_fee_base_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity fee charged (in millionths of the amount transferred) for the entire blinded path
 * (i.e., 10,000 is 1%).
 */
uint32_t BlindedPayInfo_get_fee_proportional_millionths(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * Liquidity fee charged (in millionths of the amount transferred) for the entire blinded path
 * (i.e., 10,000 is 1%).
 */
void BlindedPayInfo_set_fee_proportional_millionths(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Number of blocks subtracted from an incoming HTLC's `cltv_expiry` for the entire blinded
 * path.
 */
uint16_t BlindedPayInfo_get_cltv_expiry_delta(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * Number of blocks subtracted from an incoming HTLC's `cltv_expiry` for the entire blinded
 * path.
 */
void BlindedPayInfo_set_cltv_expiry_delta(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum HTLC value (in millisatoshi) that is acceptable to all channel peers on the
 * blinded path from the introduction node to the recipient, accounting for any fees, i.e., as
 * seen by the recipient.
 */
uint64_t BlindedPayInfo_get_htlc_minimum_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * The minimum HTLC value (in millisatoshi) that is acceptable to all channel peers on the
 * blinded path from the introduction node to the recipient, accounting for any fees, i.e., as
 * seen by the recipient.
 */
void BlindedPayInfo_set_htlc_minimum_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum HTLC value (in millisatoshi) that is acceptable to all channel peers on the
 * blinded path from the introduction node to the recipient, accounting for any fees, i.e., as
 * seen by the recipient.
 */
uint64_t BlindedPayInfo_get_htlc_maximum_msat(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * The maximum HTLC value (in millisatoshi) that is acceptable to all channel peers on the
 * blinded path from the introduction node to the recipient, accounting for any fees, i.e., as
 * seen by the recipient.
 */
void BlindedPayInfo_set_htlc_maximum_msat(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Features set in `encrypted_data_tlv` for the `encrypted_recipient_data` TLV record in an
 * onion payload.
 */
struct LDKBlindedHopFeatures BlindedPayInfo_get_features(const struct LDKBlindedPayInfo *NONNULL_PTR this_ptr);

/**
 * Features set in `encrypted_data_tlv` for the `encrypted_recipient_data` TLV record in an
 * onion payload.
 */
void BlindedPayInfo_set_features(struct LDKBlindedPayInfo *NONNULL_PTR this_ptr, struct LDKBlindedHopFeatures val);

/**
 * Constructs a new BlindedPayInfo given each field
 */
MUST_USE_RES struct LDKBlindedPayInfo BlindedPayInfo_new(uint32_t fee_base_msat_arg, uint32_t fee_proportional_millionths_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, struct LDKBlindedHopFeatures features_arg);

/**
 * Creates a copy of the BlindedPayInfo
 */
struct LDKBlindedPayInfo BlindedPayInfo_clone(const struct LDKBlindedPayInfo *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the BlindedPayInfo.
 */
uint64_t BlindedPayInfo_hash(const struct LDKBlindedPayInfo *NONNULL_PTR o);

/**
 * Checks if two BlindedPayInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BlindedPayInfo_eq(const struct LDKBlindedPayInfo *NONNULL_PTR a, const struct LDKBlindedPayInfo *NONNULL_PTR b);

/**
 * Serialize the BlindedPayInfo object into a byte array which can be read by BlindedPayInfo_read
 */
struct LDKCVec_u8Z BlindedPayInfo_write(const struct LDKBlindedPayInfo *NONNULL_PTR obj);

/**
 * Read a BlindedPayInfo from a byte array, created by BlindedPayInfo_write
 */
struct LDKCResult_BlindedPayInfoDecodeErrorZ BlindedPayInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the InvoiceError, if is_owned is set and inner is non-NULL.
 */
void InvoiceError_free(struct LDKInvoiceError this_obj);

/**
 * The field in the [`InvoiceRequest`] or the [`Bolt12Invoice`] that contained an error.
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKErroneousField InvoiceError_get_erroneous_field(const struct LDKInvoiceError *NONNULL_PTR this_ptr);

/**
 * The field in the [`InvoiceRequest`] or the [`Bolt12Invoice`] that contained an error.
 *
 * [`InvoiceRequest`]: crate::offers::invoice_request::InvoiceRequest
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void InvoiceError_set_erroneous_field(struct LDKInvoiceError *NONNULL_PTR this_ptr, struct LDKErroneousField val);

/**
 * An explanation of the error.
 */
struct LDKUntrustedString InvoiceError_get_message(const struct LDKInvoiceError *NONNULL_PTR this_ptr);

/**
 * An explanation of the error.
 */
void InvoiceError_set_message(struct LDKInvoiceError *NONNULL_PTR this_ptr, struct LDKUntrustedString val);

/**
 * Constructs a new InvoiceError given each field
 *
 * Note that erroneous_field_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKInvoiceError InvoiceError_new(struct LDKErroneousField erroneous_field_arg, struct LDKUntrustedString message_arg);

/**
 * Creates a copy of the InvoiceError
 */
struct LDKInvoiceError InvoiceError_clone(const struct LDKInvoiceError *NONNULL_PTR orig);

/**
 * Frees any resources used by the ErroneousField, if is_owned is set and inner is non-NULL.
 */
void ErroneousField_free(struct LDKErroneousField this_obj);

/**
 * The type number of the TLV field containing the error.
 */
uint64_t ErroneousField_get_tlv_fieldnum(const struct LDKErroneousField *NONNULL_PTR this_ptr);

/**
 * The type number of the TLV field containing the error.
 */
void ErroneousField_set_tlv_fieldnum(struct LDKErroneousField *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A value to use for the TLV field to avoid the error.
 *
 * Returns a copy of the field.
 */
struct LDKCOption_CVec_u8ZZ ErroneousField_get_suggested_value(const struct LDKErroneousField *NONNULL_PTR this_ptr);

/**
 * A value to use for the TLV field to avoid the error.
 */
void ErroneousField_set_suggested_value(struct LDKErroneousField *NONNULL_PTR this_ptr, struct LDKCOption_CVec_u8ZZ val);

/**
 * Constructs a new ErroneousField given each field
 */
MUST_USE_RES struct LDKErroneousField ErroneousField_new(uint64_t tlv_fieldnum_arg, struct LDKCOption_CVec_u8ZZ suggested_value_arg);

/**
 * Creates a copy of the ErroneousField
 */
struct LDKErroneousField ErroneousField_clone(const struct LDKErroneousField *NONNULL_PTR orig);

/**
 * Serialize the InvoiceError object into a byte array which can be read by InvoiceError_read
 */
struct LDKCVec_u8Z InvoiceError_write(const struct LDKInvoiceError *NONNULL_PTR obj);

/**
 * Read a InvoiceError from a byte array, created by InvoiceError_write
 */
struct LDKCResult_InvoiceErrorDecodeErrorZ InvoiceError_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the UnsignedInvoiceRequest, if is_owned is set and inner is non-NULL.
 */
void UnsignedInvoiceRequest_free(struct LDKUnsignedInvoiceRequest this_obj);

/**
 * Returns the [`TaggedHash`] of the invoice to sign.
 */
MUST_USE_RES struct LDKTaggedHash UnsignedInvoiceRequest_tagged_hash(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the InvoiceRequest, if is_owned is set and inner is non-NULL.
 */
void InvoiceRequest_free(struct LDKInvoiceRequest this_obj);

/**
 * Creates a copy of the InvoiceRequest
 */
struct LDKInvoiceRequest InvoiceRequest_clone(const struct LDKInvoiceRequest *NONNULL_PTR orig);

/**
 * Frees any resources used by the VerifiedInvoiceRequest, if is_owned is set and inner is non-NULL.
 */
void VerifiedInvoiceRequest_free(struct LDKVerifiedInvoiceRequest this_obj);

/**
 * Keys used for signing a [`Bolt12Invoice`] if they can be derived.
 *
 * If `Some`, must call [`respond_using_derived_keys`] when responding. Otherwise, call
 * [`respond_with`].
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 * [`respond_using_derived_keys`]: Self::respond_using_derived_keys
 * [`respond_with`]: Self::respond_with
 */
struct LDKCOption_SecretKeyZ VerifiedInvoiceRequest_get_keys(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_ptr);

/**
 * Keys used for signing a [`Bolt12Invoice`] if they can be derived.
 *
 * If `Some`, must call [`respond_using_derived_keys`] when responding. Otherwise, call
 * [`respond_with`].
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 * [`respond_using_derived_keys`]: Self::respond_using_derived_keys
 * [`respond_with`]: Self::respond_with
 */
void VerifiedInvoiceRequest_set_keys(struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_ptr, struct LDKCOption_SecretKeyZ val);

/**
 * Creates a copy of the VerifiedInvoiceRequest
 */
struct LDKVerifiedInvoiceRequest VerifiedInvoiceRequest_clone(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR orig);

/**
 * The chains that may be used when paying a requested invoice (e.g., bitcoin mainnet).
 * Payments must be denominated in units of the minimal lightning-payable unit (e.g., msats)
 * for the selected chain.
 */
MUST_USE_RES struct LDKCVec_ThirtyTwoBytesZ UnsignedInvoiceRequest_chains(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originator. Useful for authentication and validating fields since it
 * is reflected in `invoice_request` messages along with all the other fields from the `offer`.
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ UnsignedInvoiceRequest_metadata(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount UnsignedInvoiceRequest_amount(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the payment. Intended to be displayed to the user
 * but with the caveat that it has not been verified in any way.
 */
MUST_USE_RES struct LDKPrintableString UnsignedInvoiceRequest_description(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to the offer.
 */
MUST_USE_RES struct LDKOfferFeatures UnsignedInvoiceRequest_offer_features(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * If `None`, the offer does not expire.
 */
MUST_USE_RES struct LDKCOption_u64Z UnsignedInvoiceRequest_absolute_expiry(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The issuer of the offer, possibly beginning with `user@domain` or `domain`. Intended to be
 * displayed to the user but with the caveat that it has not been verified in any way.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString UnsignedInvoiceRequest_issuer(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes. Blinded paths provide
 * recipient privacy by obfuscating its node id.
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ UnsignedInvoiceRequest_paths(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 */
MUST_USE_RES struct LDKQuantity UnsignedInvoiceRequest_supported_quantity(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The public key used by the recipient to sign invoices.
 */
MUST_USE_RES struct LDKPublicKey UnsignedInvoiceRequest_signing_pubkey(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes, typically containing information about the derivation of
 * [`payer_id`].
 *
 * [`payer_id`]: Self::payer_id
 */
MUST_USE_RES struct LDKu8slice UnsignedInvoiceRequest_payer_metadata(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A chain from [`Offer::chains`] that the offer is valid for.
 */
MUST_USE_RES struct LDKThirtyTwoBytes UnsignedInvoiceRequest_chain(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The amount to pay in msats (i.e., the minimum lightning-payable unit for [`chain`]), which
 * must be greater than or equal to [`Offer::amount`], converted if necessary.
 *
 * [`chain`]: Self::chain
 */
MUST_USE_RES struct LDKCOption_u64Z UnsignedInvoiceRequest_amount_msats(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures UnsignedInvoiceRequest_invoice_request_features(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of the offer's item conforming to [`Offer::is_valid_quantity`].
 */
MUST_USE_RES struct LDKCOption_u64Z UnsignedInvoiceRequest_quantity(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A possibly transient pubkey used to sign the invoice request.
 */
MUST_USE_RES struct LDKPublicKey UnsignedInvoiceRequest_payer_id(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A payer-provided note which will be seen by the recipient and reflected back in the invoice
 * response.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString UnsignedInvoiceRequest_payer_note(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The chains that may be used when paying a requested invoice (e.g., bitcoin mainnet).
 * Payments must be denominated in units of the minimal lightning-payable unit (e.g., msats)
 * for the selected chain.
 */
MUST_USE_RES struct LDKCVec_ThirtyTwoBytesZ InvoiceRequest_chains(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originator. Useful for authentication and validating fields since it
 * is reflected in `invoice_request` messages along with all the other fields from the `offer`.
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ InvoiceRequest_metadata(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount InvoiceRequest_amount(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the payment. Intended to be displayed to the user
 * but with the caveat that it has not been verified in any way.
 */
MUST_USE_RES struct LDKPrintableString InvoiceRequest_description(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to the offer.
 */
MUST_USE_RES struct LDKOfferFeatures InvoiceRequest_offer_features(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * If `None`, the offer does not expire.
 */
MUST_USE_RES struct LDKCOption_u64Z InvoiceRequest_absolute_expiry(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The issuer of the offer, possibly beginning with `user@domain` or `domain`. Intended to be
 * displayed to the user but with the caveat that it has not been verified in any way.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString InvoiceRequest_issuer(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes. Blinded paths provide
 * recipient privacy by obfuscating its node id.
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ InvoiceRequest_paths(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 */
MUST_USE_RES struct LDKQuantity InvoiceRequest_supported_quantity(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The public key used by the recipient to sign invoices.
 */
MUST_USE_RES struct LDKPublicKey InvoiceRequest_signing_pubkey(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes, typically containing information about the derivation of
 * [`payer_id`].
 *
 * [`payer_id`]: Self::payer_id
 */
MUST_USE_RES struct LDKu8slice InvoiceRequest_payer_metadata(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A chain from [`Offer::chains`] that the offer is valid for.
 */
MUST_USE_RES struct LDKThirtyTwoBytes InvoiceRequest_chain(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The amount to pay in msats (i.e., the minimum lightning-payable unit for [`chain`]), which
 * must be greater than or equal to [`Offer::amount`], converted if necessary.
 *
 * [`chain`]: Self::chain
 */
MUST_USE_RES struct LDKCOption_u64Z InvoiceRequest_amount_msats(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures InvoiceRequest_invoice_request_features(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of the offer's item conforming to [`Offer::is_valid_quantity`].
 */
MUST_USE_RES struct LDKCOption_u64Z InvoiceRequest_quantity(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A possibly transient pubkey used to sign the invoice request.
 */
MUST_USE_RES struct LDKPublicKey InvoiceRequest_payer_id(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A payer-provided note which will be seen by the recipient and reflected back in the invoice
 * response.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString InvoiceRequest_payer_note(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Signature of the invoice request using [`payer_id`].
 *
 * [`payer_id`]: Self::payer_id
 */
MUST_USE_RES struct LDKSchnorrSignature InvoiceRequest_signature(const struct LDKInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Verifies that the request was for an offer created using the given key. Returns the verified
 * request which contains the derived keys needed to sign a [`Bolt12Invoice`] for the request
 * if they could be extracted from the metadata.
 *
 * [`Bolt12Invoice`]: crate::offers::invoice::Bolt12Invoice
 */
MUST_USE_RES struct LDKCResult_VerifiedInvoiceRequestNoneZ InvoiceRequest_verify(struct LDKInvoiceRequest this_arg, const struct LDKExpandedKey *NONNULL_PTR key);

/**
 * The chains that may be used when paying a requested invoice (e.g., bitcoin mainnet).
 * Payments must be denominated in units of the minimal lightning-payable unit (e.g., msats)
 * for the selected chain.
 */
MUST_USE_RES struct LDKCVec_ThirtyTwoBytesZ VerifiedInvoiceRequest_chains(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Opaque bytes set by the originator. Useful for authentication and validating fields since it
 * is reflected in `invoice_request` messages along with all the other fields from the `offer`.
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ VerifiedInvoiceRequest_metadata(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The minimum amount required for a successful payment of a single item.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKAmount VerifiedInvoiceRequest_amount(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A complete description of the purpose of the payment. Intended to be displayed to the user
 * but with the caveat that it has not been verified in any way.
 */
MUST_USE_RES struct LDKPrintableString VerifiedInvoiceRequest_description(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to the offer.
 */
MUST_USE_RES struct LDKOfferFeatures VerifiedInvoiceRequest_offer_features(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be requested.
 *
 * If `None`, the offer does not expire.
 */
MUST_USE_RES struct LDKCOption_u64Z VerifiedInvoiceRequest_absolute_expiry(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The issuer of the offer, possibly beginning with `user@domain` or `domain`. Intended to be
 * displayed to the user but with the caveat that it has not been verified in any way.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString VerifiedInvoiceRequest_issuer(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Paths to the recipient originating from publicly reachable nodes. Blinded paths provide
 * recipient privacy by obfuscating its node id.
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ VerifiedInvoiceRequest_paths(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of items supported.
 */
MUST_USE_RES struct LDKQuantity VerifiedInvoiceRequest_supported_quantity(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The public key used by the recipient to sign invoices.
 */
MUST_USE_RES struct LDKPublicKey VerifiedInvoiceRequest_signing_pubkey(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes, typically containing information about the derivation of
 * [`payer_id`].
 *
 * [`payer_id`]: Self::payer_id
 */
MUST_USE_RES struct LDKu8slice VerifiedInvoiceRequest_payer_metadata(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A chain from [`Offer::chains`] that the offer is valid for.
 */
MUST_USE_RES struct LDKThirtyTwoBytes VerifiedInvoiceRequest_chain(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The amount to pay in msats (i.e., the minimum lightning-payable unit for [`chain`]), which
 * must be greater than or equal to [`Offer::amount`], converted if necessary.
 *
 * [`chain`]: Self::chain
 */
MUST_USE_RES struct LDKCOption_u64Z VerifiedInvoiceRequest_amount_msats(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures VerifiedInvoiceRequest_invoice_request_features(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * The quantity of the offer's item conforming to [`Offer::is_valid_quantity`].
 */
MUST_USE_RES struct LDKCOption_u64Z VerifiedInvoiceRequest_quantity(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A possibly transient pubkey used to sign the invoice request.
 */
MUST_USE_RES struct LDKPublicKey VerifiedInvoiceRequest_payer_id(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * A payer-provided note which will be seen by the recipient and reflected back in the invoice
 * response.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString VerifiedInvoiceRequest_payer_note(const struct LDKVerifiedInvoiceRequest *NONNULL_PTR this_arg);

/**
 * Serialize the UnsignedInvoiceRequest object into a byte array which can be read by UnsignedInvoiceRequest_read
 */
struct LDKCVec_u8Z UnsignedInvoiceRequest_write(const struct LDKUnsignedInvoiceRequest *NONNULL_PTR obj);

/**
 * Serialize the InvoiceRequest object into a byte array which can be read by InvoiceRequest_read
 */
struct LDKCVec_u8Z InvoiceRequest_write(const struct LDKInvoiceRequest *NONNULL_PTR obj);

/**
 * Frees any resources used by the TaggedHash, if is_owned is set and inner is non-NULL.
 */
void TaggedHash_free(struct LDKTaggedHash this_obj);

/**
 * Frees any resources used by the Bolt12ParseError, if is_owned is set and inner is non-NULL.
 */
void Bolt12ParseError_free(struct LDKBolt12ParseError this_obj);

/**
 * Creates a copy of the Bolt12ParseError
 */
struct LDKBolt12ParseError Bolt12ParseError_clone(const struct LDKBolt12ParseError *NONNULL_PTR orig);

/**
 * Creates a copy of the Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_clone(const enum LDKBolt12SemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new AlreadyExpired-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_already_expired(void);

/**
 * Utility method to constructs a new UnsupportedChain-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unsupported_chain(void);

/**
 * Utility method to constructs a new UnexpectedChain-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_chain(void);

/**
 * Utility method to constructs a new MissingAmount-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_amount(void);

/**
 * Utility method to constructs a new InvalidAmount-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_invalid_amount(void);

/**
 * Utility method to constructs a new InsufficientAmount-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_insufficient_amount(void);

/**
 * Utility method to constructs a new UnexpectedAmount-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_amount(void);

/**
 * Utility method to constructs a new UnsupportedCurrency-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unsupported_currency(void);

/**
 * Utility method to constructs a new UnknownRequiredFeatures-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unknown_required_features(void);

/**
 * Utility method to constructs a new UnexpectedFeatures-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_features(void);

/**
 * Utility method to constructs a new MissingDescription-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_description(void);

/**
 * Utility method to constructs a new MissingSigningPubkey-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_signing_pubkey(void);

/**
 * Utility method to constructs a new InvalidSigningPubkey-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_invalid_signing_pubkey(void);

/**
 * Utility method to constructs a new UnexpectedSigningPubkey-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_signing_pubkey(void);

/**
 * Utility method to constructs a new MissingQuantity-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_quantity(void);

/**
 * Utility method to constructs a new InvalidQuantity-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_invalid_quantity(void);

/**
 * Utility method to constructs a new UnexpectedQuantity-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_quantity(void);

/**
 * Utility method to constructs a new InvalidMetadata-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_invalid_metadata(void);

/**
 * Utility method to constructs a new UnexpectedMetadata-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_unexpected_metadata(void);

/**
 * Utility method to constructs a new MissingPayerMetadata-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_payer_metadata(void);

/**
 * Utility method to constructs a new MissingPayerId-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_payer_id(void);

/**
 * Utility method to constructs a new MissingPaths-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_paths(void);

/**
 * Utility method to constructs a new InvalidPayInfo-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_invalid_pay_info(void);

/**
 * Utility method to constructs a new MissingCreationTime-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_creation_time(void);

/**
 * Utility method to constructs a new MissingPaymentHash-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_payment_hash(void);

/**
 * Utility method to constructs a new MissingSignature-variant Bolt12SemanticError
 */
enum LDKBolt12SemanticError Bolt12SemanticError_missing_signature(void);

/**
 * Frees any resources used by the Refund, if is_owned is set and inner is non-NULL.
 */
void Refund_free(struct LDKRefund this_obj);

/**
 * Creates a copy of the Refund
 */
struct LDKRefund Refund_clone(const struct LDKRefund *NONNULL_PTR orig);

/**
 * A complete description of the purpose of the refund. Intended to be displayed to the user
 * but with the caveat that it has not been verified in any way.
 */
MUST_USE_RES struct LDKPrintableString Refund_description(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Duration since the Unix epoch when an invoice should no longer be sent.
 *
 * If `None`, the refund does not expire.
 */
MUST_USE_RES struct LDKCOption_u64Z Refund_absolute_expiry(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Whether the refund has expired.
 */
MUST_USE_RES bool Refund_is_expired(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * The issuer of the refund, possibly beginning with `user@domain` or `domain`. Intended to be
 * displayed to the user but with the caveat that it has not been verified in any way.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString Refund_issuer(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Paths to the sender originating from publicly reachable nodes. Blinded paths provide sender
 * privacy by obfuscating its node id.
 */
MUST_USE_RES struct LDKCVec_BlindedPathZ Refund_paths(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * An unpredictable series of bytes, typically containing information about the derivation of
 * [`payer_id`].
 *
 * [`payer_id`]: Self::payer_id
 */
MUST_USE_RES struct LDKu8slice Refund_payer_metadata(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * A chain that the refund is valid for.
 */
MUST_USE_RES struct LDKThirtyTwoBytes Refund_chain(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * The amount to refund in msats (i.e., the minimum lightning-payable unit for [`chain`]).
 *
 * [`chain`]: Self::chain
 */
MUST_USE_RES uint64_t Refund_amount_msats(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Features pertaining to requesting an invoice.
 */
MUST_USE_RES struct LDKInvoiceRequestFeatures Refund_features(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * The quantity of an item that refund is for.
 */
MUST_USE_RES struct LDKCOption_u64Z Refund_quantity(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * A public node id to send to in the case where there are no [`paths`]. Otherwise, a possibly
 * transient pubkey.
 *
 * [`paths`]: Self::paths
 */
MUST_USE_RES struct LDKPublicKey Refund_payer_id(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Payer provided note to include in the invoice.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPrintableString Refund_payer_note(const struct LDKRefund *NONNULL_PTR this_arg);

/**
 * Serialize the Refund object into a byte array which can be read by Refund_read
 */
struct LDKCVec_u8Z Refund_write(const struct LDKRefund *NONNULL_PTR obj);

/**
 * Read a Refund object from a string
 */
struct LDKCResult_RefundBolt12ParseErrorZ Refund_from_str(struct LDKStr s);

/**
 * Creates a copy of the UtxoLookupError
 */
enum LDKUtxoLookupError UtxoLookupError_clone(const enum LDKUtxoLookupError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new UnknownChain-variant UtxoLookupError
 */
enum LDKUtxoLookupError UtxoLookupError_unknown_chain(void);

/**
 * Utility method to constructs a new UnknownTx-variant UtxoLookupError
 */
enum LDKUtxoLookupError UtxoLookupError_unknown_tx(void);

/**
 * Frees any resources used by the UtxoResult
 */
void UtxoResult_free(struct LDKUtxoResult this_ptr);

/**
 * Creates a copy of the UtxoResult
 */
struct LDKUtxoResult UtxoResult_clone(const struct LDKUtxoResult *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Sync-variant UtxoResult
 */
struct LDKUtxoResult UtxoResult_sync(struct LDKCResult_TxOutUtxoLookupErrorZ a);

/**
 * Utility method to constructs a new Async-variant UtxoResult
 */
struct LDKUtxoResult UtxoResult_async(struct LDKUtxoFuture a);

/**
 * Calls the free function if one is set
 */
void UtxoLookup_free(struct LDKUtxoLookup this_ptr);

/**
 * Frees any resources used by the UtxoFuture, if is_owned is set and inner is non-NULL.
 */
void UtxoFuture_free(struct LDKUtxoFuture this_obj);

/**
 * Creates a copy of the UtxoFuture
 */
struct LDKUtxoFuture UtxoFuture_clone(const struct LDKUtxoFuture *NONNULL_PTR orig);

/**
 * Builds a new future for later resolution.
 */
MUST_USE_RES struct LDKUtxoFuture UtxoFuture_new(void);

/**
 * Resolves this future against the given `graph` and with the given `result`.
 *
 * This is identical to calling [`UtxoFuture::resolve`] with a dummy `gossip`, disabling
 * forwarding the validated gossip message onwards to peers.
 *
 * Because this may cause the [`NetworkGraph`]'s [`processing_queue_high`] to flip, in order
 * to allow us to interact with peers again, you should call [`PeerManager::process_events`]
 * after this.
 *
 * [`processing_queue_high`]: crate::ln::msgs::RoutingMessageHandler::processing_queue_high
 * [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
 */
void UtxoFuture_resolve_without_forwarding(const struct LDKUtxoFuture *NONNULL_PTR this_arg, const struct LDKNetworkGraph *NONNULL_PTR graph, struct LDKCResult_TxOutUtxoLookupErrorZ result);

/**
 * Resolves this future against the given `graph` and with the given `result`.
 *
 * The given `gossip` is used to broadcast any validated messages onwards to all peers which
 * have available buffer space.
 *
 * Because this may cause the [`NetworkGraph`]'s [`processing_queue_high`] to flip, in order
 * to allow us to interact with peers again, you should call [`PeerManager::process_events`]
 * after this.
 *
 * [`processing_queue_high`]: crate::ln::msgs::RoutingMessageHandler::processing_queue_high
 * [`PeerManager::process_events`]: crate::ln::peer_handler::PeerManager::process_events
 */
void UtxoFuture_resolve(const struct LDKUtxoFuture *NONNULL_PTR this_arg, const struct LDKNetworkGraph *NONNULL_PTR graph, const struct LDKP2PGossipSync *NONNULL_PTR gossip, struct LDKCResult_TxOutUtxoLookupErrorZ result);

/**
 * Frees any resources used by the NodeId, if is_owned is set and inner is non-NULL.
 */
void NodeId_free(struct LDKNodeId this_obj);

/**
 * Creates a copy of the NodeId
 */
struct LDKNodeId NodeId_clone(const struct LDKNodeId *NONNULL_PTR orig);

/**
 * Create a new NodeId from a public key
 */
MUST_USE_RES struct LDKNodeId NodeId_from_pubkey(struct LDKPublicKey pubkey);

/**
 * Get the public key slice from this NodeId
 */
MUST_USE_RES struct LDKu8slice NodeId_as_slice(const struct LDKNodeId *NONNULL_PTR this_arg);

/**
 * Get the public key from this NodeId
 */
MUST_USE_RES struct LDKCResult_PublicKeySecp256k1ErrorZ NodeId_as_pubkey(const struct LDKNodeId *NONNULL_PTR this_arg);

/**
 * Generates a non-cryptographic 64-bit hash of the NodeId.
 */
uint64_t NodeId_hash(const struct LDKNodeId *NONNULL_PTR o);

/**
 * Serialize the NodeId object into a byte array which can be read by NodeId_read
 */
struct LDKCVec_u8Z NodeId_write(const struct LDKNodeId *NONNULL_PTR obj);

/**
 * Read a NodeId from a byte array, created by NodeId_write
 */
struct LDKCResult_NodeIdDecodeErrorZ NodeId_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NetworkGraph, if is_owned is set and inner is non-NULL.
 */
void NetworkGraph_free(struct LDKNetworkGraph this_obj);

/**
 * Frees any resources used by the ReadOnlyNetworkGraph, if is_owned is set and inner is non-NULL.
 */
void ReadOnlyNetworkGraph_free(struct LDKReadOnlyNetworkGraph this_obj);

/**
 * Frees any resources used by the NetworkUpdate
 */
void NetworkUpdate_free(struct LDKNetworkUpdate this_ptr);

/**
 * Creates a copy of the NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_clone(const struct LDKNetworkUpdate *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ChannelUpdateMessage-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_update_message(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new ChannelFailure-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_channel_failure(uint64_t short_channel_id, bool is_permanent);

/**
 * Utility method to constructs a new NodeFailure-variant NetworkUpdate
 */
struct LDKNetworkUpdate NetworkUpdate_node_failure(struct LDKPublicKey node_id, bool is_permanent);

/**
 * Checks if two NetworkUpdates contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool NetworkUpdate_eq(const struct LDKNetworkUpdate *NONNULL_PTR a, const struct LDKNetworkUpdate *NONNULL_PTR b);

/**
 * Serialize the NetworkUpdate object into a byte array which can be read by NetworkUpdate_read
 */
struct LDKCVec_u8Z NetworkUpdate_write(const struct LDKNetworkUpdate *NONNULL_PTR obj);

/**
 * Read a NetworkUpdate from a byte array, created by NetworkUpdate_write
 */
struct LDKCResult_COption_NetworkUpdateZDecodeErrorZ NetworkUpdate_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the P2PGossipSync, if is_owned is set and inner is non-NULL.
 */
void P2PGossipSync_free(struct LDKP2PGossipSync this_obj);

/**
 * Creates a new tracker of the actual state of the network of channels and nodes,
 * assuming an existing [`NetworkGraph`].
 * UTXO lookup is used to make sure announced channels exist on-chain, channel data is
 * correct, and the announcement is signed with channel owners' keys.
 */
MUST_USE_RES struct LDKP2PGossipSync P2PGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCOption_UtxoLookupZ utxo_lookup, struct LDKLogger logger);

/**
 * Adds a provider used to check new announcements. Does not affect
 * existing announcements unless they are updated.
 * Add, update or remove the provider would replace the current one.
 */
void P2PGossipSync_add_utxo_lookup(const struct LDKP2PGossipSync *NONNULL_PTR this_arg, struct LDKCOption_UtxoLookupZ utxo_lookup);

/**
 * Handles any network updates originating from [`Event`]s.
 *
 * [`Event`]: crate::events::Event
 */
void NetworkGraph_handle_network_update(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNetworkUpdate *NONNULL_PTR network_update);

/**
 * Gets the genesis hash for this network graph.
 */
MUST_USE_RES struct LDKThirtyTwoBytes NetworkGraph_get_genesis_hash(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Verifies the signature of a [`NodeAnnouncement`].
 *
 * Returns an error if it is invalid.
 */
struct LDKCResult_NoneLightningErrorZ verify_node_announcement(const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * Verifies all signatures included in a [`ChannelAnnouncement`].
 *
 * Returns an error if one of the signatures is invalid.
 */
struct LDKCResult_NoneLightningErrorZ verify_channel_announcement(const struct LDKChannelAnnouncement *NONNULL_PTR msg);

/**
 * Constructs a new RoutingMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned RoutingMessageHandler must be freed before this_arg is
 */
struct LDKRoutingMessageHandler P2PGossipSync_as_RoutingMessageHandler(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);

/**
 * Constructs a new MessageSendEventsProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageSendEventsProvider must be freed before this_arg is
 */
struct LDKMessageSendEventsProvider P2PGossipSync_as_MessageSendEventsProvider(const struct LDKP2PGossipSync *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelUpdateInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelUpdateInfo_free(struct LDKChannelUpdateInfo this_obj);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t ChannelUpdateInfo_get_last_update(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * When the last update to the channel direction was issued.
 * Value is opaque, as set in the announcement.
 */
void ChannelUpdateInfo_set_last_update(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
bool ChannelUpdateInfo_get_enabled(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Whether the channel can be currently used for payments (in this one direction).
 */
void ChannelUpdateInfo_set_enabled(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, bool val);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
uint16_t ChannelUpdateInfo_get_cltv_expiry_delta(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values that you must have when routing through this channel.
 */
void ChannelUpdateInfo_set_cltv_expiry_delta(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
uint64_t ChannelUpdateInfo_get_htlc_minimum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The minimum value, which must be relayed to the next hop via the channel
 */
void ChannelUpdateInfo_set_htlc_minimum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
uint64_t ChannelUpdateInfo_get_htlc_maximum_msat(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * The maximum value which may be relayed to the next hop via the channel.
 */
void ChannelUpdateInfo_set_htlc_maximum_msat(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Fees charged when the channel is used for routing
 */
struct LDKRoutingFees ChannelUpdateInfo_get_fees(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Fees charged when the channel is used for routing
 */
void ChannelUpdateInfo_set_fees(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdate ChannelUpdateInfo_get_last_update_message(const struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr);

/**
 * Most recent update for the channel received from the network
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelUpdateInfo_set_last_update_message(struct LDKChannelUpdateInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdate val);

/**
 * Constructs a new ChannelUpdateInfo given each field
 *
 * Note that last_update_message_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelUpdateInfo ChannelUpdateInfo_new(uint32_t last_update_arg, bool enabled_arg, uint16_t cltv_expiry_delta_arg, uint64_t htlc_minimum_msat_arg, uint64_t htlc_maximum_msat_arg, struct LDKRoutingFees fees_arg, struct LDKChannelUpdate last_update_message_arg);

/**
 * Creates a copy of the ChannelUpdateInfo
 */
struct LDKChannelUpdateInfo ChannelUpdateInfo_clone(const struct LDKChannelUpdateInfo *NONNULL_PTR orig);

/**
 * Checks if two ChannelUpdateInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelUpdateInfo_eq(const struct LDKChannelUpdateInfo *NONNULL_PTR a, const struct LDKChannelUpdateInfo *NONNULL_PTR b);

/**
 * Serialize the ChannelUpdateInfo object into a byte array which can be read by ChannelUpdateInfo_read
 */
struct LDKCVec_u8Z ChannelUpdateInfo_write(const struct LDKChannelUpdateInfo *NONNULL_PTR obj);

/**
 * Read a ChannelUpdateInfo from a byte array, created by ChannelUpdateInfo_write
 */
struct LDKCResult_ChannelUpdateInfoDecodeErrorZ ChannelUpdateInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ChannelInfo, if is_owned is set and inner is non-NULL.
 */
void ChannelInfo_free(struct LDKChannelInfo this_obj);

/**
 * Protocol features of a channel communicated during its announcement
 */
struct LDKChannelFeatures ChannelInfo_get_features(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features of a channel communicated during its announcement
 */
void ChannelInfo_set_features(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * Source node of the first direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the first direction of a channel
 */
void ChannelInfo_set_node_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the first direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_one_to_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the first direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_one_to_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * Source node of the second direction of a channel
 */
struct LDKNodeId ChannelInfo_get_node_two(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Source node of the second direction of a channel
 */
void ChannelInfo_set_node_two(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKNodeId val);

/**
 * Details about the second direction of a channel
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelUpdateInfo ChannelInfo_get_two_to_one(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * Details about the second direction of a channel
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_two_to_one(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelUpdateInfo val);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
struct LDKCOption_u64Z ChannelInfo_get_capacity_sats(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * The channel capacity as seen on-chain, if chain lookup is available.
 */
void ChannelInfo_set_capacity_sats(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelAnnouncement ChannelInfo_get_announcement_message(const struct LDKChannelInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the channel
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void ChannelInfo_set_announcement_message(struct LDKChannelInfo *NONNULL_PTR this_ptr, struct LDKChannelAnnouncement val);

/**
 * Creates a copy of the ChannelInfo
 */
struct LDKChannelInfo ChannelInfo_clone(const struct LDKChannelInfo *NONNULL_PTR orig);

/**
 * Checks if two ChannelInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelInfo_eq(const struct LDKChannelInfo *NONNULL_PTR a, const struct LDKChannelInfo *NONNULL_PTR b);

/**
 * Returns a [`ChannelUpdateInfo`] based on the direction implied by the channel_flag.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelUpdateInfo ChannelInfo_get_directional_info(const struct LDKChannelInfo *NONNULL_PTR this_arg, uint8_t channel_flags);

/**
 * Serialize the ChannelInfo object into a byte array which can be read by ChannelInfo_read
 */
struct LDKCVec_u8Z ChannelInfo_write(const struct LDKChannelInfo *NONNULL_PTR obj);

/**
 * Read a ChannelInfo from a byte array, created by ChannelInfo_write
 */
struct LDKCResult_ChannelInfoDecodeErrorZ ChannelInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the DirectedChannelInfo, if is_owned is set and inner is non-NULL.
 */
void DirectedChannelInfo_free(struct LDKDirectedChannelInfo this_obj);

/**
 * Creates a copy of the DirectedChannelInfo
 */
struct LDKDirectedChannelInfo DirectedChannelInfo_clone(const struct LDKDirectedChannelInfo *NONNULL_PTR orig);

/**
 * Returns information for the channel.
 */
MUST_USE_RES struct LDKChannelInfo DirectedChannelInfo_channel(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns the maximum HTLC amount allowed over the channel in the direction.
 */
MUST_USE_RES uint64_t DirectedChannelInfo_htlc_maximum_msat(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Returns the [`EffectiveCapacity`] of the channel in the direction.
 *
 * This is either the total capacity from the funding transaction, if known, or the
 * `htlc_maximum_msat` for the direction as advertised by the gossip network, if known,
 * otherwise.
 */
MUST_USE_RES struct LDKEffectiveCapacity DirectedChannelInfo_effective_capacity(const struct LDKDirectedChannelInfo *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the EffectiveCapacity
 */
void EffectiveCapacity_free(struct LDKEffectiveCapacity this_ptr);

/**
 * Creates a copy of the EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_clone(const struct LDKEffectiveCapacity *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ExactLiquidity-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_exact_liquidity(uint64_t liquidity_msat);

/**
 * Utility method to constructs a new AdvertisedMaxHTLC-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_advertised_max_htlc(uint64_t amount_msat);

/**
 * Utility method to constructs a new Total-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_total(uint64_t capacity_msat, uint64_t htlc_maximum_msat);

/**
 * Utility method to constructs a new Infinite-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_infinite(void);

/**
 * Utility method to constructs a new HintMaxHTLC-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_hint_max_htlc(uint64_t amount_msat);

/**
 * Utility method to constructs a new Unknown-variant EffectiveCapacity
 */
struct LDKEffectiveCapacity EffectiveCapacity_unknown(void);

/**
 * Returns the effective capacity denominated in millisatoshi.
 */
MUST_USE_RES uint64_t EffectiveCapacity_as_msat(const struct LDKEffectiveCapacity *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the RoutingFees, if is_owned is set and inner is non-NULL.
 */
void RoutingFees_free(struct LDKRoutingFees this_obj);

/**
 * Flat routing fee in millisatoshis.
 */
uint32_t RoutingFees_get_base_msat(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Flat routing fee in millisatoshis.
 */
void RoutingFees_set_base_msat(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
uint32_t RoutingFees_get_proportional_millionths(const struct LDKRoutingFees *NONNULL_PTR this_ptr);

/**
 * Liquidity-based routing fee in millionths of a routed amount.
 * In other words, 10000 is 1%.
 */
void RoutingFees_set_proportional_millionths(struct LDKRoutingFees *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new RoutingFees given each field
 */
MUST_USE_RES struct LDKRoutingFees RoutingFees_new(uint32_t base_msat_arg, uint32_t proportional_millionths_arg);

/**
 * Checks if two RoutingFeess contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RoutingFees_eq(const struct LDKRoutingFees *NONNULL_PTR a, const struct LDKRoutingFees *NONNULL_PTR b);

/**
 * Creates a copy of the RoutingFees
 */
struct LDKRoutingFees RoutingFees_clone(const struct LDKRoutingFees *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RoutingFees.
 */
uint64_t RoutingFees_hash(const struct LDKRoutingFees *NONNULL_PTR o);

/**
 * Serialize the RoutingFees object into a byte array which can be read by RoutingFees_read
 */
struct LDKCVec_u8Z RoutingFees_write(const struct LDKRoutingFees *NONNULL_PTR obj);

/**
 * Read a RoutingFees from a byte array, created by RoutingFees_write
 */
struct LDKCResult_RoutingFeesDecodeErrorZ RoutingFees_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAnnouncementInfo, if is_owned is set and inner is non-NULL.
 */
void NodeAnnouncementInfo_free(struct LDKNodeAnnouncementInfo this_obj);

/**
 * Protocol features the node announced support for
 */
struct LDKNodeFeatures NodeAnnouncementInfo_get_features(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Protocol features the node announced support for
 */
void NodeAnnouncementInfo_set_features(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
uint32_t NodeAnnouncementInfo_get_last_update(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * When the last known update to the node state was issued.
 * Value is opaque, as set in the announcement.
 */
void NodeAnnouncementInfo_set_last_update(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Color assigned to the node
 */
const uint8_t (*NodeAnnouncementInfo_get_rgb(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr))[3];

/**
 * Color assigned to the node
 */
void NodeAnnouncementInfo_set_rgb(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKThreeBytes val);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
struct LDKNodeAlias NodeAnnouncementInfo_get_alias(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * Moniker assigned to the node.
 * May be invalid or malicious (eg control chars),
 * should not be exposed to the user.
 */
void NodeAnnouncementInfo_set_alias(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAlias val);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncement NodeAnnouncementInfo_get_announcement_message(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr);

/**
 * An initial announcement of the node
 * Mostly redundant with the data we store in fields explicitly.
 * Everything else is useful only for sending out for initial routing sync.
 * Not stored if contains excess data to prevent DoS.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeAnnouncementInfo_set_announcement_message(struct LDKNodeAnnouncementInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncement val);

/**
 * Constructs a new NodeAnnouncementInfo given each field
 *
 * Note that announcement_message_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_new(struct LDKNodeFeatures features_arg, uint32_t last_update_arg, struct LDKThreeBytes rgb_arg, struct LDKNodeAlias alias_arg, struct LDKNodeAnnouncement announcement_message_arg);

/**
 * Creates a copy of the NodeAnnouncementInfo
 */
struct LDKNodeAnnouncementInfo NodeAnnouncementInfo_clone(const struct LDKNodeAnnouncementInfo *NONNULL_PTR orig);

/**
 * Checks if two NodeAnnouncementInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAnnouncementInfo_eq(const struct LDKNodeAnnouncementInfo *NONNULL_PTR a, const struct LDKNodeAnnouncementInfo *NONNULL_PTR b);

/**
 * Internet-level addresses via which one can connect to the node
 */
MUST_USE_RES struct LDKCVec_SocketAddressZ NodeAnnouncementInfo_addresses(const struct LDKNodeAnnouncementInfo *NONNULL_PTR this_arg);

/**
 * Serialize the NodeAnnouncementInfo object into a byte array which can be read by NodeAnnouncementInfo_read
 */
struct LDKCVec_u8Z NodeAnnouncementInfo_write(const struct LDKNodeAnnouncementInfo *NONNULL_PTR obj);

/**
 * Read a NodeAnnouncementInfo from a byte array, created by NodeAnnouncementInfo_write
 */
struct LDKCResult_NodeAnnouncementInfoDecodeErrorZ NodeAnnouncementInfo_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeAlias, if is_owned is set and inner is non-NULL.
 */
void NodeAlias_free(struct LDKNodeAlias this_obj);

const uint8_t (*NodeAlias_get_a(const struct LDKNodeAlias *NONNULL_PTR this_ptr))[32];

void NodeAlias_set_a(struct LDKNodeAlias *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new NodeAlias given each field
 */
MUST_USE_RES struct LDKNodeAlias NodeAlias_new(struct LDKThirtyTwoBytes a_arg);

/**
 * Creates a copy of the NodeAlias
 */
struct LDKNodeAlias NodeAlias_clone(const struct LDKNodeAlias *NONNULL_PTR orig);

/**
 * Checks if two NodeAliass contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeAlias_eq(const struct LDKNodeAlias *NONNULL_PTR a, const struct LDKNodeAlias *NONNULL_PTR b);

/**
 * Serialize the NodeAlias object into a byte array which can be read by NodeAlias_read
 */
struct LDKCVec_u8Z NodeAlias_write(const struct LDKNodeAlias *NONNULL_PTR obj);

/**
 * Read a NodeAlias from a byte array, created by NodeAlias_write
 */
struct LDKCResult_NodeAliasDecodeErrorZ NodeAlias_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the NodeInfo, if is_owned is set and inner is non-NULL.
 */
void NodeInfo_free(struct LDKNodeInfo this_obj);

/**
 * All valid channels a node has announced
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z NodeInfo_get_channels(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * All valid channels a node has announced
 */
void NodeInfo_set_channels(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKNodeAnnouncementInfo NodeInfo_get_announcement_info(const struct LDKNodeInfo *NONNULL_PTR this_ptr);

/**
 * More information about a node from node_announcement.
 * Optional because we store a Node entry after learning about it from
 * a channel announcement, but before receiving a node announcement.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void NodeInfo_set_announcement_info(struct LDKNodeInfo *NONNULL_PTR this_ptr, struct LDKNodeAnnouncementInfo val);

/**
 * Constructs a new NodeInfo given each field
 *
 * Note that announcement_info_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKNodeInfo NodeInfo_new(struct LDKCVec_u64Z channels_arg, struct LDKNodeAnnouncementInfo announcement_info_arg);

/**
 * Creates a copy of the NodeInfo
 */
struct LDKNodeInfo NodeInfo_clone(const struct LDKNodeInfo *NONNULL_PTR orig);

/**
 * Checks if two NodeInfos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool NodeInfo_eq(const struct LDKNodeInfo *NONNULL_PTR a, const struct LDKNodeInfo *NONNULL_PTR b);

/**
 * Serialize the NodeInfo object into a byte array which can be read by NodeInfo_read
 */
struct LDKCVec_u8Z NodeInfo_write(const struct LDKNodeInfo *NONNULL_PTR obj);

/**
 * Read a NodeInfo from a byte array, created by NodeInfo_write
 */
struct LDKCResult_NodeInfoDecodeErrorZ NodeInfo_read(struct LDKu8slice ser);

/**
 * Serialize the NetworkGraph object into a byte array which can be read by NetworkGraph_read
 */
struct LDKCVec_u8Z NetworkGraph_write(const struct LDKNetworkGraph *NONNULL_PTR obj);

/**
 * Read a NetworkGraph from a byte array, created by NetworkGraph_write
 */
struct LDKCResult_NetworkGraphDecodeErrorZ NetworkGraph_read(struct LDKu8slice ser, struct LDKLogger arg);

/**
 * Creates a new, empty, network graph.
 */
MUST_USE_RES struct LDKNetworkGraph NetworkGraph_new(enum LDKNetwork network, struct LDKLogger logger);

/**
 * Returns a read-only view of the network graph.
 */
MUST_USE_RES struct LDKReadOnlyNetworkGraph NetworkGraph_read_only(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * The unix timestamp provided by the most recent rapid gossip sync.
 * It will be set by the rapid sync process after every sync completion.
 */
MUST_USE_RES struct LDKCOption_u32Z NetworkGraph_get_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Update the unix timestamp provided by the most recent rapid gossip sync.
 * This should be done automatically by the rapid sync process after every sync completion.
 */
void NetworkGraph_set_last_rapid_gossip_sync_timestamp(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint32_t last_rapid_gossip_sync_timestamp);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement.
 *
 * You probably don't want to call this directly, instead relying on a P2PGossipSync's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeAnnouncement *NONNULL_PTR msg);

/**
 * For an already known node (from channel announcements), update its stored properties from a
 * given node announcement without verifying the associated signatures. Because we aren't
 * given the associated signatures here we cannot relay the node announcement to any of our
 * peers.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_node_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedNodeAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a [`P2PGossipSync`]'s
 * [`RoutingMessageHandler`] implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If a [`UtxoLookup`] object is provided via `utxo_lookup`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_UtxoLookupZ utxo_lookup);

/**
 * Store or update channel info from a channel announcement.
 *
 * You probably don't want to call this directly, instead relying on a [`P2PGossipSync`]'s
 * [`RoutingMessageHandler`] implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * This will skip verification of if the channel is actually on-chain.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_announcement_no_lookup(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelAnnouncement *NONNULL_PTR msg);

/**
 * Store or update channel info from a channel announcement without verifying the associated
 * signatures. Because we aren't given the associated signatures here we cannot relay the
 * channel announcement to any of our peers.
 *
 * If a [`UtxoLookup`] object is provided via `utxo_lookup`, it will be called to verify
 * the corresponding UTXO exists on chain and is correctly-formatted.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_from_unsigned_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelAnnouncement *NONNULL_PTR msg, struct LDKCOption_UtxoLookupZ utxo_lookup);

/**
 * Update channel from partial announcement data received via rapid gossip sync
 *
 * `timestamp: u64`: Timestamp emulating the backdated original announcement receipt (by the
 * rapid gossip sync server)
 *
 * All other parameters as used in [`msgs::UnsignedChannelAnnouncement`] fields.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_add_channel_from_partial_announcement(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id, uint64_t timestamp, struct LDKChannelFeatures features, struct LDKPublicKey node_id_1, struct LDKPublicKey node_id_2);

/**
 * Marks a channel in the graph as failed permanently.
 *
 * The channel and any node for which this was their last channel are removed from the graph.
 */
void NetworkGraph_channel_failed_permanent(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id);

/**
 * Marks a node in the graph as permanently failed, effectively removing it and its channels
 * from local storage.
 */
void NetworkGraph_node_failed_permanent(const struct LDKNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey node_id);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * Note that for users of the `lightning-background-processor` crate this method may be
 * automatically called regularly for you.
 *
 * This method will also cause us to stop tracking removed nodes and channels if they have been
 * in the map for a while so that these can be resynced from gossip in the future.
 *
 * This method is only available with the `std` feature. See
 * [`NetworkGraph::remove_stale_channels_and_tracking_with_time`] for `no-std` use.
 */
void NetworkGraph_remove_stale_channels_and_tracking(const struct LDKNetworkGraph *NONNULL_PTR this_arg);

/**
 * Removes information about channels that we haven't heard any updates about in some time.
 * This can be used regularly to prune the network graph of channels that likely no longer
 * exist.
 *
 * While there is no formal requirement that nodes regularly re-broadcast their channel
 * updates every two weeks, the non-normative section of BOLT 7 currently suggests that
 * pruning occur for updates which are at least two weeks old, which we implement here.
 *
 * This method will also cause us to stop tracking removed nodes and channels if they have been
 * in the map for a while so that these can be resynced from gossip in the future.
 *
 * This function takes the current unix time as an argument. For users with the `std` feature
 * enabled, [`NetworkGraph::remove_stale_channels_and_tracking`] may be preferable.
 */
void NetworkGraph_remove_stale_channels_and_tracking_with_time(const struct LDKNetworkGraph *NONNULL_PTR this_arg, uint64_t current_time_unix);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel.
 *
 * You probably don't want to call this directly, instead relying on a P2PGossipSync's
 * RoutingMessageHandler implementation to call it indirectly. This may be useful to accept
 * routing messages from a source using a protocol other than the lightning P2P protocol.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKChannelUpdate *NONNULL_PTR msg);

/**
 * For an already known (from announcement) channel, update info about one of the directions
 * of the channel without verifying the associated signatures. Because we aren't given the
 * associated signatures here we cannot relay the channel update to any of our peers.
 *
 * If built with `no-std`, any updates with a timestamp more than two weeks in the past or
 * materially in the future will be rejected.
 */
MUST_USE_RES struct LDKCResult_NoneLightningErrorZ NetworkGraph_update_channel_unsigned(const struct LDKNetworkGraph *NONNULL_PTR this_arg, const struct LDKUnsignedChannelUpdate *NONNULL_PTR msg);

/**
 * Returns information on a channel with the given id.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelInfo ReadOnlyNetworkGraph_channel(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, uint64_t short_channel_id);

/**
 * Returns the list of channels in the graph
 */
MUST_USE_RES struct LDKCVec_u64Z ReadOnlyNetworkGraph_list_channels(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);

/**
 * Returns information on a node with the given id.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKNodeInfo ReadOnlyNetworkGraph_node(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Returns the list of nodes in the graph
 */
MUST_USE_RES struct LDKCVec_NodeIdZ ReadOnlyNetworkGraph_list_nodes(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg);

/**
 * Get network addresses by node id.
 * Returns None if the requested node is completely unknown,
 * or if node announcement for the node was never received.
 */
MUST_USE_RES struct LDKCOption_CVec_SocketAddressZZ ReadOnlyNetworkGraph_get_addresses(const struct LDKReadOnlyNetworkGraph *NONNULL_PTR this_arg, struct LDKPublicKey pubkey);

/**
 * Frees any resources used by the DefaultRouter, if is_owned is set and inner is non-NULL.
 */
void DefaultRouter_free(struct LDKDefaultRouter this_obj);

/**
 * Creates a new router.
 */
MUST_USE_RES struct LDKDefaultRouter DefaultRouter_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, struct LDKThirtyTwoBytes random_seed_bytes, struct LDKLockableScore scorer, struct LDKProbabilisticScoringFeeParameters score_params);

/**
 * Constructs a new Router which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Router must be freed before this_arg is
 */
struct LDKRouter DefaultRouter_as_Router(const struct LDKDefaultRouter *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void Router_free(struct LDKRouter this_ptr);

/**
 * Frees any resources used by the ScorerAccountingForInFlightHtlcs, if is_owned is set and inner is non-NULL.
 */
void ScorerAccountingForInFlightHtlcs_free(struct LDKScorerAccountingForInFlightHtlcs this_obj);

/**
 * Initialize a new `ScorerAccountingForInFlightHtlcs`.
 */
MUST_USE_RES struct LDKScorerAccountingForInFlightHtlcs ScorerAccountingForInFlightHtlcs_new(struct LDKScoreLookUp scorer, const struct LDKInFlightHtlcs *NONNULL_PTR inflight_htlcs);

/**
 * Constructs a new ScoreLookUp which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreLookUp must be freed before this_arg is
 */
struct LDKScoreLookUp ScorerAccountingForInFlightHtlcs_as_ScoreLookUp(const struct LDKScorerAccountingForInFlightHtlcs *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the InFlightHtlcs, if is_owned is set and inner is non-NULL.
 */
void InFlightHtlcs_free(struct LDKInFlightHtlcs this_obj);

/**
 * Creates a copy of the InFlightHtlcs
 */
struct LDKInFlightHtlcs InFlightHtlcs_clone(const struct LDKInFlightHtlcs *NONNULL_PTR orig);

/**
 * Constructs an empty `InFlightHtlcs`.
 */
MUST_USE_RES struct LDKInFlightHtlcs InFlightHtlcs_new(void);

/**
 * Takes in a path with payer's node id and adds the path's details to `InFlightHtlcs`.
 */
void InFlightHtlcs_process_path(struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKPath *NONNULL_PTR path, struct LDKPublicKey payer_node_id);

/**
 * Adds a known HTLC given the public key of the HTLC source, target, and short channel
 * id.
 */
void InFlightHtlcs_add_inflight_htlc(struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, uint64_t channel_scid, uint64_t used_msat);

/**
 * Returns liquidity in msat given the public key of the HTLC source, target, and short channel
 * id.
 */
MUST_USE_RES struct LDKCOption_u64Z InFlightHtlcs_used_liquidity_msat(const struct LDKInFlightHtlcs *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR source, const struct LDKNodeId *NONNULL_PTR target, uint64_t channel_scid);

/**
 * Serialize the InFlightHtlcs object into a byte array which can be read by InFlightHtlcs_read
 */
struct LDKCVec_u8Z InFlightHtlcs_write(const struct LDKInFlightHtlcs *NONNULL_PTR obj);

/**
 * Read a InFlightHtlcs from a byte array, created by InFlightHtlcs_write
 */
struct LDKCResult_InFlightHtlcsDecodeErrorZ InFlightHtlcs_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHop, if is_owned is set and inner is non-NULL.
 */
void RouteHop_free(struct LDKRouteHop this_obj);

/**
 * The node_id of the node at this hop.
 */
struct LDKPublicKey RouteHop_get_pubkey(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the node at this hop.
 */
void RouteHop_set_pubkey(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
struct LDKNodeFeatures RouteHop_get_node_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The node_announcement features of the node at this hop. For the last hop, these may be
 * amended to match the features present in the invoice this node generated.
 */
void RouteHop_set_node_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKNodeFeatures val);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
uint64_t RouteHop_get_short_channel_id(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel that should be used from the previous hop to reach this node.
 */
void RouteHop_set_short_channel_id(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
struct LDKChannelFeatures RouteHop_get_channel_features(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The channel_announcement features of the channel that should be used from the previous hop
 * to reach this node.
 */
void RouteHop_set_channel_features(struct LDKRouteHop *NONNULL_PTR this_ptr, struct LDKChannelFeatures val);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * If this is the last hop in [`Path::hops`]:
 * * if we're sending to a [`BlindedPath`], this is the fee paid for use of the entire blinded path
 * * otherwise, this is the full value of this [`Path`]'s part of the payment
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
uint64_t RouteHop_get_fee_msat(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The fee taken on this hop (for paying for the use of the *next* channel in the path).
 * If this is the last hop in [`Path::hops`]:
 * * if we're sending to a [`BlindedPath`], this is the fee paid for use of the entire blinded path
 * * otherwise, this is the full value of this [`Path`]'s part of the payment
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
void RouteHop_set_fee_msat(struct LDKRouteHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The CLTV delta added for this hop.
 * If this is the last hop in [`Path::hops`]:
 * * if we're sending to a [`BlindedPath`], this is the CLTV delta for the entire blinded path
 * * otherwise, this is the CLTV delta expected at the destination
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
uint32_t RouteHop_get_cltv_expiry_delta(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * The CLTV delta added for this hop.
 * If this is the last hop in [`Path::hops`]:
 * * if we're sending to a [`BlindedPath`], this is the CLTV delta for the entire blinded path
 * * otherwise, this is the CLTV delta expected at the destination
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
void RouteHop_set_cltv_expiry_delta(struct LDKRouteHop *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Indicates whether this hop is possibly announced in the public network graph.
 *
 * Will be `true` if there is a possibility that the channel is publicly known, i.e., if we
 * either know for sure it's announced in the public graph, or if any public channels exist
 * for which the given `short_channel_id` could be an alias for. Will be `false` if we believe
 * the channel to be unannounced.
 *
 * Will be `true` for objects serialized with LDK version 0.0.116 and before.
 */
bool RouteHop_get_maybe_announced_channel(const struct LDKRouteHop *NONNULL_PTR this_ptr);

/**
 * Indicates whether this hop is possibly announced in the public network graph.
 *
 * Will be `true` if there is a possibility that the channel is publicly known, i.e., if we
 * either know for sure it's announced in the public graph, or if any public channels exist
 * for which the given `short_channel_id` could be an alias for. Will be `false` if we believe
 * the channel to be unannounced.
 *
 * Will be `true` for objects serialized with LDK version 0.0.116 and before.
 */
void RouteHop_set_maybe_announced_channel(struct LDKRouteHop *NONNULL_PTR this_ptr, bool val);

/**
 * Constructs a new RouteHop given each field
 */
MUST_USE_RES struct LDKRouteHop RouteHop_new(struct LDKPublicKey pubkey_arg, struct LDKNodeFeatures node_features_arg, uint64_t short_channel_id_arg, struct LDKChannelFeatures channel_features_arg, uint64_t fee_msat_arg, uint32_t cltv_expiry_delta_arg, bool maybe_announced_channel_arg);

/**
 * Creates a copy of the RouteHop
 */
struct LDKRouteHop RouteHop_clone(const struct LDKRouteHop *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RouteHop.
 */
uint64_t RouteHop_hash(const struct LDKRouteHop *NONNULL_PTR o);

/**
 * Checks if two RouteHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHop_eq(const struct LDKRouteHop *NONNULL_PTR a, const struct LDKRouteHop *NONNULL_PTR b);

/**
 * Serialize the RouteHop object into a byte array which can be read by RouteHop_read
 */
struct LDKCVec_u8Z RouteHop_write(const struct LDKRouteHop *NONNULL_PTR obj);

/**
 * Read a RouteHop from a byte array, created by RouteHop_write
 */
struct LDKCResult_RouteHopDecodeErrorZ RouteHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the BlindedTail, if is_owned is set and inner is non-NULL.
 */
void BlindedTail_free(struct LDKBlindedTail this_obj);

/**
 * The hops of the [`BlindedPath`] provided by the recipient.
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
struct LDKCVec_BlindedHopZ BlindedTail_get_hops(const struct LDKBlindedTail *NONNULL_PTR this_ptr);

/**
 * The hops of the [`BlindedPath`] provided by the recipient.
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
void BlindedTail_set_hops(struct LDKBlindedTail *NONNULL_PTR this_ptr, struct LDKCVec_BlindedHopZ val);

/**
 * The blinding point of the [`BlindedPath`] provided by the recipient.
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
struct LDKPublicKey BlindedTail_get_blinding_point(const struct LDKBlindedTail *NONNULL_PTR this_ptr);

/**
 * The blinding point of the [`BlindedPath`] provided by the recipient.
 *
 * [`BlindedPath`]: crate::blinded_path::BlindedPath
 */
void BlindedTail_set_blinding_point(struct LDKBlindedTail *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Excess CLTV delta added to the recipient's CLTV expiry to deter intermediate nodes from
 * inferring the destination. May be 0.
 */
uint32_t BlindedTail_get_excess_final_cltv_expiry_delta(const struct LDKBlindedTail *NONNULL_PTR this_ptr);

/**
 * Excess CLTV delta added to the recipient's CLTV expiry to deter intermediate nodes from
 * inferring the destination. May be 0.
 */
void BlindedTail_set_excess_final_cltv_expiry_delta(struct LDKBlindedTail *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The total amount paid on this [`Path`], excluding the fees.
 */
uint64_t BlindedTail_get_final_value_msat(const struct LDKBlindedTail *NONNULL_PTR this_ptr);

/**
 * The total amount paid on this [`Path`], excluding the fees.
 */
void BlindedTail_set_final_value_msat(struct LDKBlindedTail *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new BlindedTail given each field
 */
MUST_USE_RES struct LDKBlindedTail BlindedTail_new(struct LDKCVec_BlindedHopZ hops_arg, struct LDKPublicKey blinding_point_arg, uint32_t excess_final_cltv_expiry_delta_arg, uint64_t final_value_msat_arg);

/**
 * Creates a copy of the BlindedTail
 */
struct LDKBlindedTail BlindedTail_clone(const struct LDKBlindedTail *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the BlindedTail.
 */
uint64_t BlindedTail_hash(const struct LDKBlindedTail *NONNULL_PTR o);

/**
 * Checks if two BlindedTails contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BlindedTail_eq(const struct LDKBlindedTail *NONNULL_PTR a, const struct LDKBlindedTail *NONNULL_PTR b);

/**
 * Serialize the BlindedTail object into a byte array which can be read by BlindedTail_read
 */
struct LDKCVec_u8Z BlindedTail_write(const struct LDKBlindedTail *NONNULL_PTR obj);

/**
 * Read a BlindedTail from a byte array, created by BlindedTail_write
 */
struct LDKCResult_BlindedTailDecodeErrorZ BlindedTail_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Path, if is_owned is set and inner is non-NULL.
 */
void Path_free(struct LDKPath this_obj);

/**
 * The list of unblinded hops in this [`Path`]. Must be at least length one.
 */
struct LDKCVec_RouteHopZ Path_get_hops(const struct LDKPath *NONNULL_PTR this_ptr);

/**
 * The list of unblinded hops in this [`Path`]. Must be at least length one.
 */
void Path_set_hops(struct LDKPath *NONNULL_PTR this_ptr, struct LDKCVec_RouteHopZ val);

/**
 * The blinded path at which this path terminates, if we're sending to one, and its metadata.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKBlindedTail Path_get_blinded_tail(const struct LDKPath *NONNULL_PTR this_ptr);

/**
 * The blinded path at which this path terminates, if we're sending to one, and its metadata.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void Path_set_blinded_tail(struct LDKPath *NONNULL_PTR this_ptr, struct LDKBlindedTail val);

/**
 * Constructs a new Path given each field
 *
 * Note that blinded_tail_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPath Path_new(struct LDKCVec_RouteHopZ hops_arg, struct LDKBlindedTail blinded_tail_arg);

/**
 * Creates a copy of the Path
 */
struct LDKPath Path_clone(const struct LDKPath *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Path.
 */
uint64_t Path_hash(const struct LDKPath *NONNULL_PTR o);

/**
 * Checks if two Paths contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Path_eq(const struct LDKPath *NONNULL_PTR a, const struct LDKPath *NONNULL_PTR b);

/**
 * Gets the fees for a given path, excluding any excess paid to the recipient.
 */
MUST_USE_RES uint64_t Path_fee_msat(const struct LDKPath *NONNULL_PTR this_arg);

/**
 * Gets the total amount paid on this [`Path`], excluding the fees.
 */
MUST_USE_RES uint64_t Path_final_value_msat(const struct LDKPath *NONNULL_PTR this_arg);

/**
 * Gets the final hop's CLTV expiry delta.
 */
MUST_USE_RES struct LDKCOption_u32Z Path_final_cltv_expiry_delta(const struct LDKPath *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the Route, if is_owned is set and inner is non-NULL.
 */
void Route_free(struct LDKRoute this_obj);

/**
 * The list of [`Path`]s taken for a single (potentially-)multi-part payment. If no
 * [`BlindedTail`]s are present, then the pubkey of the last [`RouteHop`] in each path must be
 * the same.
 */
struct LDKCVec_PathZ Route_get_paths(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The list of [`Path`]s taken for a single (potentially-)multi-part payment. If no
 * [`BlindedTail`]s are present, then the pubkey of the last [`RouteHop`] in each path must be
 * the same.
 */
void Route_set_paths(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKCVec_PathZ val);

/**
 * The `route_params` parameter passed to [`find_route`].
 *
 * This is used by `ChannelManager` to track information which may be required for retries.
 *
 * Will be `None` for objects serialized with LDK versions prior to 0.0.117.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKRouteParameters Route_get_route_params(const struct LDKRoute *NONNULL_PTR this_ptr);

/**
 * The `route_params` parameter passed to [`find_route`].
 *
 * This is used by `ChannelManager` to track information which may be required for retries.
 *
 * Will be `None` for objects serialized with LDK versions prior to 0.0.117.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void Route_set_route_params(struct LDKRoute *NONNULL_PTR this_ptr, struct LDKRouteParameters val);

/**
 * Constructs a new Route given each field
 *
 * Note that route_params_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKRoute Route_new(struct LDKCVec_PathZ paths_arg, struct LDKRouteParameters route_params_arg);

/**
 * Creates a copy of the Route
 */
struct LDKRoute Route_clone(const struct LDKRoute *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Route.
 */
uint64_t Route_hash(const struct LDKRoute *NONNULL_PTR o);

/**
 * Checks if two Routes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Route_eq(const struct LDKRoute *NONNULL_PTR a, const struct LDKRoute *NONNULL_PTR b);

/**
 * Returns the total amount of fees paid on this [`Route`].
 *
 * For objects serialized with LDK 0.0.117 and after, this includes any extra payment made to
 * the recipient, which can happen in excess of the amount passed to [`find_route`] via
 * [`RouteParameters::final_value_msat`], if we had to reach the [`htlc_minimum_msat`] limits.
 *
 * [`htlc_minimum_msat`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
 */
MUST_USE_RES uint64_t Route_get_total_fees(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Returns the total amount paid on this [`Route`], excluding the fees.
 *
 * Might be more than requested as part of the given [`RouteParameters::final_value_msat`] if
 * we had to reach the [`htlc_minimum_msat`] limits.
 *
 * [`htlc_minimum_msat`]: https://github.com/lightning/bolts/blob/master/07-routing-gossip.md#the-channel_update-message
 */
MUST_USE_RES uint64_t Route_get_total_amount(const struct LDKRoute *NONNULL_PTR this_arg);

/**
 * Serialize the Route object into a byte array which can be read by Route_read
 */
struct LDKCVec_u8Z Route_write(const struct LDKRoute *NONNULL_PTR obj);

/**
 * Read a Route from a byte array, created by Route_write
 */
struct LDKCResult_RouteDecodeErrorZ Route_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteParameters, if is_owned is set and inner is non-NULL.
 */
void RouteParameters_free(struct LDKRouteParameters this_obj);

/**
 * The parameters of the failed payment path.
 */
struct LDKPaymentParameters RouteParameters_get_payment_params(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The parameters of the failed payment path.
 */
void RouteParameters_set_payment_params(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKPaymentParameters val);

/**
 * The amount in msats sent on the failed payment path.
 */
uint64_t RouteParameters_get_final_value_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The amount in msats sent on the failed payment path.
 */
void RouteParameters_set_final_value_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The maximum total fees, in millisatoshi, that may accrue during route finding.
 *
 * This limit also applies to the total fees that may arise while retrying failed payment
 * paths.
 *
 * Note that values below a few sats may result in some paths being spuriously ignored.
 */
struct LDKCOption_u64Z RouteParameters_get_max_total_routing_fee_msat(const struct LDKRouteParameters *NONNULL_PTR this_ptr);

/**
 * The maximum total fees, in millisatoshi, that may accrue during route finding.
 *
 * This limit also applies to the total fees that may arise while retrying failed payment
 * paths.
 *
 * Note that values below a few sats may result in some paths being spuriously ignored.
 */
void RouteParameters_set_max_total_routing_fee_msat(struct LDKRouteParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new RouteParameters given each field
 */
MUST_USE_RES struct LDKRouteParameters RouteParameters_new(struct LDKPaymentParameters payment_params_arg, uint64_t final_value_msat_arg, struct LDKCOption_u64Z max_total_routing_fee_msat_arg);

/**
 * Creates a copy of the RouteParameters
 */
struct LDKRouteParameters RouteParameters_clone(const struct LDKRouteParameters *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RouteParameters.
 */
uint64_t RouteParameters_hash(const struct LDKRouteParameters *NONNULL_PTR o);

/**
 * Checks if two RouteParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteParameters_eq(const struct LDKRouteParameters *NONNULL_PTR a, const struct LDKRouteParameters *NONNULL_PTR b);

/**
 * Constructs [`RouteParameters`] from the given [`PaymentParameters`] and a payment amount.
 *
 * [`Self::max_total_routing_fee_msat`] defaults to 1% of the payment amount + 50 sats
 */
MUST_USE_RES struct LDKRouteParameters RouteParameters_from_payment_params_and_value(struct LDKPaymentParameters payment_params, uint64_t final_value_msat);

/**
 * Serialize the RouteParameters object into a byte array which can be read by RouteParameters_read
 */
struct LDKCVec_u8Z RouteParameters_write(const struct LDKRouteParameters *NONNULL_PTR obj);

/**
 * Read a RouteParameters from a byte array, created by RouteParameters_write
 */
struct LDKCResult_RouteParametersDecodeErrorZ RouteParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PaymentParameters, if is_owned is set and inner is non-NULL.
 */
void PaymentParameters_free(struct LDKPaymentParameters this_obj);

/**
 * Information about the payee, such as their features and route hints for their channels.
 */
struct LDKPayee PaymentParameters_get_payee(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Information about the payee, such as their features and route hints for their channels.
 */
void PaymentParameters_set_payee(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKPayee val);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
struct LDKCOption_u64Z PaymentParameters_get_expiry_time(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Expiration of a payment to the payee, in seconds relative to the UNIX epoch.
 */
void PaymentParameters_set_expiry_time(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum total CLTV delta we accept for the route.
 * Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
 */
uint32_t PaymentParameters_get_max_total_cltv_expiry_delta(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The maximum total CLTV delta we accept for the route.
 * Defaults to [`DEFAULT_MAX_TOTAL_CLTV_EXPIRY_DELTA`].
 */
void PaymentParameters_set_max_total_cltv_expiry_delta(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The maximum number of paths that may be used by (MPP) payments.
 * Defaults to [`DEFAULT_MAX_PATH_COUNT`].
 */
uint8_t PaymentParameters_get_max_path_count(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * The maximum number of paths that may be used by (MPP) payments.
 * Defaults to [`DEFAULT_MAX_PATH_COUNT`].
 */
void PaymentParameters_set_max_path_count(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);

/**
 * Selects the maximum share of a channel's total capacity which will be sent over a channel,
 * as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
 * a lower value prefers to send larger MPP parts, potentially saturating channels and
 * increasing failure probability for those paths.
 *
 * Note that this restriction will be relaxed during pathfinding after paths which meet this
 * restriction have been found. While paths which meet this criteria will be searched for, it
 * is ultimately up to the scorer to select them over other paths.
 *
 * A value of 0 will allow payments up to and including a channel's total announced usable
 * capacity, a value of one will only use up to half its capacity, two 1/4, etc.
 *
 * Default value: 2
 */
uint8_t PaymentParameters_get_max_channel_saturation_power_of_half(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * Selects the maximum share of a channel's total capacity which will be sent over a channel,
 * as a power of 1/2. A higher value prefers to send the payment using more MPP parts whereas
 * a lower value prefers to send larger MPP parts, potentially saturating channels and
 * increasing failure probability for those paths.
 *
 * Note that this restriction will be relaxed during pathfinding after paths which meet this
 * restriction have been found. While paths which meet this criteria will be searched for, it
 * is ultimately up to the scorer to select them over other paths.
 *
 * A value of 0 will allow payments up to and including a channel's total announced usable
 * capacity, a value of one will only use up to half its capacity, two 1/4, etc.
 *
 * Default value: 2
 */
void PaymentParameters_set_max_channel_saturation_power_of_half(struct LDKPaymentParameters *NONNULL_PTR this_ptr, uint8_t val);

/**
 * A list of SCIDs which this payment was previously attempted over and which caused the
 * payment to fail. Future attempts for the same payment shouldn't be relayed through any of
 * these SCIDs.
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u64Z PaymentParameters_get_previously_failed_channels(const struct LDKPaymentParameters *NONNULL_PTR this_ptr);

/**
 * A list of SCIDs which this payment was previously attempted over and which caused the
 * payment to fail. Future attempts for the same payment shouldn't be relayed through any of
 * these SCIDs.
 */
void PaymentParameters_set_previously_failed_channels(struct LDKPaymentParameters *NONNULL_PTR this_ptr, struct LDKCVec_u64Z val);

/**
 * Constructs a new PaymentParameters given each field
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_new(struct LDKPayee payee_arg, struct LDKCOption_u64Z expiry_time_arg, uint32_t max_total_cltv_expiry_delta_arg, uint8_t max_path_count_arg, uint8_t max_channel_saturation_power_of_half_arg, struct LDKCVec_u64Z previously_failed_channels_arg);

/**
 * Creates a copy of the PaymentParameters
 */
struct LDKPaymentParameters PaymentParameters_clone(const struct LDKPaymentParameters *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the PaymentParameters.
 */
uint64_t PaymentParameters_hash(const struct LDKPaymentParameters *NONNULL_PTR o);

/**
 * Checks if two PaymentParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PaymentParameters_eq(const struct LDKPaymentParameters *NONNULL_PTR a, const struct LDKPaymentParameters *NONNULL_PTR b);

/**
 * Serialize the PaymentParameters object into a byte array which can be read by PaymentParameters_read
 */
struct LDKCVec_u8Z PaymentParameters_write(const struct LDKPaymentParameters *NONNULL_PTR obj);

/**
 * Read a PaymentParameters from a byte array, created by PaymentParameters_write
 */
struct LDKCResult_PaymentParametersDecodeErrorZ PaymentParameters_read(struct LDKu8slice ser, uint32_t arg);

/**
 * Creates a payee with the node id of the given `pubkey`.
 *
 * The `final_cltv_expiry_delta` should match the expected final CLTV delta the recipient has
 * provided.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_node_id(struct LDKPublicKey payee_pubkey, uint32_t final_cltv_expiry_delta);

/**
 * Creates a payee with the node id of the given `pubkey` to use for keysend payments.
 *
 * The `final_cltv_expiry_delta` should match the expected final CLTV delta the recipient has
 * provided.
 *
 * Note that MPP keysend is not widely supported yet. The `allow_mpp` lets you choose
 * whether your router will be allowed to find a multi-part route for this payment. If you
 * set `allow_mpp` to true, you should ensure a payment secret is set on send, likely via
 * [`RecipientOnionFields::secret_only`].
 *
 * [`RecipientOnionFields::secret_only`]: crate::ln::channelmanager::RecipientOnionFields::secret_only
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_for_keysend(struct LDKPublicKey payee_pubkey, uint32_t final_cltv_expiry_delta, bool allow_mpp);

/**
 * Creates parameters for paying to a blinded payee from the provided invoice. Sets
 * [`Payee::Blinded::route_hints`], [`Payee::Blinded::features`], and
 * [`PaymentParameters::expiry_time`].
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_from_bolt12_invoice(const struct LDKBolt12Invoice *NONNULL_PTR invoice);

/**
 * Creates parameters for paying to a blinded payee from the provided blinded route hints.
 */
MUST_USE_RES struct LDKPaymentParameters PaymentParameters_blinded(struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ blinded_route_hints);

/**
 * Frees any resources used by the Payee
 */
void Payee_free(struct LDKPayee this_ptr);

/**
 * Creates a copy of the Payee
 */
struct LDKPayee Payee_clone(const struct LDKPayee *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Blinded-variant Payee
 */
struct LDKPayee Payee_blinded(struct LDKCVec_C2Tuple_BlindedPayInfoBlindedPathZZ route_hints, struct LDKBolt12InvoiceFeatures features);

/**
 * Utility method to constructs a new Clear-variant Payee
 */
struct LDKPayee Payee_clear(struct LDKPublicKey node_id, struct LDKCVec_RouteHintZ route_hints, struct LDKBolt11InvoiceFeatures features, uint32_t final_cltv_expiry_delta);

/**
 * Generates a non-cryptographic 64-bit hash of the Payee.
 */
uint64_t Payee_hash(const struct LDKPayee *NONNULL_PTR o);

/**
 * Checks if two Payees contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Payee_eq(const struct LDKPayee *NONNULL_PTR a, const struct LDKPayee *NONNULL_PTR b);

/**
 * Frees any resources used by the RouteHint, if is_owned is set and inner is non-NULL.
 */
void RouteHint_free(struct LDKRouteHint this_obj);

struct LDKCVec_RouteHintHopZ RouteHint_get_a(const struct LDKRouteHint *NONNULL_PTR this_ptr);

void RouteHint_set_a(struct LDKRouteHint *NONNULL_PTR this_ptr, struct LDKCVec_RouteHintHopZ val);

/**
 * Constructs a new RouteHint given each field
 */
MUST_USE_RES struct LDKRouteHint RouteHint_new(struct LDKCVec_RouteHintHopZ a_arg);

/**
 * Creates a copy of the RouteHint
 */
struct LDKRouteHint RouteHint_clone(const struct LDKRouteHint *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RouteHint.
 */
uint64_t RouteHint_hash(const struct LDKRouteHint *NONNULL_PTR o);

/**
 * Checks if two RouteHints contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHint_eq(const struct LDKRouteHint *NONNULL_PTR a, const struct LDKRouteHint *NONNULL_PTR b);

/**
 * Serialize the RouteHint object into a byte array which can be read by RouteHint_read
 */
struct LDKCVec_u8Z RouteHint_write(const struct LDKRouteHint *NONNULL_PTR obj);

/**
 * Read a RouteHint from a byte array, created by RouteHint_write
 */
struct LDKCResult_RouteHintDecodeErrorZ RouteHint_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the RouteHintHop, if is_owned is set and inner is non-NULL.
 */
void RouteHintHop_free(struct LDKRouteHintHop this_obj);

/**
 * The node_id of the non-target end of the route
 */
struct LDKPublicKey RouteHintHop_get_src_node_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The node_id of the non-target end of the route
 */
void RouteHintHop_set_src_node_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The short_channel_id of this channel
 */
uint64_t RouteHintHop_get_short_channel_id(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The short_channel_id of this channel
 */
void RouteHintHop_set_short_channel_id(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The fees which must be paid to use this channel
 */
struct LDKRoutingFees RouteHintHop_get_fees(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The fees which must be paid to use this channel
 */
void RouteHintHop_set_fees(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKRoutingFees val);

/**
 * The difference in CLTV values between this node and the next node.
 */
uint16_t RouteHintHop_get_cltv_expiry_delta(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The difference in CLTV values between this node and the next node.
 */
void RouteHintHop_set_cltv_expiry_delta(struct LDKRouteHintHop *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_minimum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The minimum value, in msat, which must be relayed to the next hop.
 */
void RouteHintHop_set_htlc_minimum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
struct LDKCOption_u64Z RouteHintHop_get_htlc_maximum_msat(const struct LDKRouteHintHop *NONNULL_PTR this_ptr);

/**
 * The maximum value in msat available for routing with a single HTLC.
 */
void RouteHintHop_set_htlc_maximum_msat(struct LDKRouteHintHop *NONNULL_PTR this_ptr, struct LDKCOption_u64Z val);

/**
 * Constructs a new RouteHintHop given each field
 */
MUST_USE_RES struct LDKRouteHintHop RouteHintHop_new(struct LDKPublicKey src_node_id_arg, uint64_t short_channel_id_arg, struct LDKRoutingFees fees_arg, uint16_t cltv_expiry_delta_arg, struct LDKCOption_u64Z htlc_minimum_msat_arg, struct LDKCOption_u64Z htlc_maximum_msat_arg);

/**
 * Creates a copy of the RouteHintHop
 */
struct LDKRouteHintHop RouteHintHop_clone(const struct LDKRouteHintHop *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RouteHintHop.
 */
uint64_t RouteHintHop_hash(const struct LDKRouteHintHop *NONNULL_PTR o);

/**
 * Checks if two RouteHintHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RouteHintHop_eq(const struct LDKRouteHintHop *NONNULL_PTR a, const struct LDKRouteHintHop *NONNULL_PTR b);

/**
 * Serialize the RouteHintHop object into a byte array which can be read by RouteHintHop_read
 */
struct LDKCVec_u8Z RouteHintHop_write(const struct LDKRouteHintHop *NONNULL_PTR obj);

/**
 * Read a RouteHintHop from a byte array, created by RouteHintHop_write
 */
struct LDKCResult_RouteHintHopDecodeErrorZ RouteHintHop_read(struct LDKu8slice ser);

/**
 * Finds a route from us (payer) to the given target node (payee).
 *
 * If the payee provided features in their invoice, they should be provided via the `payee` field
 * in the given [`RouteParameters::payment_params`].
 * Without this, MPP will only be used if the payee's features are available in the network graph.
 *
 * Private routing paths between a public node and the target may be included in the `payee` field
 * of [`RouteParameters::payment_params`].
 *
 * If some channels aren't announced, it may be useful to fill in `first_hops` with the results
 * from [`ChannelManager::list_usable_channels`]. If it is filled in, the view of these channels
 * from `network_graph` will be ignored, and only those in `first_hops` will be used.
 *
 * The fees on channels from us to the next hop are ignored as they are assumed to all be equal.
 * However, the enabled/disabled bit on such channels as well as the `htlc_minimum_msat` /
 * `htlc_maximum_msat` *are* checked as they may change based on the receiving node.
 *
 * # Panics
 *
 * Panics if first_hops contains channels without `short_channel_id`s;
 * [`ChannelManager::list_usable_channels`] will never include such channels.
 *
 * [`ChannelManager::list_usable_channels`]: crate::ln::channelmanager::ChannelManager::list_usable_channels
 * [`Event::PaymentPathFailed`]: crate::events::Event::PaymentPathFailed
 * [`NetworkGraph`]: crate::routing::gossip::NetworkGraph
 *
 * Note that first_hops (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_RouteLightningErrorZ find_route(struct LDKPublicKey our_node_pubkey, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKCVec_ChannelDetailsZ *first_hops, struct LDKLogger logger, const struct LDKScoreLookUp *NONNULL_PTR scorer, const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR score_params, const uint8_t (*random_seed_bytes)[32]);

/**
 * Construct a route from us (payer) to the target node (payee) via the given hops (which should
 * exclude the payer, but include the payee). This may be useful, e.g., for probing the chosen path.
 *
 * Re-uses logic from `find_route`, so the restrictions described there also apply here.
 */
struct LDKCResult_RouteLightningErrorZ build_route_from_hops(struct LDKPublicKey our_node_pubkey, struct LDKCVec_PublicKeyZ hops, const struct LDKRouteParameters *NONNULL_PTR route_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger, const uint8_t (*random_seed_bytes)[32]);

/**
 * Calls the free function if one is set
 */
void ScoreLookUp_free(struct LDKScoreLookUp this_ptr);

/**
 * Calls the free function if one is set
 */
void ScoreUpdate_free(struct LDKScoreUpdate this_ptr);

/**
 * Calls the free function if one is set
 */
void Score_free(struct LDKScore this_ptr);

/**
 * Calls the free function if one is set
 */
void LockableScore_free(struct LDKLockableScore this_ptr);

/**
 * Calls the free function if one is set
 */
void WriteableScore_free(struct LDKWriteableScore this_ptr);

/**
 * Frees any resources used by the MultiThreadedLockableScore, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedLockableScore_free(struct LDKMultiThreadedLockableScore this_obj);

/**
 * Constructs a new LockableScore which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned LockableScore must be freed before this_arg is
 */
struct LDKLockableScore MultiThreadedLockableScore_as_LockableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);

/**
 * Serialize the MultiThreadedLockableScore object into a byte array which can be read by MultiThreadedLockableScore_read
 */
struct LDKCVec_u8Z MultiThreadedLockableScore_write(const struct LDKMultiThreadedLockableScore *NONNULL_PTR obj);

/**
 * Constructs a new WriteableScore which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned WriteableScore must be freed before this_arg is
 */
struct LDKWriteableScore MultiThreadedLockableScore_as_WriteableScore(const struct LDKMultiThreadedLockableScore *NONNULL_PTR this_arg);

/**
 * Creates a new [`MultiThreadedLockableScore`] given an underlying [`Score`].
 */
MUST_USE_RES struct LDKMultiThreadedLockableScore MultiThreadedLockableScore_new(struct LDKScore score);

/**
 * Frees any resources used by the MultiThreadedScoreLockRead, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedScoreLockRead_free(struct LDKMultiThreadedScoreLockRead this_obj);

/**
 * Frees any resources used by the MultiThreadedScoreLockWrite, if is_owned is set and inner is non-NULL.
 */
void MultiThreadedScoreLockWrite_free(struct LDKMultiThreadedScoreLockWrite this_obj);

/**
 * Constructs a new ScoreLookUp which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreLookUp must be freed before this_arg is
 */
struct LDKScoreLookUp MultiThreadedScoreLockRead_as_ScoreLookUp(const struct LDKMultiThreadedScoreLockRead *NONNULL_PTR this_arg);

/**
 * Serialize the MultiThreadedScoreLockWrite object into a byte array which can be read by MultiThreadedScoreLockWrite_read
 */
struct LDKCVec_u8Z MultiThreadedScoreLockWrite_write(const struct LDKMultiThreadedScoreLockWrite *NONNULL_PTR obj);

/**
 * Constructs a new ScoreUpdate which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreUpdate must be freed before this_arg is
 */
struct LDKScoreUpdate MultiThreadedScoreLockWrite_as_ScoreUpdate(const struct LDKMultiThreadedScoreLockWrite *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ChannelUsage, if is_owned is set and inner is non-NULL.
 */
void ChannelUsage_free(struct LDKChannelUsage this_obj);

/**
 * The amount to send through the channel, denominated in millisatoshis.
 */
uint64_t ChannelUsage_get_amount_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * The amount to send through the channel, denominated in millisatoshis.
 */
void ChannelUsage_set_amount_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Total amount, denominated in millisatoshis, already allocated to send through the channel
 * as part of a multi-path payment.
 */
uint64_t ChannelUsage_get_inflight_htlc_msat(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * Total amount, denominated in millisatoshis, already allocated to send through the channel
 * as part of a multi-path payment.
 */
void ChannelUsage_set_inflight_htlc_msat(struct LDKChannelUsage *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The effective capacity of the channel.
 */
struct LDKEffectiveCapacity ChannelUsage_get_effective_capacity(const struct LDKChannelUsage *NONNULL_PTR this_ptr);

/**
 * The effective capacity of the channel.
 */
void ChannelUsage_set_effective_capacity(struct LDKChannelUsage *NONNULL_PTR this_ptr, struct LDKEffectiveCapacity val);

/**
 * Constructs a new ChannelUsage given each field
 */
MUST_USE_RES struct LDKChannelUsage ChannelUsage_new(uint64_t amount_msat_arg, uint64_t inflight_htlc_msat_arg, struct LDKEffectiveCapacity effective_capacity_arg);

/**
 * Creates a copy of the ChannelUsage
 */
struct LDKChannelUsage ChannelUsage_clone(const struct LDKChannelUsage *NONNULL_PTR orig);

/**
 * Frees any resources used by the FixedPenaltyScorer, if is_owned is set and inner is non-NULL.
 */
void FixedPenaltyScorer_free(struct LDKFixedPenaltyScorer this_obj);

/**
 * Creates a copy of the FixedPenaltyScorer
 */
struct LDKFixedPenaltyScorer FixedPenaltyScorer_clone(const struct LDKFixedPenaltyScorer *NONNULL_PTR orig);

/**
 * Creates a new scorer using `penalty_msat`.
 */
MUST_USE_RES struct LDKFixedPenaltyScorer FixedPenaltyScorer_with_penalty(uint64_t penalty_msat);

/**
 * Constructs a new ScoreLookUp which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreLookUp must be freed before this_arg is
 */
struct LDKScoreLookUp FixedPenaltyScorer_as_ScoreLookUp(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);

/**
 * Constructs a new ScoreUpdate which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreUpdate must be freed before this_arg is
 */
struct LDKScoreUpdate FixedPenaltyScorer_as_ScoreUpdate(const struct LDKFixedPenaltyScorer *NONNULL_PTR this_arg);

/**
 * Serialize the FixedPenaltyScorer object into a byte array which can be read by FixedPenaltyScorer_read
 */
struct LDKCVec_u8Z FixedPenaltyScorer_write(const struct LDKFixedPenaltyScorer *NONNULL_PTR obj);

/**
 * Read a FixedPenaltyScorer from a byte array, created by FixedPenaltyScorer_write
 */
struct LDKCResult_FixedPenaltyScorerDecodeErrorZ FixedPenaltyScorer_read(struct LDKu8slice ser, uint64_t arg);

/**
 * Frees any resources used by the ProbabilisticScorer, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScorer_free(struct LDKProbabilisticScorer this_obj);

/**
 * Frees any resources used by the ProbabilisticScoringFeeParameters, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScoringFeeParameters_free(struct LDKProbabilisticScoringFeeParameters this_obj);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_base_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A fixed penalty in msats to apply to each channel.
 *
 * Default value: 500 msat
 */
void ProbabilisticScoringFeeParameters_set_base_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used with the total amount flowing over a channel to calculate a fixed penalty
 * applied to each channel, in excess of the [`base_penalty_msat`].
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^30`ths of the total amount flowing over a channel (i.e. the payment
 * amount plus the amount of any other HTLCs flowing we sent over the same channel).
 *
 * ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
 *
 * Default value: 8,192 msat
 *
 * [`base_penalty_msat`]: Self::base_penalty_msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_base_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used with the total amount flowing over a channel to calculate a fixed penalty
 * applied to each channel, in excess of the [`base_penalty_msat`].
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^30`ths of the total amount flowing over a channel (i.e. the payment
 * amount plus the amount of any other HTLCs flowing we sent over the same channel).
 *
 * ie `base_penalty_amount_multiplier_msat * amount_msat / 2^30`
 *
 * Default value: 8,192 msat
 *
 * [`base_penalty_msat`]: Self::base_penalty_msat
 */
void ProbabilisticScoringFeeParameters_set_base_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment, as determined by our latest estimates of the channel's
 * liquidity, to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * `-log10(success_probability) * liquidity_penalty_multiplier_msat`
 *
 * Default value: 30,000 msat
 *
 * [`liquidity_offset_half_life`]: ProbabilisticScoringDecayParameters::liquidity_offset_half_life
 */
uint64_t ProbabilisticScoringFeeParameters_get_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for a payment, as determined by our latest estimates of the channel's
 * liquidity, to determine the liquidity penalty.
 *
 * The penalty is based in part on the knowledge learned from prior successful and unsuccessful
 * payments. This knowledge is decayed over time based on [`liquidity_offset_half_life`]. The
 * penalty is effectively limited to `2 * liquidity_penalty_multiplier_msat` (corresponding to
 * lower bounding the success probability to `0.01`) when the amount falls within the
 * uncertainty bounds of the channel liquidity balance. Amounts above the upper bound will
 * result in a `u64::max_value` penalty, however.
 *
 * `-log10(success_probability) * liquidity_penalty_multiplier_msat`
 *
 * Default value: 30,000 msat
 *
 * [`liquidity_offset_half_life`]: ProbabilisticScoringDecayParameters::liquidity_offset_half_life
 */
void ProbabilisticScoringFeeParameters_set_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the total amount flowing over a channel and the
 * negative `log10` of the channel's success probability for the payment, as determined by our
 * latest estimates of the channel's liquidity, to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the amount flowing over this channel, weighted by the negative
 * `log10` of the success probability.
 *
 * `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 192 msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the total amount flowing over a channel and the
 * negative `log10` of the channel's success probability for the payment, as determined by our
 * latest estimates of the channel's liquidity, to determine the amount penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost (i.e.,
 * fees plus penalty) for large payments. The penalty is computed as the product of this
 * multiplier and `2^20`ths of the amount flowing over this channel, weighted by the negative
 * `log10` of the success probability.
 *
 * `-log10(success_probability) * liquidity_penalty_amount_multiplier_msat * amount_msat / 2^20`
 *
 * In practice, this means for 0.1 success probability (`-log10(0.1) == 1`) each `2^20`th of
 * the amount will result in a penalty of the multiplier. And, as the success probability
 * decreases, the negative `log10` weighting will increase dramatically. For higher success
 * probabilities, the multiplier will have a decreasing effect as the negative `log10` will
 * fall below `1`.
 *
 * Default value: 192 msat
 */
void ProbabilisticScoringFeeParameters_set_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for the payment, as determined based on the history of our estimates of the
 * channel's available liquidity, to determine a penalty.
 *
 * This penalty is similar to [`liquidity_penalty_multiplier_msat`], however, instead of using
 * only our latest estimate for the current liquidity available in the channel, it estimates
 * success probability based on the estimated liquidity available in the channel through
 * history. Specifically, every time we update our liquidity bounds on a given channel, we
 * track which of several buckets those bounds fall into, exponentially decaying the
 * probability of each bucket as new samples are added.
 *
 * Default value: 10,000 msat
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the negative `log10` of the channel's success
 * probability for the payment, as determined based on the history of our estimates of the
 * channel's available liquidity, to determine a penalty.
 *
 * This penalty is similar to [`liquidity_penalty_multiplier_msat`], however, instead of using
 * only our latest estimate for the current liquidity available in the channel, it estimates
 * success probability based on the estimated liquidity available in the channel through
 * history. Specifically, every time we update our liquidity bounds on a given channel, we
 * track which of several buckets those bounds fall into, exponentially decaying the
 * probability of each bucket as new samples are added.
 *
 * Default value: 10,000 msat
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 */
void ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * A multiplier used in conjunction with the total amount flowing over a channel and the
 * negative `log10` of the channel's success probability for the payment, as determined based
 * on the history of our estimates of the channel's available liquidity, to determine a
 * penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost for
 * large payments. The penalty is computed as the product of this multiplier and `2^20`ths
 * of the amount flowing over this channel, weighted by the negative `log10` of the success
 * probability.
 *
 * This penalty is similar to [`liquidity_penalty_amount_multiplier_msat`], however, instead
 * of using only our latest estimate for the current liquidity available in the channel, it
 * estimates success probability based on the estimated liquidity available in the channel
 * through history. Specifically, every time we update our liquidity bounds on a given
 * channel, we track which of several buckets those bounds fall into, exponentially decaying
 * the probability of each bucket as new samples are added.
 *
 * Default value: 64 msat
 *
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_historical_liquidity_penalty_amount_multiplier_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * A multiplier used in conjunction with the total amount flowing over a channel and the
 * negative `log10` of the channel's success probability for the payment, as determined based
 * on the history of our estimates of the channel's available liquidity, to determine a
 * penalty.
 *
 * The purpose of the amount penalty is to avoid having fees dominate the channel cost for
 * large payments. The penalty is computed as the product of this multiplier and `2^20`ths
 * of the amount flowing over this channel, weighted by the negative `log10` of the success
 * probability.
 *
 * This penalty is similar to [`liquidity_penalty_amount_multiplier_msat`], however, instead
 * of using only our latest estimate for the current liquidity available in the channel, it
 * estimates success probability based on the estimated liquidity available in the channel
 * through history. Specifically, every time we update our liquidity bounds on a given
 * channel, we track which of several buckets those bounds fall into, exponentially decaying
 * the probability of each bucket as new samples are added.
 *
 * Default value: 64 msat
 *
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 */
void ProbabilisticScoringFeeParameters_set_historical_liquidity_penalty_amount_multiplier_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
 * channel's capacity, (ie. htlc_maximum_msat >= 0.5 * channel_capacity) which makes us
 * prefer nodes with a smaller `htlc_maximum_msat`. We treat such nodes preferentially
 * as this makes balance discovery attacks harder to execute, thereby creating an incentive
 * to restrict `htlc_maximum_msat` and improve privacy.
 *
 * Default value: 250 msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_anti_probing_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * This penalty is applied when `htlc_maximum_msat` is equal to or larger than half of the
 * channel's capacity, (ie. htlc_maximum_msat >= 0.5 * channel_capacity) which makes us
 * prefer nodes with a smaller `htlc_maximum_msat`. We treat such nodes preferentially
 * as this makes balance discovery attacks harder to execute, thereby creating an incentive
 * to restrict `htlc_maximum_msat` and improve privacy.
 *
 * Default value: 250 msat
 */
void ProbabilisticScoringFeeParameters_set_anti_probing_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * This penalty is applied when the total amount flowing over a channel exceeds our current
 * estimate of the channel's available liquidity. The total amount is the amount of the
 * current HTLC plus any HTLCs which we've sent over the same channel.
 *
 * Note that in this case all other penalties, including the
 * [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
 * penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
 * applicable, are still included in the overall penalty.
 *
 * If you wish to avoid creating paths with such channels entirely, setting this to a value of
 * `u64::max_value()` will guarantee that.
 *
 * Default value: 1_0000_0000_000 msat (1 Bitcoin)
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 * [`base_penalty_msat`]: Self::base_penalty_msat
 * [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
 */
uint64_t ProbabilisticScoringFeeParameters_get_considered_impossible_penalty_msat(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * This penalty is applied when the total amount flowing over a channel exceeds our current
 * estimate of the channel's available liquidity. The total amount is the amount of the
 * current HTLC plus any HTLCs which we've sent over the same channel.
 *
 * Note that in this case all other penalties, including the
 * [`liquidity_penalty_multiplier_msat`] and [`liquidity_penalty_amount_multiplier_msat`]-based
 * penalties, as well as the [`base_penalty_msat`] and the [`anti_probing_penalty_msat`], if
 * applicable, are still included in the overall penalty.
 *
 * If you wish to avoid creating paths with such channels entirely, setting this to a value of
 * `u64::max_value()` will guarantee that.
 *
 * Default value: 1_0000_0000_000 msat (1 Bitcoin)
 *
 * [`liquidity_penalty_multiplier_msat`]: Self::liquidity_penalty_multiplier_msat
 * [`liquidity_penalty_amount_multiplier_msat`]: Self::liquidity_penalty_amount_multiplier_msat
 * [`base_penalty_msat`]: Self::base_penalty_msat
 * [`anti_probing_penalty_msat`]: Self::anti_probing_penalty_msat
 */
void ProbabilisticScoringFeeParameters_set_considered_impossible_penalty_msat(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * In order to calculate most of the scores above, we must first convert a lower and upper
 * bound on the available liquidity in a channel into the probability that we think a payment
 * will succeed. That probability is derived from a Probability Density Function for where we
 * think the liquidity in a channel likely lies, given such bounds.
 *
 * If this flag is set, that PDF is simply a constant - we assume that the actual available
 * liquidity in a channel is just as likely to be at any point between our lower and upper
 * bounds.
 *
 * If this flag is *not* set, that PDF is `(x - 0.5*capacity) ^ 2`. That is, we use an
 * exponential curve which expects the liquidity of a channel to lie \"at the edges\". This
 * matches experimental results - most routing nodes do not aggressively rebalance their
 * channels and flows in the network are often unbalanced, leaving liquidity usually
 * unavailable.
 *
 * Thus, for the \"best\" routes, leave this flag `false`. However, the flag does imply a number
 * of floating-point multiplications in the hottest routing code, which may lead to routing
 * performance degradation on some machines.
 *
 * Default value: false
 */
bool ProbabilisticScoringFeeParameters_get_linear_success_probability(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr);

/**
 * In order to calculate most of the scores above, we must first convert a lower and upper
 * bound on the available liquidity in a channel into the probability that we think a payment
 * will succeed. That probability is derived from a Probability Density Function for where we
 * think the liquidity in a channel likely lies, given such bounds.
 *
 * If this flag is set, that PDF is simply a constant - we assume that the actual available
 * liquidity in a channel is just as likely to be at any point between our lower and upper
 * bounds.
 *
 * If this flag is *not* set, that PDF is `(x - 0.5*capacity) ^ 2`. That is, we use an
 * exponential curve which expects the liquidity of a channel to lie \"at the edges\". This
 * matches experimental results - most routing nodes do not aggressively rebalance their
 * channels and flows in the network are often unbalanced, leaving liquidity usually
 * unavailable.
 *
 * Thus, for the \"best\" routes, leave this flag `false`. However, the flag does imply a number
 * of floating-point multiplications in the hottest routing code, which may lead to routing
 * performance degradation on some machines.
 *
 * Default value: false
 */
void ProbabilisticScoringFeeParameters_set_linear_success_probability(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_ptr, bool val);

/**
 * Creates a copy of the ProbabilisticScoringFeeParameters
 */
struct LDKProbabilisticScoringFeeParameters ProbabilisticScoringFeeParameters_clone(const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR orig);

/**
 * Creates a "default" ProbabilisticScoringFeeParameters. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKProbabilisticScoringFeeParameters ProbabilisticScoringFeeParameters_default(void);

/**
 * Marks the node with the given `node_id` as banned,
 * i.e it will be avoided during path finding.
 */
void ProbabilisticScoringFeeParameters_add_banned(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Marks all nodes in the given list as banned, i.e.,
 * they will be avoided during path finding.
 */
void ProbabilisticScoringFeeParameters_add_banned_from_list(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, struct LDKCVec_NodeIdZ node_ids);

/**
 * Removes the node with the given `node_id` from the list of nodes to avoid.
 */
void ProbabilisticScoringFeeParameters_remove_banned(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Sets a manual penalty for the given node.
 */
void ProbabilisticScoringFeeParameters_set_manual_penalty(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id, uint64_t penalty);

/**
 * Removes the node with the given `node_id` from the list of manual penalties.
 */
void ProbabilisticScoringFeeParameters_remove_manual_penalty(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg, const struct LDKNodeId *NONNULL_PTR node_id);

/**
 * Clears the list of manual penalties that are applied during path finding.
 */
void ProbabilisticScoringFeeParameters_clear_manual_penalties(struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the ProbabilisticScoringDecayParameters, if is_owned is set and inner is non-NULL.
 */
void ProbabilisticScoringDecayParameters_free(struct LDKProbabilisticScoringDecayParameters this_obj);

/**
 * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
 * tracking can simply live on with increasingly stale data. Instead, when a channel has not
 * seen a liquidity estimate update for this amount of time, the historical datapoints are
 * decayed by half.
 * For an example of historical_no_updates_half_life being used see [`historical_estimated_channel_liquidity_probabilities`]
 *
 * Note that after 16 or more half lives all historical data will be completely gone.
 *
 * Default value: 14 days
 *
 * [`historical_estimated_channel_liquidity_probabilities`]: ProbabilisticScorerUsingTime::historical_estimated_channel_liquidity_probabilities
 */
uint64_t ProbabilisticScoringDecayParameters_get_historical_no_updates_half_life(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr);

/**
 * If we aren't learning any new datapoints for a channel, the historical liquidity bounds
 * tracking can simply live on with increasingly stale data. Instead, when a channel has not
 * seen a liquidity estimate update for this amount of time, the historical datapoints are
 * decayed by half.
 * For an example of historical_no_updates_half_life being used see [`historical_estimated_channel_liquidity_probabilities`]
 *
 * Note that after 16 or more half lives all historical data will be completely gone.
 *
 * Default value: 14 days
 *
 * [`historical_estimated_channel_liquidity_probabilities`]: ProbabilisticScorerUsingTime::historical_estimated_channel_liquidity_probabilities
 */
void ProbabilisticScoringDecayParameters_set_historical_no_updates_half_life(struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
 * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
 * the available liquidity is halved and the upper-bound moves half-way to the channel's total
 * capacity.
 *
 * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
 * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
 * struct documentation for more info on the way the liquidity bounds are used.
 *
 * For example, if the channel's capacity is 1 million sats, and the current upper and lower
 * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
 * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
 *
 * Default value: 6 hours
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
uint64_t ProbabilisticScoringDecayParameters_get_liquidity_offset_half_life(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr);

/**
 * Whenever this amount of time elapses since the last update to a channel's liquidity bounds,
 * the distance from the bounds to \"zero\" is cut in half. In other words, the lower-bound on
 * the available liquidity is halved and the upper-bound moves half-way to the channel's total
 * capacity.
 *
 * Because halving the liquidity bounds grows the uncertainty on the channel's liquidity,
 * the penalty for an amount within the new bounds may change. See the [`ProbabilisticScorer`]
 * struct documentation for more info on the way the liquidity bounds are used.
 *
 * For example, if the channel's capacity is 1 million sats, and the current upper and lower
 * liquidity bounds are 200,000 sats and 600,000 sats, after this amount of time the upper
 * and lower liquidity bounds will be decayed to 100,000 and 800,000 sats.
 *
 * Default value: 6 hours
 *
 * # Note
 *
 * When built with the `no-std` feature, time will never elapse. Therefore, the channel
 * liquidity knowledge will never decay except when the bounds cross.
 */
void ProbabilisticScoringDecayParameters_set_liquidity_offset_half_life(struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ProbabilisticScoringDecayParameters given each field
 */
MUST_USE_RES struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_new(uint64_t historical_no_updates_half_life_arg, uint64_t liquidity_offset_half_life_arg);

/**
 * Creates a copy of the ProbabilisticScoringDecayParameters
 */
struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_clone(const struct LDKProbabilisticScoringDecayParameters *NONNULL_PTR orig);

/**
 * Creates a "default" ProbabilisticScoringDecayParameters. See struct and individual field documentaiton for details on which values are used.
 */
MUST_USE_RES struct LDKProbabilisticScoringDecayParameters ProbabilisticScoringDecayParameters_default(void);

/**
 * Creates a new scorer using the given scoring parameters for sending payments from a node
 * through a network graph.
 */
MUST_USE_RES struct LDKProbabilisticScorer ProbabilisticScorer_new(struct LDKProbabilisticScoringDecayParameters decay_params, const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger);

/**
 * Dump the contents of this scorer into the configured logger.
 *
 * Note that this writes roughly one line per channel for which we have a liquidity estimate,
 * which may be a substantial amount of log output.
 */
void ProbabilisticScorer_debug_log_liquidity_stats(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Query the estimated minimum and maximum liquidity available for sending a payment over the
 * channel with `scid` towards the given `target` node.
 */
MUST_USE_RES struct LDKCOption_C2Tuple_u64u64ZZ ProbabilisticScorer_estimated_channel_liquidity_range(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target);

/**
 * Query the historical estimated minimum and maximum liquidity available for sending a
 * payment over the channel with `scid` towards the given `target` node.
 *
 * Returns two sets of 32 buckets. The first set describes the lower-bound liquidity history,
 * the second set describes the upper-bound liquidity history. Each bucket describes the
 * relative frequency at which we've seen a liquidity bound in the bucket's range relative to
 * the channel's total capacity, on an arbitrary scale. Because the values are slowly decayed,
 * more recent data points are weighted more heavily than older datapoints.
 *
 * Note that the range of each bucket varies by its location to provide more granular results
 * at the edges of a channel's capacity, where it is more likely to sit.
 *
 * When scoring, the estimated probability that an upper-/lower-bound lies in a given bucket
 * is calculated by dividing that bucket's value with the total value of all buckets.
 *
 * For example, using a lower bucket count for illustrative purposes, a value of
 * `[0, 0, 0, ..., 0, 32]` indicates that we believe the probability of a bound being very
 * close to the channel's capacity to be 100%, and have never (recently) seen it in any other
 * bucket. A value of `[31, 0, 0, ..., 0, 0, 32]` indicates we've seen the bound being both
 * in the top and bottom bucket, and roughly with similar (recent) frequency.
 *
 * Because the datapoints are decayed slowly over time, values will eventually return to
 * `Some(([1; 32], [1; 32]))` and then to `None` once no datapoints remain.
 *
 * In order to fetch a single success probability from the buckets provided here, as used in
 * the scoring model, see [`Self::historical_estimated_payment_success_probability`].
 */
MUST_USE_RES struct LDKCOption_C2Tuple_ThirtyTwoU16sThirtyTwoU16sZZ ProbabilisticScorer_historical_estimated_channel_liquidity_probabilities(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target);

/**
 * Query the probability of payment success sending the given `amount_msat` over the channel
 * with `scid` towards the given `target` node, based on the historical estimated liquidity
 * bounds.
 *
 * These are the same bounds as returned by
 * [`Self::historical_estimated_channel_liquidity_probabilities`] (but not those returned by
 * [`Self::estimated_channel_liquidity_range`]).
 */
MUST_USE_RES struct LDKCOption_f64Z ProbabilisticScorer_historical_estimated_payment_success_probability(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg, uint64_t scid, const struct LDKNodeId *NONNULL_PTR target, uint64_t amount_msat, const struct LDKProbabilisticScoringFeeParameters *NONNULL_PTR params);

/**
 * Constructs a new ScoreLookUp which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreLookUp must be freed before this_arg is
 */
struct LDKScoreLookUp ProbabilisticScorer_as_ScoreLookUp(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Constructs a new ScoreUpdate which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ScoreUpdate must be freed before this_arg is
 */
struct LDKScoreUpdate ProbabilisticScorer_as_ScoreUpdate(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Constructs a new Score which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned Score must be freed before this_arg is
 */
struct LDKScore ProbabilisticScorer_as_Score(const struct LDKProbabilisticScorer *NONNULL_PTR this_arg);

/**
 * Serialize the ProbabilisticScorer object into a byte array which can be read by ProbabilisticScorer_read
 */
struct LDKCVec_u8Z ProbabilisticScorer_write(const struct LDKProbabilisticScorer *NONNULL_PTR obj);

/**
 * Read a ProbabilisticScorer from a byte array, created by ProbabilisticScorer_write
 */
struct LDKCResult_ProbabilisticScorerDecodeErrorZ ProbabilisticScorer_read(struct LDKu8slice ser, struct LDKProbabilisticScoringDecayParameters arg_a, const struct LDKNetworkGraph *NONNULL_PTR arg_b, struct LDKLogger arg_c);

/**
 * Frees any resources used by the DelayedPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void DelayedPaymentOutputDescriptor_free(struct LDKDelayedPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable.
 */
struct LDKOutPoint DelayedPaymentOutputDescriptor_get_outpoint(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable.
 */
void DelayedPaymentOutputDescriptor_set_outpoint(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Per commitment point to derive the delayed payment key by key holder.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_per_commitment_point(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * Per commitment point to derive the delayed payment key by key holder.
 */
void DelayedPaymentOutputDescriptor_set_per_commitment_point(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The `nSequence` value which must be set in the spending input to satisfy the `OP_CSV` in
 * the witness_script.
 */
uint16_t DelayedPaymentOutputDescriptor_get_to_self_delay(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The `nSequence` value which must be set in the spending input to satisfy the `OP_CSV` in
 * the witness_script.
 */
void DelayedPaymentOutputDescriptor_set_to_self_delay(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint16_t val);

/**
 * The output which is referenced by the given outpoint.
 */
struct LDKTxOut DelayedPaymentOutputDescriptor_get_output(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The output which is referenced by the given outpoint.
 */
void DelayedPaymentOutputDescriptor_set_output(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
struct LDKPublicKey DelayedPaymentOutputDescriptor_get_revocation_pubkey(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The revocation point specific to the commitment transaction which was broadcast. Used to
 * derive the witnessScript for this output.
 */
void DelayedPaymentOutputDescriptor_set_revocation_pubkey(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Arbitrary identification information returned by a call to [`ChannelSigner::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
const uint8_t (*DelayedPaymentOutputDescriptor_get_channel_keys_id(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to [`ChannelSigner::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
void DelayedPaymentOutputDescriptor_set_channel_keys_id(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
uint64_t DelayedPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this output originated from, possibly indirectly.
 */
void DelayedPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new DelayedPaymentOutputDescriptor given each field
 */
MUST_USE_RES struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKPublicKey per_commitment_point_arg, uint16_t to_self_delay_arg, struct LDKTxOut output_arg, struct LDKPublicKey revocation_pubkey_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg);

/**
 * Creates a copy of the DelayedPaymentOutputDescriptor
 */
struct LDKDelayedPaymentOutputDescriptor DelayedPaymentOutputDescriptor_clone(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the DelayedPaymentOutputDescriptor.
 */
uint64_t DelayedPaymentOutputDescriptor_hash(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR o);

/**
 * Checks if two DelayedPaymentOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool DelayedPaymentOutputDescriptor_eq(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR b);

/**
 * Serialize the DelayedPaymentOutputDescriptor object into a byte array which can be read by DelayedPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z DelayedPaymentOutputDescriptor_write(const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a DelayedPaymentOutputDescriptor from a byte array, created by DelayedPaymentOutputDescriptor_write
 */
struct LDKCResult_DelayedPaymentOutputDescriptorDecodeErrorZ DelayedPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the StaticPaymentOutputDescriptor, if is_owned is set and inner is non-NULL.
 */
void StaticPaymentOutputDescriptor_free(struct LDKStaticPaymentOutputDescriptor this_obj);

/**
 * The outpoint which is spendable.
 */
struct LDKOutPoint StaticPaymentOutputDescriptor_get_outpoint(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The outpoint which is spendable.
 */
void StaticPaymentOutputDescriptor_set_outpoint(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output which is referenced by the given outpoint.
 */
struct LDKTxOut StaticPaymentOutputDescriptor_get_output(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The output which is referenced by the given outpoint.
 */
void StaticPaymentOutputDescriptor_set_output(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * Arbitrary identification information returned by a call to [`ChannelSigner::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
const uint8_t (*StaticPaymentOutputDescriptor_get_channel_keys_id(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr))[32];

/**
 * Arbitrary identification information returned by a call to [`ChannelSigner::channel_keys_id`].
 * This may be useful in re-deriving keys used in the channel to spend the output.
 */
void StaticPaymentOutputDescriptor_set_channel_keys_id(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The value of the channel which this transactions spends.
 */
uint64_t StaticPaymentOutputDescriptor_get_channel_value_satoshis(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The value of the channel which this transactions spends.
 */
void StaticPaymentOutputDescriptor_set_channel_value_satoshis(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The necessary channel parameters that need to be provided to the re-derived signer through
 * [`ChannelSigner::provide_channel_parameters`].
 *
 * Added as optional, but always `Some` if the descriptor was produced in v0.0.117 or later.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKChannelTransactionParameters StaticPaymentOutputDescriptor_get_channel_transaction_parameters(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr);

/**
 * The necessary channel parameters that need to be provided to the re-derived signer through
 * [`ChannelSigner::provide_channel_parameters`].
 *
 * Added as optional, but always `Some` if the descriptor was produced in v0.0.117 or later.
 *
 * Note that val (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
void StaticPaymentOutputDescriptor_set_channel_transaction_parameters(struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_ptr, struct LDKChannelTransactionParameters val);

/**
 * Constructs a new StaticPaymentOutputDescriptor given each field
 *
 * Note that channel_transaction_parameters_arg (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, struct LDKThirtyTwoBytes channel_keys_id_arg, uint64_t channel_value_satoshis_arg, struct LDKChannelTransactionParameters channel_transaction_parameters_arg);

/**
 * Creates a copy of the StaticPaymentOutputDescriptor
 */
struct LDKStaticPaymentOutputDescriptor StaticPaymentOutputDescriptor_clone(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the StaticPaymentOutputDescriptor.
 */
uint64_t StaticPaymentOutputDescriptor_hash(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR o);

/**
 * Checks if two StaticPaymentOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool StaticPaymentOutputDescriptor_eq(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR a, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR b);

/**
 * Returns the `witness_script` of the spendable output.
 *
 * Note that this will only return `Some` for [`StaticPaymentOutputDescriptor`]s that
 * originated from an anchor outputs channel, as they take the form of a P2WSH script.
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ StaticPaymentOutputDescriptor_witness_script(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_arg);

/**
 * The maximum length a well-formed witness spending one of these should have.
 * Note: If you have the grind_signatures feature enabled, this will be at least 1 byte
 * shorter.
 */
MUST_USE_RES uintptr_t StaticPaymentOutputDescriptor_max_witness_length(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR this_arg);

/**
 * Serialize the StaticPaymentOutputDescriptor object into a byte array which can be read by StaticPaymentOutputDescriptor_read
 */
struct LDKCVec_u8Z StaticPaymentOutputDescriptor_write(const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a StaticPaymentOutputDescriptor from a byte array, created by StaticPaymentOutputDescriptor_write
 */
struct LDKCResult_StaticPaymentOutputDescriptorDecodeErrorZ StaticPaymentOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the SpendableOutputDescriptor
 */
void SpendableOutputDescriptor_free(struct LDKSpendableOutputDescriptor this_ptr);

/**
 * Creates a copy of the SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_clone(const struct LDKSpendableOutputDescriptor *NONNULL_PTR orig);

/**
 * Utility method to constructs a new StaticOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_output(struct LDKOutPoint outpoint, struct LDKTxOut output);

/**
 * Utility method to constructs a new DelayedPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_delayed_payment_output(struct LDKDelayedPaymentOutputDescriptor a);

/**
 * Utility method to constructs a new StaticPaymentOutput-variant SpendableOutputDescriptor
 */
struct LDKSpendableOutputDescriptor SpendableOutputDescriptor_static_payment_output(struct LDKStaticPaymentOutputDescriptor a);

/**
 * Generates a non-cryptographic 64-bit hash of the SpendableOutputDescriptor.
 */
uint64_t SpendableOutputDescriptor_hash(const struct LDKSpendableOutputDescriptor *NONNULL_PTR o);

/**
 * Checks if two SpendableOutputDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SpendableOutputDescriptor_eq(const struct LDKSpendableOutputDescriptor *NONNULL_PTR a, const struct LDKSpendableOutputDescriptor *NONNULL_PTR b);

/**
 * Serialize the SpendableOutputDescriptor object into a byte array which can be read by SpendableOutputDescriptor_read
 */
struct LDKCVec_u8Z SpendableOutputDescriptor_write(const struct LDKSpendableOutputDescriptor *NONNULL_PTR obj);

/**
 * Read a SpendableOutputDescriptor from a byte array, created by SpendableOutputDescriptor_write
 */
struct LDKCResult_SpendableOutputDescriptorDecodeErrorZ SpendableOutputDescriptor_read(struct LDKu8slice ser);

/**
 * Creates an unsigned [`PartiallySignedTransaction`] which spends the given descriptors to
 * the given outputs, plus an output to the given change destination (if sufficient
 * change value remains). The PSBT will have a feerate, at least, of the given value.
 *
 * The `locktime` argument is used to set the transaction's locktime. If `None`, the
 * transaction will have a locktime of 0. It it recommended to set this to the current block
 * height to avoid fee sniping, unless you have some specific reason to use a different
 * locktime.
 *
 * Returns the PSBT and expected max transaction weight.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee,
 * if a descriptor was duplicated, or if an output descriptor `script_pubkey`
 * does not match the one we can spend.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 */
MUST_USE_RES struct LDKCResult_C2Tuple_CVec_u8ZusizeZNoneZ SpendableOutputDescriptor_create_spendable_outputs_psbt(struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_u32Z locktime);

/**
 * Calls the free function if one is set
 */
void ChannelSigner_free(struct LDKChannelSigner this_ptr);

/**
 * Calls the free function if one is set
 */
void EcdsaChannelSigner_free(struct LDKEcdsaChannelSigner this_ptr);

/**
 * Creates a copy of a WriteableEcdsaChannelSigner
 */
struct LDKWriteableEcdsaChannelSigner WriteableEcdsaChannelSigner_clone(const struct LDKWriteableEcdsaChannelSigner *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void WriteableEcdsaChannelSigner_free(struct LDKWriteableEcdsaChannelSigner this_ptr);

/**
 * Creates a copy of the Recipient
 */
enum LDKRecipient Recipient_clone(const enum LDKRecipient *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Node-variant Recipient
 */
enum LDKRecipient Recipient_node(void);

/**
 * Utility method to constructs a new PhantomNode-variant Recipient
 */
enum LDKRecipient Recipient_phantom_node(void);

/**
 * Calls the free function if one is set
 */
void EntropySource_free(struct LDKEntropySource this_ptr);

/**
 * Calls the free function if one is set
 */
void NodeSigner_free(struct LDKNodeSigner this_ptr);

/**
 * Calls the free function if one is set
 */
void SignerProvider_free(struct LDKSignerProvider this_ptr);

/**
 * Frees any resources used by the InMemorySigner, if is_owned is set and inner is non-NULL.
 */
void InMemorySigner_free(struct LDKInMemorySigner this_obj);

/**
 * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
 * holder's anchor output in a commitment transaction, if one is present.
 */
const uint8_t (*InMemorySigner_get_funding_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key in the 2-of-2 multisig script of a channel. This key also backs the
 * holder's anchor output in a commitment transaction, if one is present.
 */
void InMemorySigner_set_funding_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key for blinded revocation pubkey.
 */
const uint8_t (*InMemorySigner_get_revocation_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key for blinded revocation pubkey.
 */
void InMemorySigner_set_revocation_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
 */
const uint8_t (*InMemorySigner_get_payment_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used for our balance in counterparty-broadcasted commitment transactions.
 */
void InMemorySigner_set_payment_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder secret key used in an HTLC transaction.
 */
const uint8_t (*InMemorySigner_get_delayed_payment_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder secret key used in an HTLC transaction.
 */
void InMemorySigner_set_delayed_payment_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Holder HTLC secret key used in commitment transaction HTLC outputs.
 */
const uint8_t (*InMemorySigner_get_htlc_base_key(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Holder HTLC secret key used in commitment transaction HTLC outputs.
 */
void InMemorySigner_set_htlc_base_key(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKSecretKey val);

/**
 * Commitment seed.
 */
const uint8_t (*InMemorySigner_get_commitment_seed(const struct LDKInMemorySigner *NONNULL_PTR this_ptr))[32];

/**
 * Commitment seed.
 */
void InMemorySigner_set_commitment_seed(struct LDKInMemorySigner *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Creates a copy of the InMemorySigner
 */
struct LDKInMemorySigner InMemorySigner_clone(const struct LDKInMemorySigner *NONNULL_PTR orig);

/**
 * Creates a new [`InMemorySigner`].
 */
MUST_USE_RES struct LDKInMemorySigner InMemorySigner_new(struct LDKSecretKey funding_key, struct LDKSecretKey revocation_base_key, struct LDKSecretKey payment_key, struct LDKSecretKey delayed_payment_base_key, struct LDKSecretKey htlc_base_key, struct LDKThirtyTwoBytes commitment_seed, uint64_t channel_value_satoshis, struct LDKThirtyTwoBytes channel_keys_id, struct LDKThirtyTwoBytes rand_bytes_unique_start);

/**
 * Returns the counterparty's pubkeys.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelPublicKeys InMemorySigner_counterparty_pubkeys(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns the `contest_delay` value specified by our counterparty and applied on holder-broadcastable
 * transactions, i.e., the amount of time that we have to wait to recover our funds if we
 * broadcast a transaction.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 */
MUST_USE_RES struct LDKCOption_u16Z InMemorySigner_counterparty_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns the `contest_delay` value specified by us and applied on transactions broadcastable
 * by our counterparty, i.e., the amount of time that they have to wait to recover their funds
 * if they broadcast a transaction.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 */
MUST_USE_RES struct LDKCOption_u16Z InMemorySigner_holder_selected_contest_delay(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns whether the holder is the initiator.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 */
MUST_USE_RES struct LDKCOption_boolZ InMemorySigner_is_outbound(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Funding outpoint
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKOutPoint InMemorySigner_funding_outpoint(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns a [`ChannelTransactionParameters`] for this channel, to be used when verifying or
 * building transactions.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelTransactionParameters InMemorySigner_get_channel_parameters(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Returns the channel type features of the channel parameters. Should be helpful for
 * determining a channel's category, i. e. legacy/anchors/taproot/etc.
 *
 * Will return `None` if [`ChannelSigner::provide_channel_parameters`] has not been called.
 * In general, this is safe to `unwrap` only in [`ChannelSigner`] implementation.
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKChannelTypeFeatures InMemorySigner_channel_type_features(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Sign the single input of `spend_tx` at index `input_idx`, which spends the output described
 * by `descriptor`, returning the witness stack for the input.
 *
 * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
 * is not spending the outpoint described by [`descriptor.outpoint`],
 * or if an output descriptor `script_pubkey` does not match the one we can spend.
 *
 * [`descriptor.outpoint`]: StaticPaymentOutputDescriptor::outpoint
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_counterparty_payment_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKStaticPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Sign the single input of `spend_tx` at index `input_idx` which spends the output
 * described by `descriptor`, returning the witness stack for the input.
 *
 * Returns an error if the input at `input_idx` does not exist, has a non-empty `script_sig`,
 * is not spending the outpoint described by [`descriptor.outpoint`], does not have a
 * sequence set to [`descriptor.to_self_delay`], or if an output descriptor
 * `script_pubkey` does not match the one we can spend.
 *
 * [`descriptor.outpoint`]: DelayedPaymentOutputDescriptor::outpoint
 * [`descriptor.to_self_delay`]: DelayedPaymentOutputDescriptor::to_self_delay
 */
MUST_USE_RES struct LDKCResult_CVec_CVec_u8ZZNoneZ InMemorySigner_sign_dynamic_p2wsh_input(const struct LDKInMemorySigner *NONNULL_PTR this_arg, struct LDKTransaction spend_tx, uintptr_t input_idx, const struct LDKDelayedPaymentOutputDescriptor *NONNULL_PTR descriptor);

/**
 * Constructs a new EntropySource which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
 */
struct LDKEntropySource InMemorySigner_as_EntropySource(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new ChannelSigner which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned ChannelSigner must be freed before this_arg is
 */
struct LDKChannelSigner InMemorySigner_as_ChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new EcdsaChannelSigner which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EcdsaChannelSigner must be freed before this_arg is
 */
struct LDKEcdsaChannelSigner InMemorySigner_as_EcdsaChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Constructs a new WriteableEcdsaChannelSigner which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned WriteableEcdsaChannelSigner must be freed before this_arg is
 */
struct LDKWriteableEcdsaChannelSigner InMemorySigner_as_WriteableEcdsaChannelSigner(const struct LDKInMemorySigner *NONNULL_PTR this_arg);

/**
 * Serialize the InMemorySigner object into a byte array which can be read by InMemorySigner_read
 */
struct LDKCVec_u8Z InMemorySigner_write(const struct LDKInMemorySigner *NONNULL_PTR obj);

/**
 * Read a InMemorySigner from a byte array, created by InMemorySigner_write
 */
struct LDKCResult_InMemorySignerDecodeErrorZ InMemorySigner_read(struct LDKu8slice ser, struct LDKEntropySource arg);

/**
 * Frees any resources used by the KeysManager, if is_owned is set and inner is non-NULL.
 */
void KeysManager_free(struct LDKKeysManager this_obj);

/**
 * Constructs a [`KeysManager`] from a 32-byte seed. If the seed is in some way biased (e.g.,
 * your CSRNG is busted) this may panic (but more importantly, you will possibly lose funds).
 * `starting_time` isn't strictly required to actually be a time, but it must absolutely,
 * without a doubt, be unique to this instance. ie if you start multiple times with the same
 * `seed`, `starting_time` must be unique to each run. Thus, the easiest way to achieve this
 * is to simply use the current time (with very high precision).
 *
 * The `seed` MUST be backed up safely prior to use so that the keys can be re-created, however,
 * obviously, `starting_time` should be unique every time you reload the library - it is only
 * used to generate new ephemeral key data (which will be stored by the individual channel if
 * necessary).
 *
 * Note that the seed is required to recover certain on-chain funds independent of
 * [`ChannelMonitor`] data, though a current copy of [`ChannelMonitor`] data is also required
 * for any channel, and some on-chain during-closing funds.
 *
 * [`ChannelMonitor`]: crate::chain::channelmonitor::ChannelMonitor
 */
MUST_USE_RES struct LDKKeysManager KeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos);

/**
 * Gets the \"node_id\" secret key used to sign gossip announcements, decode onion data, etc.
 */
MUST_USE_RES struct LDKSecretKey KeysManager_get_node_secret_key(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Derive an old [`WriteableEcdsaChannelSigner`] containing per-channel secrets based on a key derivation parameters.
 */
MUST_USE_RES struct LDKInMemorySigner KeysManager_derive_channel_keys(const struct LDKKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Signs the given [`PartiallySignedTransaction`] which spends the given [`SpendableOutputDescriptor`]s.
 * The resulting inputs will be finalized and the PSBT will be ready for broadcast if there
 * are no other inputs that need signing.
 *
 * Returns `Err(())` if the PSBT is missing a descriptor or if we fail to sign.
 *
 * May panic if the [`SpendableOutputDescriptor`]s were not generated by channels which used
 * this [`KeysManager`] or one of the [`InMemorySigner`] created by this [`KeysManager`].
 */
MUST_USE_RES struct LDKCResult_CVec_u8ZNoneZ KeysManager_sign_spendable_outputs_psbt(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_u8Z psbt);

/**
 * Creates a [`Transaction`] which spends the given descriptors to the given outputs, plus an
 * output to the given change destination (if sufficient change value remains). The
 * transaction will have a feerate, at least, of the given value.
 *
 * The `locktime` argument is used to set the transaction's locktime. If `None`, the
 * transaction will have a locktime of 0. It it recommended to set this to the current block
 * height to avoid fee sniping, unless you have some specific reason to use a different
 * locktime.
 *
 * Returns `Err(())` if the output value is greater than the input value minus required fee,
 * if a descriptor was duplicated, or if an output descriptor `script_pubkey`
 * does not match the one we can spend.
 *
 * We do not enforce that outputs meet the dust limit or that any output scripts are standard.
 *
 * May panic if the [`SpendableOutputDescriptor`]s were not generated by channels which used
 * this [`KeysManager`] or one of the [`InMemorySigner`] created by this [`KeysManager`].
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ KeysManager_spend_spendable_outputs(const struct LDKKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_u32Z locktime);

/**
 * Constructs a new EntropySource which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
 */
struct LDKEntropySource KeysManager_as_EntropySource(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a new NodeSigner which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned NodeSigner must be freed before this_arg is
 */
struct LDKNodeSigner KeysManager_as_NodeSigner(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a new SignerProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned SignerProvider must be freed before this_arg is
 */
struct LDKSignerProvider KeysManager_as_SignerProvider(const struct LDKKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the PhantomKeysManager, if is_owned is set and inner is non-NULL.
 */
void PhantomKeysManager_free(struct LDKPhantomKeysManager this_obj);

/**
 * Constructs a new EntropySource which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned EntropySource must be freed before this_arg is
 */
struct LDKEntropySource PhantomKeysManager_as_EntropySource(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a new NodeSigner which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned NodeSigner must be freed before this_arg is
 */
struct LDKNodeSigner PhantomKeysManager_as_NodeSigner(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a new SignerProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned SignerProvider must be freed before this_arg is
 */
struct LDKSignerProvider PhantomKeysManager_as_SignerProvider(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Constructs a [`PhantomKeysManager`] given a 32-byte seed and an additional `cross_node_seed`
 * that is shared across all nodes that intend to participate in [phantom node payments]
 * together.
 *
 * See [`KeysManager::new`] for more information on `seed`, `starting_time_secs`, and
 * `starting_time_nanos`.
 *
 * `cross_node_seed` must be the same across all phantom payment-receiving nodes and also the
 * same across restarts, or else inbound payments may fail.
 *
 * [phantom node payments]: PhantomKeysManager
 */
MUST_USE_RES struct LDKPhantomKeysManager PhantomKeysManager_new(const uint8_t (*seed)[32], uint64_t starting_time_secs, uint32_t starting_time_nanos, const uint8_t (*cross_node_seed)[32]);

/**
 * See [`KeysManager::spend_spendable_outputs`] for documentation on this method.
 */
MUST_USE_RES struct LDKCResult_TransactionNoneZ PhantomKeysManager_spend_spendable_outputs(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, struct LDKCVec_SpendableOutputDescriptorZ descriptors, struct LDKCVec_TxOutZ outputs, struct LDKCVec_u8Z change_destination_script, uint32_t feerate_sat_per_1000_weight, struct LDKCOption_u32Z locktime);

/**
 * See [`KeysManager::derive_channel_keys`] for documentation on this method.
 */
MUST_USE_RES struct LDKInMemorySigner PhantomKeysManager_derive_channel_keys(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg, uint64_t channel_value_satoshis, const uint8_t (*params)[32]);

/**
 * Gets the \"node_id\" secret key used to sign gossip announcements, decode onion data, etc.
 */
MUST_USE_RES struct LDKSecretKey PhantomKeysManager_get_node_secret_key(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Gets the \"node_id\" secret key of the phantom node used to sign invoices, decode the
 * last-hop onion data, etc.
 */
MUST_USE_RES struct LDKSecretKey PhantomKeysManager_get_phantom_node_secret_key(const struct LDKPhantomKeysManager *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the OnionMessenger, if is_owned is set and inner is non-NULL.
 */
void OnionMessenger_free(struct LDKOnionMessenger this_obj);

/**
 * Calls the free function if one is set
 */
void MessageRouter_free(struct LDKMessageRouter this_ptr);

/**
 * Frees any resources used by the DefaultMessageRouter, if is_owned is set and inner is non-NULL.
 */
void DefaultMessageRouter_free(struct LDKDefaultMessageRouter this_obj);

/**
 * Constructs a new DefaultMessageRouter given each field
 */
MUST_USE_RES struct LDKDefaultMessageRouter DefaultMessageRouter_new(void);

/**
 * Constructs a new MessageRouter which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned MessageRouter must be freed before this_arg is
 */
struct LDKMessageRouter DefaultMessageRouter_as_MessageRouter(const struct LDKDefaultMessageRouter *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the OnionMessagePath, if is_owned is set and inner is non-NULL.
 */
void OnionMessagePath_free(struct LDKOnionMessagePath this_obj);

/**
 * Nodes on the path between the sender and the destination.
 *
 * Returns a copy of the field.
 */
struct LDKCVec_PublicKeyZ OnionMessagePath_get_intermediate_nodes(const struct LDKOnionMessagePath *NONNULL_PTR this_ptr);

/**
 * Nodes on the path between the sender and the destination.
 */
void OnionMessagePath_set_intermediate_nodes(struct LDKOnionMessagePath *NONNULL_PTR this_ptr, struct LDKCVec_PublicKeyZ val);

/**
 * The recipient of the message.
 */
struct LDKDestination OnionMessagePath_get_destination(const struct LDKOnionMessagePath *NONNULL_PTR this_ptr);

/**
 * The recipient of the message.
 */
void OnionMessagePath_set_destination(struct LDKOnionMessagePath *NONNULL_PTR this_ptr, struct LDKDestination val);

/**
 * Constructs a new OnionMessagePath given each field
 */
MUST_USE_RES struct LDKOnionMessagePath OnionMessagePath_new(struct LDKCVec_PublicKeyZ intermediate_nodes_arg, struct LDKDestination destination_arg);

/**
 * Creates a copy of the OnionMessagePath
 */
struct LDKOnionMessagePath OnionMessagePath_clone(const struct LDKOnionMessagePath *NONNULL_PTR orig);

/**
 * Frees any resources used by the Destination
 */
void Destination_free(struct LDKDestination this_ptr);

/**
 * Creates a copy of the Destination
 */
struct LDKDestination Destination_clone(const struct LDKDestination *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Node-variant Destination
 */
struct LDKDestination Destination_node(struct LDKPublicKey a);

/**
 * Utility method to constructs a new BlindedPath-variant Destination
 */
struct LDKDestination Destination_blinded_path(struct LDKBlindedPath a);

/**
 * Frees any resources used by the SendError
 */
void SendError_free(struct LDKSendError this_ptr);

/**
 * Creates a copy of the SendError
 */
struct LDKSendError SendError_clone(const struct LDKSendError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Secp256k1-variant SendError
 */
struct LDKSendError SendError_secp256k1(enum LDKSecp256k1Error a);

/**
 * Utility method to constructs a new TooBigPacket-variant SendError
 */
struct LDKSendError SendError_too_big_packet(void);

/**
 * Utility method to constructs a new TooFewBlindedHops-variant SendError
 */
struct LDKSendError SendError_too_few_blinded_hops(void);

/**
 * Utility method to constructs a new InvalidFirstHop-variant SendError
 */
struct LDKSendError SendError_invalid_first_hop(void);

/**
 * Utility method to constructs a new InvalidMessage-variant SendError
 */
struct LDKSendError SendError_invalid_message(void);

/**
 * Utility method to constructs a new BufferFull-variant SendError
 */
struct LDKSendError SendError_buffer_full(void);

/**
 * Utility method to constructs a new GetNodeIdFailed-variant SendError
 */
struct LDKSendError SendError_get_node_id_failed(void);

/**
 * Utility method to constructs a new BlindedPathAdvanceFailed-variant SendError
 */
struct LDKSendError SendError_blinded_path_advance_failed(void);

/**
 * Checks if two SendErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SendError_eq(const struct LDKSendError *NONNULL_PTR a, const struct LDKSendError *NONNULL_PTR b);

/**
 * Calls the free function if one is set
 */
void CustomOnionMessageHandler_free(struct LDKCustomOnionMessageHandler this_ptr);

/**
 * Create an onion message with contents `message` to the destination of `path`.
 * Returns (introduction_node_id, onion_msg)
 *
 * Note that reply_path (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
struct LDKCResult_C2Tuple_PublicKeyOnionMessageZSendErrorZ create_onion_message(const struct LDKEntropySource *NONNULL_PTR entropy_source, const struct LDKNodeSigner *NONNULL_PTR node_signer, struct LDKOnionMessagePath path, struct LDKOnionMessageContents message, struct LDKBlindedPath reply_path);

/**
 * Constructs a new `OnionMessenger` to send, forward, and delegate received onion messages to
 * their respective handlers.
 */
MUST_USE_RES struct LDKOnionMessenger OnionMessenger_new(struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, struct LDKMessageRouter message_router, struct LDKOffersMessageHandler offers_handler, struct LDKCustomOnionMessageHandler custom_handler);

/**
 * Send an onion message with contents `message` to the destination of `path`.
 *
 * See [`OnionMessenger`] for example usage.
 *
 * Note that reply_path (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKCResult_NoneSendErrorZ OnionMessenger_send_onion_message(const struct LDKOnionMessenger *NONNULL_PTR this_arg, struct LDKOnionMessagePath path, struct LDKOnionMessageContents message, struct LDKBlindedPath reply_path);

/**
 * Constructs a new OnionMessageHandler which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageHandler must be freed before this_arg is
 */
struct LDKOnionMessageHandler OnionMessenger_as_OnionMessageHandler(const struct LDKOnionMessenger *NONNULL_PTR this_arg);

/**
 * Constructs a new OnionMessageProvider which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned OnionMessageProvider must be freed before this_arg is
 */
struct LDKOnionMessageProvider OnionMessenger_as_OnionMessageProvider(const struct LDKOnionMessenger *NONNULL_PTR this_arg);

/**
 * Calls the free function if one is set
 */
void OffersMessageHandler_free(struct LDKOffersMessageHandler this_ptr);

/**
 * Frees any resources used by the OffersMessage
 */
void OffersMessage_free(struct LDKOffersMessage this_ptr);

/**
 * Creates a copy of the OffersMessage
 */
struct LDKOffersMessage OffersMessage_clone(const struct LDKOffersMessage *NONNULL_PTR orig);

/**
 * Utility method to constructs a new InvoiceRequest-variant OffersMessage
 */
struct LDKOffersMessage OffersMessage_invoice_request(struct LDKInvoiceRequest a);

/**
 * Utility method to constructs a new Invoice-variant OffersMessage
 */
struct LDKOffersMessage OffersMessage_invoice(struct LDKBolt12Invoice a);

/**
 * Utility method to constructs a new InvoiceError-variant OffersMessage
 */
struct LDKOffersMessage OffersMessage_invoice_error(struct LDKInvoiceError a);

/**
 * Returns whether `tlv_type` corresponds to a TLV record for Offers.
 */
MUST_USE_RES bool OffersMessage_is_known_type(uint64_t tlv_type);

/**
 * The TLV record type for the message as used in an `onionmsg_tlv` TLV stream.
 */
MUST_USE_RES uint64_t OffersMessage_tlv_type(const struct LDKOffersMessage *NONNULL_PTR this_arg);

/**
 * Serialize the OffersMessage object into a byte array which can be read by OffersMessage_read
 */
struct LDKCVec_u8Z OffersMessage_write(const struct LDKOffersMessage *NONNULL_PTR obj);

/**
 * Read a OffersMessage from a byte array, created by OffersMessage_write
 */
struct LDKCResult_OffersMessageDecodeErrorZ OffersMessage_read(struct LDKu8slice ser, uint64_t arg_a, const struct LDKLogger *NONNULL_PTR arg_b);

/**
 * Frees any resources used by the Packet, if is_owned is set and inner is non-NULL.
 */
void Packet_free(struct LDKPacket this_obj);

/**
 * Bolt 04 version number
 */
uint8_t Packet_get_version(const struct LDKPacket *NONNULL_PTR this_ptr);

/**
 * Bolt 04 version number
 */
void Packet_set_version(struct LDKPacket *NONNULL_PTR this_ptr, uint8_t val);

/**
 * A random sepc256k1 point, used to build the ECDH shared secret to decrypt hop_data
 */
struct LDKPublicKey Packet_get_public_key(const struct LDKPacket *NONNULL_PTR this_ptr);

/**
 * A random sepc256k1 point, used to build the ECDH shared secret to decrypt hop_data
 */
void Packet_set_public_key(struct LDKPacket *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Encrypted payload for the next hop
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z Packet_get_hop_data(const struct LDKPacket *NONNULL_PTR this_ptr);

/**
 * Encrypted payload for the next hop
 */
void Packet_set_hop_data(struct LDKPacket *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * HMAC to verify the integrity of hop_data
 */
const uint8_t (*Packet_get_hmac(const struct LDKPacket *NONNULL_PTR this_ptr))[32];

/**
 * HMAC to verify the integrity of hop_data
 */
void Packet_set_hmac(struct LDKPacket *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constructs a new Packet given each field
 */
MUST_USE_RES struct LDKPacket Packet_new(uint8_t version_arg, struct LDKPublicKey public_key_arg, struct LDKCVec_u8Z hop_data_arg, struct LDKThirtyTwoBytes hmac_arg);

/**
 * Creates a copy of the Packet
 */
struct LDKPacket Packet_clone(const struct LDKPacket *NONNULL_PTR orig);

/**
 * Checks if two Packets contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Packet_eq(const struct LDKPacket *NONNULL_PTR a, const struct LDKPacket *NONNULL_PTR b);

/**
 * Serialize the Packet object into a byte array which can be read by Packet_read
 */
struct LDKCVec_u8Z Packet_write(const struct LDKPacket *NONNULL_PTR obj);

/**
 * Frees any resources used by the OnionMessageContents
 */
void OnionMessageContents_free(struct LDKOnionMessageContents this_ptr);

/**
 * Creates a copy of the OnionMessageContents
 */
struct LDKOnionMessageContents OnionMessageContents_clone(const struct LDKOnionMessageContents *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Offers-variant OnionMessageContents
 */
struct LDKOnionMessageContents OnionMessageContents_offers(struct LDKOffersMessage a);

/**
 * Utility method to constructs a new Custom-variant OnionMessageContents
 */
struct LDKOnionMessageContents OnionMessageContents_custom(struct LDKCustomOnionMessageContents a);

/**
 * Creates a copy of a CustomOnionMessageContents
 */
struct LDKCustomOnionMessageContents CustomOnionMessageContents_clone(const struct LDKCustomOnionMessageContents *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void CustomOnionMessageContents_free(struct LDKCustomOnionMessageContents this_ptr);

/**
 * Frees any resources used by the BlindedPath, if is_owned is set and inner is non-NULL.
 */
void BlindedPath_free(struct LDKBlindedPath this_obj);

/**
 * To send to a blinded path, the sender first finds a route to the unblinded
 * `introduction_node_id`, which can unblind its [`encrypted_payload`] to find out the onion
 * message or payment's next hop and forward it along.
 *
 * [`encrypted_payload`]: BlindedHop::encrypted_payload
 */
struct LDKPublicKey BlindedPath_get_introduction_node_id(const struct LDKBlindedPath *NONNULL_PTR this_ptr);

/**
 * To send to a blinded path, the sender first finds a route to the unblinded
 * `introduction_node_id`, which can unblind its [`encrypted_payload`] to find out the onion
 * message or payment's next hop and forward it along.
 *
 * [`encrypted_payload`]: BlindedHop::encrypted_payload
 */
void BlindedPath_set_introduction_node_id(struct LDKBlindedPath *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Used by the introduction node to decrypt its [`encrypted_payload`] to forward the onion
 * message or payment.
 *
 * [`encrypted_payload`]: BlindedHop::encrypted_payload
 */
struct LDKPublicKey BlindedPath_get_blinding_point(const struct LDKBlindedPath *NONNULL_PTR this_ptr);

/**
 * Used by the introduction node to decrypt its [`encrypted_payload`] to forward the onion
 * message or payment.
 *
 * [`encrypted_payload`]: BlindedHop::encrypted_payload
 */
void BlindedPath_set_blinding_point(struct LDKBlindedPath *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The hops composing the blinded path.
 */
struct LDKCVec_BlindedHopZ BlindedPath_get_blinded_hops(const struct LDKBlindedPath *NONNULL_PTR this_ptr);

/**
 * The hops composing the blinded path.
 */
void BlindedPath_set_blinded_hops(struct LDKBlindedPath *NONNULL_PTR this_ptr, struct LDKCVec_BlindedHopZ val);

/**
 * Constructs a new BlindedPath given each field
 */
MUST_USE_RES struct LDKBlindedPath BlindedPath_new(struct LDKPublicKey introduction_node_id_arg, struct LDKPublicKey blinding_point_arg, struct LDKCVec_BlindedHopZ blinded_hops_arg);

/**
 * Creates a copy of the BlindedPath
 */
struct LDKBlindedPath BlindedPath_clone(const struct LDKBlindedPath *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the BlindedPath.
 */
uint64_t BlindedPath_hash(const struct LDKBlindedPath *NONNULL_PTR o);

/**
 * Checks if two BlindedPaths contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BlindedPath_eq(const struct LDKBlindedPath *NONNULL_PTR a, const struct LDKBlindedPath *NONNULL_PTR b);

/**
 * Frees any resources used by the BlindedHop, if is_owned is set and inner is non-NULL.
 */
void BlindedHop_free(struct LDKBlindedHop this_obj);

/**
 * The blinded node id of this hop in a [`BlindedPath`].
 */
struct LDKPublicKey BlindedHop_get_blinded_node_id(const struct LDKBlindedHop *NONNULL_PTR this_ptr);

/**
 * The blinded node id of this hop in a [`BlindedPath`].
 */
void BlindedHop_set_blinded_node_id(struct LDKBlindedHop *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The encrypted payload intended for this hop in a [`BlindedPath`].
 *
 * Returns a copy of the field.
 */
struct LDKCVec_u8Z BlindedHop_get_encrypted_payload(const struct LDKBlindedHop *NONNULL_PTR this_ptr);

/**
 * The encrypted payload intended for this hop in a [`BlindedPath`].
 */
void BlindedHop_set_encrypted_payload(struct LDKBlindedHop *NONNULL_PTR this_ptr, struct LDKCVec_u8Z val);

/**
 * Constructs a new BlindedHop given each field
 */
MUST_USE_RES struct LDKBlindedHop BlindedHop_new(struct LDKPublicKey blinded_node_id_arg, struct LDKCVec_u8Z encrypted_payload_arg);

/**
 * Creates a copy of the BlindedHop
 */
struct LDKBlindedHop BlindedHop_clone(const struct LDKBlindedHop *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the BlindedHop.
 */
uint64_t BlindedHop_hash(const struct LDKBlindedHop *NONNULL_PTR o);

/**
 * Checks if two BlindedHops contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool BlindedHop_eq(const struct LDKBlindedHop *NONNULL_PTR a, const struct LDKBlindedHop *NONNULL_PTR b);

/**
 * Create a blinded path for an onion message, to be forwarded along `node_pks`. The last node
 * pubkey in `node_pks` will be the destination node.
 *
 * Errors if less than two hops are provided or if `node_pk`(s) are invalid.
 */
MUST_USE_RES struct LDKCResult_BlindedPathNoneZ BlindedPath_new_for_message(struct LDKCVec_PublicKeyZ node_pks, const struct LDKEntropySource *NONNULL_PTR entropy_source);

/**
 * Create a one-hop blinded path for a payment.
 */
MUST_USE_RES struct LDKCResult_C2Tuple_BlindedPayInfoBlindedPathZNoneZ BlindedPath_one_hop_for_payment(struct LDKPublicKey payee_node_id, struct LDKReceiveTlvs payee_tlvs, const struct LDKEntropySource *NONNULL_PTR entropy_source);

/**
 * Serialize the BlindedPath object into a byte array which can be read by BlindedPath_read
 */
struct LDKCVec_u8Z BlindedPath_write(const struct LDKBlindedPath *NONNULL_PTR obj);

/**
 * Read a BlindedPath from a byte array, created by BlindedPath_write
 */
struct LDKCResult_BlindedPathDecodeErrorZ BlindedPath_read(struct LDKu8slice ser);

/**
 * Serialize the BlindedHop object into a byte array which can be read by BlindedHop_read
 */
struct LDKCVec_u8Z BlindedHop_write(const struct LDKBlindedHop *NONNULL_PTR obj);

/**
 * Read a BlindedHop from a byte array, created by BlindedHop_write
 */
struct LDKCResult_BlindedHopDecodeErrorZ BlindedHop_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ForwardNode, if is_owned is set and inner is non-NULL.
 */
void ForwardNode_free(struct LDKForwardNode this_obj);

/**
 * The TLVs for this node's [`BlindedHop`], where the fee parameters contained within are also
 * used for [`BlindedPayInfo`] construction.
 */
struct LDKForwardTlvs ForwardNode_get_tlvs(const struct LDKForwardNode *NONNULL_PTR this_ptr);

/**
 * The TLVs for this node's [`BlindedHop`], where the fee parameters contained within are also
 * used for [`BlindedPayInfo`] construction.
 */
void ForwardNode_set_tlvs(struct LDKForwardNode *NONNULL_PTR this_ptr, struct LDKForwardTlvs val);

/**
 * This node's pubkey.
 */
struct LDKPublicKey ForwardNode_get_node_id(const struct LDKForwardNode *NONNULL_PTR this_ptr);

/**
 * This node's pubkey.
 */
void ForwardNode_set_node_id(struct LDKForwardNode *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The maximum value, in msat, that may be accepted by this node.
 */
uint64_t ForwardNode_get_htlc_maximum_msat(const struct LDKForwardNode *NONNULL_PTR this_ptr);

/**
 * The maximum value, in msat, that may be accepted by this node.
 */
void ForwardNode_set_htlc_maximum_msat(struct LDKForwardNode *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ForwardNode given each field
 */
MUST_USE_RES struct LDKForwardNode ForwardNode_new(struct LDKForwardTlvs tlvs_arg, struct LDKPublicKey node_id_arg, uint64_t htlc_maximum_msat_arg);

/**
 * Creates a copy of the ForwardNode
 */
struct LDKForwardNode ForwardNode_clone(const struct LDKForwardNode *NONNULL_PTR orig);

/**
 * Frees any resources used by the ForwardTlvs, if is_owned is set and inner is non-NULL.
 */
void ForwardTlvs_free(struct LDKForwardTlvs this_obj);

/**
 * The short channel id this payment should be forwarded out over.
 */
uint64_t ForwardTlvs_get_short_channel_id(const struct LDKForwardTlvs *NONNULL_PTR this_ptr);

/**
 * The short channel id this payment should be forwarded out over.
 */
void ForwardTlvs_set_short_channel_id(struct LDKForwardTlvs *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Payment parameters for relaying over [`Self::short_channel_id`].
 */
struct LDKPaymentRelay ForwardTlvs_get_payment_relay(const struct LDKForwardTlvs *NONNULL_PTR this_ptr);

/**
 * Payment parameters for relaying over [`Self::short_channel_id`].
 */
void ForwardTlvs_set_payment_relay(struct LDKForwardTlvs *NONNULL_PTR this_ptr, struct LDKPaymentRelay val);

/**
 * Payment constraints for relaying over [`Self::short_channel_id`].
 */
struct LDKPaymentConstraints ForwardTlvs_get_payment_constraints(const struct LDKForwardTlvs *NONNULL_PTR this_ptr);

/**
 * Payment constraints for relaying over [`Self::short_channel_id`].
 */
void ForwardTlvs_set_payment_constraints(struct LDKForwardTlvs *NONNULL_PTR this_ptr, struct LDKPaymentConstraints val);

/**
 * Supported and required features when relaying a payment onion containing this object's
 * corresponding [`BlindedHop::encrypted_payload`].
 *
 * [`BlindedHop::encrypted_payload`]: crate::blinded_path::BlindedHop::encrypted_payload
 */
struct LDKBlindedHopFeatures ForwardTlvs_get_features(const struct LDKForwardTlvs *NONNULL_PTR this_ptr);

/**
 * Supported and required features when relaying a payment onion containing this object's
 * corresponding [`BlindedHop::encrypted_payload`].
 *
 * [`BlindedHop::encrypted_payload`]: crate::blinded_path::BlindedHop::encrypted_payload
 */
void ForwardTlvs_set_features(struct LDKForwardTlvs *NONNULL_PTR this_ptr, struct LDKBlindedHopFeatures val);

/**
 * Constructs a new ForwardTlvs given each field
 */
MUST_USE_RES struct LDKForwardTlvs ForwardTlvs_new(uint64_t short_channel_id_arg, struct LDKPaymentRelay payment_relay_arg, struct LDKPaymentConstraints payment_constraints_arg, struct LDKBlindedHopFeatures features_arg);

/**
 * Creates a copy of the ForwardTlvs
 */
struct LDKForwardTlvs ForwardTlvs_clone(const struct LDKForwardTlvs *NONNULL_PTR orig);

/**
 * Frees any resources used by the ReceiveTlvs, if is_owned is set and inner is non-NULL.
 */
void ReceiveTlvs_free(struct LDKReceiveTlvs this_obj);

/**
 * Used to authenticate the sender of a payment to the receiver and tie MPP HTLCs together.
 */
const uint8_t (*ReceiveTlvs_get_payment_secret(const struct LDKReceiveTlvs *NONNULL_PTR this_ptr))[32];

/**
 * Used to authenticate the sender of a payment to the receiver and tie MPP HTLCs together.
 */
void ReceiveTlvs_set_payment_secret(struct LDKReceiveTlvs *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * Constraints for the receiver of this payment.
 */
struct LDKPaymentConstraints ReceiveTlvs_get_payment_constraints(const struct LDKReceiveTlvs *NONNULL_PTR this_ptr);

/**
 * Constraints for the receiver of this payment.
 */
void ReceiveTlvs_set_payment_constraints(struct LDKReceiveTlvs *NONNULL_PTR this_ptr, struct LDKPaymentConstraints val);

/**
 * Constructs a new ReceiveTlvs given each field
 */
MUST_USE_RES struct LDKReceiveTlvs ReceiveTlvs_new(struct LDKThirtyTwoBytes payment_secret_arg, struct LDKPaymentConstraints payment_constraints_arg);

/**
 * Creates a copy of the ReceiveTlvs
 */
struct LDKReceiveTlvs ReceiveTlvs_clone(const struct LDKReceiveTlvs *NONNULL_PTR orig);

/**
 * Frees any resources used by the PaymentRelay, if is_owned is set and inner is non-NULL.
 */
void PaymentRelay_free(struct LDKPaymentRelay this_obj);

/**
 * Number of blocks subtracted from an incoming HTLC's `cltv_expiry` for this [`BlindedHop`].
 */
uint16_t PaymentRelay_get_cltv_expiry_delta(const struct LDKPaymentRelay *NONNULL_PTR this_ptr);

/**
 * Number of blocks subtracted from an incoming HTLC's `cltv_expiry` for this [`BlindedHop`].
 */
void PaymentRelay_set_cltv_expiry_delta(struct LDKPaymentRelay *NONNULL_PTR this_ptr, uint16_t val);

/**
 * Liquidity fee charged (in millionths of the amount transferred) for relaying a payment over
 * this [`BlindedHop`], (i.e., 10,000 is 1%).
 */
uint32_t PaymentRelay_get_fee_proportional_millionths(const struct LDKPaymentRelay *NONNULL_PTR this_ptr);

/**
 * Liquidity fee charged (in millionths of the amount transferred) for relaying a payment over
 * this [`BlindedHop`], (i.e., 10,000 is 1%).
 */
void PaymentRelay_set_fee_proportional_millionths(struct LDKPaymentRelay *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Base fee charged (in millisatoshi) for relaying a payment over this [`BlindedHop`].
 */
uint32_t PaymentRelay_get_fee_base_msat(const struct LDKPaymentRelay *NONNULL_PTR this_ptr);

/**
 * Base fee charged (in millisatoshi) for relaying a payment over this [`BlindedHop`].
 */
void PaymentRelay_set_fee_base_msat(struct LDKPaymentRelay *NONNULL_PTR this_ptr, uint32_t val);

/**
 * Constructs a new PaymentRelay given each field
 */
MUST_USE_RES struct LDKPaymentRelay PaymentRelay_new(uint16_t cltv_expiry_delta_arg, uint32_t fee_proportional_millionths_arg, uint32_t fee_base_msat_arg);

/**
 * Creates a copy of the PaymentRelay
 */
struct LDKPaymentRelay PaymentRelay_clone(const struct LDKPaymentRelay *NONNULL_PTR orig);

/**
 * Frees any resources used by the PaymentConstraints, if is_owned is set and inner is non-NULL.
 */
void PaymentConstraints_free(struct LDKPaymentConstraints this_obj);

/**
 * The maximum total CLTV delta that is acceptable when relaying a payment over this
 * [`BlindedHop`].
 */
uint32_t PaymentConstraints_get_max_cltv_expiry(const struct LDKPaymentConstraints *NONNULL_PTR this_ptr);

/**
 * The maximum total CLTV delta that is acceptable when relaying a payment over this
 * [`BlindedHop`].
 */
void PaymentConstraints_set_max_cltv_expiry(struct LDKPaymentConstraints *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The minimum value, in msat, that may be accepted by the node corresponding to this
 * [`BlindedHop`].
 */
uint64_t PaymentConstraints_get_htlc_minimum_msat(const struct LDKPaymentConstraints *NONNULL_PTR this_ptr);

/**
 * The minimum value, in msat, that may be accepted by the node corresponding to this
 * [`BlindedHop`].
 */
void PaymentConstraints_set_htlc_minimum_msat(struct LDKPaymentConstraints *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new PaymentConstraints given each field
 */
MUST_USE_RES struct LDKPaymentConstraints PaymentConstraints_new(uint32_t max_cltv_expiry_arg, uint64_t htlc_minimum_msat_arg);

/**
 * Creates a copy of the PaymentConstraints
 */
struct LDKPaymentConstraints PaymentConstraints_clone(const struct LDKPaymentConstraints *NONNULL_PTR orig);

/**
 * Serialize the ForwardTlvs object into a byte array which can be read by ForwardTlvs_read
 */
struct LDKCVec_u8Z ForwardTlvs_write(const struct LDKForwardTlvs *NONNULL_PTR obj);

/**
 * Serialize the ReceiveTlvs object into a byte array which can be read by ReceiveTlvs_read
 */
struct LDKCVec_u8Z ReceiveTlvs_write(const struct LDKReceiveTlvs *NONNULL_PTR obj);

/**
 * Read a ReceiveTlvs from a byte array, created by ReceiveTlvs_write
 */
struct LDKCResult_ReceiveTlvsDecodeErrorZ ReceiveTlvs_read(struct LDKu8slice ser);

/**
 * Serialize the PaymentRelay object into a byte array which can be read by PaymentRelay_read
 */
struct LDKCVec_u8Z PaymentRelay_write(const struct LDKPaymentRelay *NONNULL_PTR obj);

/**
 * Read a PaymentRelay from a byte array, created by PaymentRelay_write
 */
struct LDKCResult_PaymentRelayDecodeErrorZ PaymentRelay_read(struct LDKu8slice ser);

/**
 * Serialize the PaymentConstraints object into a byte array which can be read by PaymentConstraints_read
 */
struct LDKCVec_u8Z PaymentConstraints_write(const struct LDKPaymentConstraints *NONNULL_PTR obj);

/**
 * Read a PaymentConstraints from a byte array, created by PaymentConstraints_write
 */
struct LDKCResult_PaymentConstraintsDecodeErrorZ PaymentConstraints_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PaymentPurpose
 */
void PaymentPurpose_free(struct LDKPaymentPurpose this_ptr);

/**
 * Creates a copy of the PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_clone(const struct LDKPaymentPurpose *NONNULL_PTR orig);

/**
 * Utility method to constructs a new InvoicePayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_invoice_payment(struct LDKCOption_ThirtyTwoBytesZ payment_preimage, struct LDKThirtyTwoBytes payment_secret);

/**
 * Utility method to constructs a new SpontaneousPayment-variant PaymentPurpose
 */
struct LDKPaymentPurpose PaymentPurpose_spontaneous_payment(struct LDKThirtyTwoBytes a);

/**
 * Checks if two PaymentPurposes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool PaymentPurpose_eq(const struct LDKPaymentPurpose *NONNULL_PTR a, const struct LDKPaymentPurpose *NONNULL_PTR b);

/**
 * Serialize the PaymentPurpose object into a byte array which can be read by PaymentPurpose_read
 */
struct LDKCVec_u8Z PaymentPurpose_write(const struct LDKPaymentPurpose *NONNULL_PTR obj);

/**
 * Read a PaymentPurpose from a byte array, created by PaymentPurpose_write
 */
struct LDKCResult_PaymentPurposeDecodeErrorZ PaymentPurpose_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ClaimedHTLC, if is_owned is set and inner is non-NULL.
 */
void ClaimedHTLC_free(struct LDKClaimedHTLC this_obj);

/**
 * The `channel_id` of the channel over which the HTLC was received.
 */
const uint8_t (*ClaimedHTLC_get_channel_id(const struct LDKClaimedHTLC *NONNULL_PTR this_ptr))[32];

/**
 * The `channel_id` of the channel over which the HTLC was received.
 */
void ClaimedHTLC_set_channel_id(struct LDKClaimedHTLC *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The `user_channel_id` of the channel over which the HTLC was received. This is the value
 * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
 * [`ChannelManager::accept_inbound_channel`] for inbound channels if
 * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
 * `user_channel_id` will be randomized for an inbound channel.
 *
 * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
 * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
 * was not actually claimed until after upgrading.)
 *
 * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
 */
struct LDKU128 ClaimedHTLC_get_user_channel_id(const struct LDKClaimedHTLC *NONNULL_PTR this_ptr);

/**
 * The `user_channel_id` of the channel over which the HTLC was received. This is the value
 * passed in to [`ChannelManager::create_channel`] for outbound channels, or to
 * [`ChannelManager::accept_inbound_channel`] for inbound channels if
 * [`UserConfig::manually_accept_inbound_channels`] config flag is set to true. Otherwise
 * `user_channel_id` will be randomized for an inbound channel.
 *
 * This field will be zero for a payment that was serialized prior to LDK version 0.0.117. (This
 * should only happen in the case that a payment was claimable prior to LDK version 0.0.117, but
 * was not actually claimed until after upgrading.)
 *
 * [`ChannelManager::create_channel`]: crate::ln::channelmanager::ChannelManager::create_channel
 * [`ChannelManager::accept_inbound_channel`]: crate::ln::channelmanager::ChannelManager::accept_inbound_channel
 * [`UserConfig::manually_accept_inbound_channels`]: crate::util::config::UserConfig::manually_accept_inbound_channels
 */
void ClaimedHTLC_set_user_channel_id(struct LDKClaimedHTLC *NONNULL_PTR this_ptr, struct LDKU128 val);

/**
 * The block height at which this HTLC expires.
 */
uint32_t ClaimedHTLC_get_cltv_expiry(const struct LDKClaimedHTLC *NONNULL_PTR this_ptr);

/**
 * The block height at which this HTLC expires.
 */
void ClaimedHTLC_set_cltv_expiry(struct LDKClaimedHTLC *NONNULL_PTR this_ptr, uint32_t val);

/**
 * The amount (in msats) of this part of an MPP.
 */
uint64_t ClaimedHTLC_get_value_msat(const struct LDKClaimedHTLC *NONNULL_PTR this_ptr);

/**
 * The amount (in msats) of this part of an MPP.
 */
void ClaimedHTLC_set_value_msat(struct LDKClaimedHTLC *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new ClaimedHTLC given each field
 */
MUST_USE_RES struct LDKClaimedHTLC ClaimedHTLC_new(struct LDKThirtyTwoBytes channel_id_arg, struct LDKU128 user_channel_id_arg, uint32_t cltv_expiry_arg, uint64_t value_msat_arg);

/**
 * Creates a copy of the ClaimedHTLC
 */
struct LDKClaimedHTLC ClaimedHTLC_clone(const struct LDKClaimedHTLC *NONNULL_PTR orig);

/**
 * Checks if two ClaimedHTLCs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ClaimedHTLC_eq(const struct LDKClaimedHTLC *NONNULL_PTR a, const struct LDKClaimedHTLC *NONNULL_PTR b);

/**
 * Serialize the ClaimedHTLC object into a byte array which can be read by ClaimedHTLC_read
 */
struct LDKCVec_u8Z ClaimedHTLC_write(const struct LDKClaimedHTLC *NONNULL_PTR obj);

/**
 * Read a ClaimedHTLC from a byte array, created by ClaimedHTLC_write
 */
struct LDKCResult_ClaimedHTLCDecodeErrorZ ClaimedHTLC_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the PathFailure
 */
void PathFailure_free(struct LDKPathFailure this_ptr);

/**
 * Creates a copy of the PathFailure
 */
struct LDKPathFailure PathFailure_clone(const struct LDKPathFailure *NONNULL_PTR orig);

/**
 * Utility method to constructs a new InitialSend-variant PathFailure
 */
struct LDKPathFailure PathFailure_initial_send(struct LDKAPIError err);

/**
 * Utility method to constructs a new OnPath-variant PathFailure
 */
struct LDKPathFailure PathFailure_on_path(struct LDKCOption_NetworkUpdateZ network_update);

/**
 * Checks if two PathFailures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool PathFailure_eq(const struct LDKPathFailure *NONNULL_PTR a, const struct LDKPathFailure *NONNULL_PTR b);

/**
 * Serialize the PathFailure object into a byte array which can be read by PathFailure_read
 */
struct LDKCVec_u8Z PathFailure_write(const struct LDKPathFailure *NONNULL_PTR obj);

/**
 * Read a PathFailure from a byte array, created by PathFailure_write
 */
struct LDKCResult_COption_PathFailureZDecodeErrorZ PathFailure_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the ClosureReason
 */
void ClosureReason_free(struct LDKClosureReason this_ptr);

/**
 * Creates a copy of the ClosureReason
 */
struct LDKClosureReason ClosureReason_clone(const struct LDKClosureReason *NONNULL_PTR orig);

/**
 * Utility method to constructs a new CounterpartyForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_counterparty_force_closed(struct LDKUntrustedString peer_msg);

/**
 * Utility method to constructs a new HolderForceClosed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_holder_force_closed(void);

/**
 * Utility method to constructs a new CooperativeClosure-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_cooperative_closure(void);

/**
 * Utility method to constructs a new CommitmentTxConfirmed-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_commitment_tx_confirmed(void);

/**
 * Utility method to constructs a new FundingTimedOut-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_funding_timed_out(void);

/**
 * Utility method to constructs a new ProcessingError-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_processing_error(struct LDKStr err);

/**
 * Utility method to constructs a new DisconnectedPeer-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_disconnected_peer(void);

/**
 * Utility method to constructs a new OutdatedChannelManager-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_outdated_channel_manager(void);

/**
 * Utility method to constructs a new CounterpartyCoopClosedUnfundedChannel-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_counterparty_coop_closed_unfunded_channel(void);

/**
 * Utility method to constructs a new FundingBatchClosure-variant ClosureReason
 */
struct LDKClosureReason ClosureReason_funding_batch_closure(void);

/**
 * Checks if two ClosureReasons contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ClosureReason_eq(const struct LDKClosureReason *NONNULL_PTR a, const struct LDKClosureReason *NONNULL_PTR b);

/**
 * Serialize the ClosureReason object into a byte array which can be read by ClosureReason_read
 */
struct LDKCVec_u8Z ClosureReason_write(const struct LDKClosureReason *NONNULL_PTR obj);

/**
 * Read a ClosureReason from a byte array, created by ClosureReason_write
 */
struct LDKCResult_COption_ClosureReasonZDecodeErrorZ ClosureReason_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the HTLCDestination
 */
void HTLCDestination_free(struct LDKHTLCDestination this_ptr);

/**
 * Creates a copy of the HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_clone(const struct LDKHTLCDestination *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NextHopChannel-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_next_hop_channel(struct LDKPublicKey node_id, struct LDKThirtyTwoBytes channel_id);

/**
 * Utility method to constructs a new UnknownNextHop-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_unknown_next_hop(uint64_t requested_forward_scid);

/**
 * Utility method to constructs a new InvalidForward-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_invalid_forward(uint64_t requested_forward_scid);

/**
 * Utility method to constructs a new FailedPayment-variant HTLCDestination
 */
struct LDKHTLCDestination HTLCDestination_failed_payment(struct LDKThirtyTwoBytes payment_hash);

/**
 * Checks if two HTLCDestinations contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool HTLCDestination_eq(const struct LDKHTLCDestination *NONNULL_PTR a, const struct LDKHTLCDestination *NONNULL_PTR b);

/**
 * Serialize the HTLCDestination object into a byte array which can be read by HTLCDestination_read
 */
struct LDKCVec_u8Z HTLCDestination_write(const struct LDKHTLCDestination *NONNULL_PTR obj);

/**
 * Read a HTLCDestination from a byte array, created by HTLCDestination_write
 */
struct LDKCResult_COption_HTLCDestinationZDecodeErrorZ HTLCDestination_read(struct LDKu8slice ser);

/**
 * Creates a copy of the PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_clone(const enum LDKPaymentFailureReason *NONNULL_PTR orig);

/**
 * Utility method to constructs a new RecipientRejected-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_recipient_rejected(void);

/**
 * Utility method to constructs a new UserAbandoned-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_user_abandoned(void);

/**
 * Utility method to constructs a new RetriesExhausted-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_retries_exhausted(void);

/**
 * Utility method to constructs a new PaymentExpired-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_payment_expired(void);

/**
 * Utility method to constructs a new RouteNotFound-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_route_not_found(void);

/**
 * Utility method to constructs a new UnexpectedError-variant PaymentFailureReason
 */
enum LDKPaymentFailureReason PaymentFailureReason_unexpected_error(void);

/**
 * Checks if two PaymentFailureReasons contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool PaymentFailureReason_eq(const enum LDKPaymentFailureReason *NONNULL_PTR a, const enum LDKPaymentFailureReason *NONNULL_PTR b);

/**
 * Serialize the PaymentFailureReason object into a byte array which can be read by PaymentFailureReason_read
 */
struct LDKCVec_u8Z PaymentFailureReason_write(const enum LDKPaymentFailureReason *NONNULL_PTR obj);

/**
 * Read a PaymentFailureReason from a byte array, created by PaymentFailureReason_write
 */
struct LDKCResult_PaymentFailureReasonDecodeErrorZ PaymentFailureReason_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the Event
 */
void Event_free(struct LDKEvent this_ptr);

/**
 * Creates a copy of the Event
 */
struct LDKEvent Event_clone(const struct LDKEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new FundingGenerationReady-variant Event
 */
struct LDKEvent Event_funding_generation_ready(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t channel_value_satoshis, struct LDKCVec_u8Z output_script, struct LDKU128 user_channel_id);

/**
 * Utility method to constructs a new PaymentClaimable-variant Event
 */
struct LDKEvent Event_payment_claimable(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, struct LDKRecipientOnionFields onion_fields, uint64_t amount_msat, uint64_t counterparty_skimmed_fee_msat, struct LDKPaymentPurpose purpose, struct LDKCOption_ThirtyTwoBytesZ via_channel_id, struct LDKCOption_U128Z via_user_channel_id, struct LDKCOption_u32Z claim_deadline);

/**
 * Utility method to constructs a new PaymentClaimed-variant Event
 */
struct LDKEvent Event_payment_claimed(struct LDKPublicKey receiver_node_id, struct LDKThirtyTwoBytes payment_hash, uint64_t amount_msat, struct LDKPaymentPurpose purpose, struct LDKCVec_ClaimedHTLCZ htlcs, struct LDKCOption_u64Z sender_intended_total_msat);

/**
 * Utility method to constructs a new PaymentSent-variant Event
 */
struct LDKEvent Event_payment_sent(struct LDKCOption_ThirtyTwoBytesZ payment_id, struct LDKThirtyTwoBytes payment_preimage, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u64Z fee_paid_msat);

/**
 * Utility method to constructs a new PaymentFailed-variant Event
 */
struct LDKEvent Event_payment_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_PaymentFailureReasonZ reason);

/**
 * Utility method to constructs a new PaymentPathSuccessful-variant Event
 */
struct LDKEvent Event_payment_path_successful(struct LDKThirtyTwoBytes payment_id, struct LDKCOption_ThirtyTwoBytesZ payment_hash, struct LDKPath path);

/**
 * Utility method to constructs a new PaymentPathFailed-variant Event
 */
struct LDKEvent Event_payment_path_failed(struct LDKCOption_ThirtyTwoBytesZ payment_id, struct LDKThirtyTwoBytes payment_hash, bool payment_failed_permanently, struct LDKPathFailure failure, struct LDKPath path, struct LDKCOption_u64Z short_channel_id);

/**
 * Utility method to constructs a new ProbeSuccessful-variant Event
 */
struct LDKEvent Event_probe_successful(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKPath path);

/**
 * Utility method to constructs a new ProbeFailed-variant Event
 */
struct LDKEvent Event_probe_failed(struct LDKThirtyTwoBytes payment_id, struct LDKThirtyTwoBytes payment_hash, struct LDKPath path, struct LDKCOption_u64Z short_channel_id);

/**
 * Utility method to constructs a new PendingHTLCsForwardable-variant Event
 */
struct LDKEvent Event_pending_htlcs_forwardable(uint64_t time_forwardable);

/**
 * Utility method to constructs a new HTLCIntercepted-variant Event
 */
struct LDKEvent Event_htlcintercepted(struct LDKThirtyTwoBytes intercept_id, uint64_t requested_next_hop_scid, struct LDKThirtyTwoBytes payment_hash, uint64_t inbound_amount_msat, uint64_t expected_outbound_amount_msat);

/**
 * Utility method to constructs a new SpendableOutputs-variant Event
 */
struct LDKEvent Event_spendable_outputs(struct LDKCVec_SpendableOutputDescriptorZ outputs, struct LDKCOption_ThirtyTwoBytesZ channel_id);

/**
 * Utility method to constructs a new PaymentForwarded-variant Event
 */
struct LDKEvent Event_payment_forwarded(struct LDKCOption_ThirtyTwoBytesZ prev_channel_id, struct LDKCOption_ThirtyTwoBytesZ next_channel_id, struct LDKCOption_u64Z fee_earned_msat, bool claim_from_onchain_tx, struct LDKCOption_u64Z outbound_amount_forwarded_msat);

/**
 * Utility method to constructs a new ChannelPending-variant Event
 */
struct LDKEvent Event_channel_pending(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKCOption_ThirtyTwoBytesZ former_temporary_channel_id, struct LDKPublicKey counterparty_node_id, struct LDKOutPoint funding_txo);

/**
 * Utility method to constructs a new ChannelReady-variant Event
 */
struct LDKEvent Event_channel_ready(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKPublicKey counterparty_node_id, struct LDKChannelTypeFeatures channel_type);

/**
 * Utility method to constructs a new ChannelClosed-variant Event
 */
struct LDKEvent Event_channel_closed(struct LDKThirtyTwoBytes channel_id, struct LDKU128 user_channel_id, struct LDKClosureReason reason, struct LDKPublicKey counterparty_node_id, struct LDKCOption_u64Z channel_capacity_sats);

/**
 * Utility method to constructs a new DiscardFunding-variant Event
 */
struct LDKEvent Event_discard_funding(struct LDKThirtyTwoBytes channel_id, struct LDKTransaction transaction);

/**
 * Utility method to constructs a new OpenChannelRequest-variant Event
 */
struct LDKEvent Event_open_channel_request(struct LDKThirtyTwoBytes temporary_channel_id, struct LDKPublicKey counterparty_node_id, uint64_t funding_satoshis, uint64_t push_msat, struct LDKChannelTypeFeatures channel_type);

/**
 * Utility method to constructs a new HTLCHandlingFailed-variant Event
 */
struct LDKEvent Event_htlchandling_failed(struct LDKThirtyTwoBytes prev_channel_id, struct LDKHTLCDestination failed_next_destination);

/**
 * Utility method to constructs a new BumpTransaction-variant Event
 */
struct LDKEvent Event_bump_transaction(struct LDKBumpTransactionEvent a);

/**
 * Checks if two Events contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Event_eq(const struct LDKEvent *NONNULL_PTR a, const struct LDKEvent *NONNULL_PTR b);

/**
 * Serialize the Event object into a byte array which can be read by Event_read
 */
struct LDKCVec_u8Z Event_write(const struct LDKEvent *NONNULL_PTR obj);

/**
 * Read a Event from a byte array, created by Event_write
 */
struct LDKCResult_COption_EventZDecodeErrorZ Event_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the MessageSendEvent
 */
void MessageSendEvent_free(struct LDKMessageSendEvent this_ptr);

/**
 * Creates a copy of the MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_clone(const struct LDKMessageSendEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SendAcceptChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_accept_channel(struct LDKPublicKey node_id, struct LDKAcceptChannel msg);

/**
 * Utility method to constructs a new SendAcceptChannelV2-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_accept_channel_v2(struct LDKPublicKey node_id, struct LDKAcceptChannelV2 msg);

/**
 * Utility method to constructs a new SendOpenChannel-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_open_channel(struct LDKPublicKey node_id, struct LDKOpenChannel msg);

/**
 * Utility method to constructs a new SendOpenChannelV2-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_open_channel_v2(struct LDKPublicKey node_id, struct LDKOpenChannelV2 msg);

/**
 * Utility method to constructs a new SendFundingCreated-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_created(struct LDKPublicKey node_id, struct LDKFundingCreated msg);

/**
 * Utility method to constructs a new SendFundingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_funding_signed(struct LDKPublicKey node_id, struct LDKFundingSigned msg);

/**
 * Utility method to constructs a new SendTxAddInput-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_add_input(struct LDKPublicKey node_id, struct LDKTxAddInput msg);

/**
 * Utility method to constructs a new SendTxAddOutput-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_add_output(struct LDKPublicKey node_id, struct LDKTxAddOutput msg);

/**
 * Utility method to constructs a new SendTxRemoveInput-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_remove_input(struct LDKPublicKey node_id, struct LDKTxRemoveInput msg);

/**
 * Utility method to constructs a new SendTxRemoveOutput-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_remove_output(struct LDKPublicKey node_id, struct LDKTxRemoveOutput msg);

/**
 * Utility method to constructs a new SendTxComplete-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_complete(struct LDKPublicKey node_id, struct LDKTxComplete msg);

/**
 * Utility method to constructs a new SendTxSignatures-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_signatures(struct LDKPublicKey node_id, struct LDKTxSignatures msg);

/**
 * Utility method to constructs a new SendTxInitRbf-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_init_rbf(struct LDKPublicKey node_id, struct LDKTxInitRbf msg);

/**
 * Utility method to constructs a new SendTxAckRbf-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_ack_rbf(struct LDKPublicKey node_id, struct LDKTxAckRbf msg);

/**
 * Utility method to constructs a new SendTxAbort-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_tx_abort(struct LDKPublicKey node_id, struct LDKTxAbort msg);

/**
 * Utility method to constructs a new SendChannelReady-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_ready(struct LDKPublicKey node_id, struct LDKChannelReady msg);

/**
 * Utility method to constructs a new SendAnnouncementSignatures-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_announcement_signatures(struct LDKPublicKey node_id, struct LDKAnnouncementSignatures msg);

/**
 * Utility method to constructs a new UpdateHTLCs-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_update_htlcs(struct LDKPublicKey node_id, struct LDKCommitmentUpdate updates);

/**
 * Utility method to constructs a new SendRevokeAndACK-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_revoke_and_ack(struct LDKPublicKey node_id, struct LDKRevokeAndACK msg);

/**
 * Utility method to constructs a new SendClosingSigned-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_closing_signed(struct LDKPublicKey node_id, struct LDKClosingSigned msg);

/**
 * Utility method to constructs a new SendShutdown-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_shutdown(struct LDKPublicKey node_id, struct LDKShutdown msg);

/**
 * Utility method to constructs a new SendChannelReestablish-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_reestablish(struct LDKPublicKey node_id, struct LDKChannelReestablish msg);

/**
 * Utility method to constructs a new SendChannelAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_announcement(struct LDKPublicKey node_id, struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);

/**
 * Utility method to constructs a new BroadcastChannelAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_announcement(struct LDKChannelAnnouncement msg, struct LDKChannelUpdate update_msg);

/**
 * Utility method to constructs a new BroadcastChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_channel_update(struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new BroadcastNodeAnnouncement-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_broadcast_node_announcement(struct LDKNodeAnnouncement msg);

/**
 * Utility method to constructs a new SendChannelUpdate-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_update(struct LDKPublicKey node_id, struct LDKChannelUpdate msg);

/**
 * Utility method to constructs a new HandleError-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_handle_error(struct LDKPublicKey node_id, struct LDKErrorAction action);

/**
 * Utility method to constructs a new SendChannelRangeQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_channel_range_query(struct LDKPublicKey node_id, struct LDKQueryChannelRange msg);

/**
 * Utility method to constructs a new SendShortIdsQuery-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_short_ids_query(struct LDKPublicKey node_id, struct LDKQueryShortChannelIds msg);

/**
 * Utility method to constructs a new SendReplyChannelRange-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_reply_channel_range(struct LDKPublicKey node_id, struct LDKReplyChannelRange msg);

/**
 * Utility method to constructs a new SendGossipTimestampFilter-variant MessageSendEvent
 */
struct LDKMessageSendEvent MessageSendEvent_send_gossip_timestamp_filter(struct LDKPublicKey node_id, struct LDKGossipTimestampFilter msg);

/**
 * Calls the free function if one is set
 */
void MessageSendEventsProvider_free(struct LDKMessageSendEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void OnionMessageProvider_free(struct LDKOnionMessageProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventsProvider_free(struct LDKEventsProvider this_ptr);

/**
 * Calls the free function if one is set
 */
void EventHandler_free(struct LDKEventHandler this_ptr);

/**
 * Frees any resources used by the ChannelDerivationParameters, if is_owned is set and inner is non-NULL.
 */
void ChannelDerivationParameters_free(struct LDKChannelDerivationParameters this_obj);

/**
 * The value in satoshis of the channel we're attempting to spend the anchor output of.
 */
uint64_t ChannelDerivationParameters_get_value_satoshis(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr);

/**
 * The value in satoshis of the channel we're attempting to spend the anchor output of.
 */
void ChannelDerivationParameters_set_value_satoshis(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The unique identifier to re-derive the signer for the associated channel.
 */
const uint8_t (*ChannelDerivationParameters_get_keys_id(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr))[32];

/**
 * The unique identifier to re-derive the signer for the associated channel.
 */
void ChannelDerivationParameters_set_keys_id(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, struct LDKThirtyTwoBytes val);

/**
 * The necessary channel parameters that need to be provided to the re-derived signer through
 * [`ChannelSigner::provide_channel_parameters`].
 *
 * [`ChannelSigner::provide_channel_parameters`]: crate::sign::ChannelSigner::provide_channel_parameters
 */
struct LDKChannelTransactionParameters ChannelDerivationParameters_get_transaction_parameters(const struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr);

/**
 * The necessary channel parameters that need to be provided to the re-derived signer through
 * [`ChannelSigner::provide_channel_parameters`].
 *
 * [`ChannelSigner::provide_channel_parameters`]: crate::sign::ChannelSigner::provide_channel_parameters
 */
void ChannelDerivationParameters_set_transaction_parameters(struct LDKChannelDerivationParameters *NONNULL_PTR this_ptr, struct LDKChannelTransactionParameters val);

/**
 * Constructs a new ChannelDerivationParameters given each field
 */
MUST_USE_RES struct LDKChannelDerivationParameters ChannelDerivationParameters_new(uint64_t value_satoshis_arg, struct LDKThirtyTwoBytes keys_id_arg, struct LDKChannelTransactionParameters transaction_parameters_arg);

/**
 * Creates a copy of the ChannelDerivationParameters
 */
struct LDKChannelDerivationParameters ChannelDerivationParameters_clone(const struct LDKChannelDerivationParameters *NONNULL_PTR orig);

/**
 * Checks if two ChannelDerivationParameterss contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ChannelDerivationParameters_eq(const struct LDKChannelDerivationParameters *NONNULL_PTR a, const struct LDKChannelDerivationParameters *NONNULL_PTR b);

/**
 * Serialize the ChannelDerivationParameters object into a byte array which can be read by ChannelDerivationParameters_read
 */
struct LDKCVec_u8Z ChannelDerivationParameters_write(const struct LDKChannelDerivationParameters *NONNULL_PTR obj);

/**
 * Read a ChannelDerivationParameters from a byte array, created by ChannelDerivationParameters_write
 */
struct LDKCResult_ChannelDerivationParametersDecodeErrorZ ChannelDerivationParameters_read(struct LDKu8slice ser);

/**
 * Frees any resources used by the AnchorDescriptor, if is_owned is set and inner is non-NULL.
 */
void AnchorDescriptor_free(struct LDKAnchorDescriptor this_obj);

/**
 * The parameters required to derive the signer for the anchor input.
 */
struct LDKChannelDerivationParameters AnchorDescriptor_get_channel_derivation_parameters(const struct LDKAnchorDescriptor *NONNULL_PTR this_ptr);

/**
 * The parameters required to derive the signer for the anchor input.
 */
void AnchorDescriptor_set_channel_derivation_parameters(struct LDKAnchorDescriptor *NONNULL_PTR this_ptr, struct LDKChannelDerivationParameters val);

/**
 * The transaction input's outpoint corresponding to the commitment transaction's anchor
 * output.
 */
struct LDKOutPoint AnchorDescriptor_get_outpoint(const struct LDKAnchorDescriptor *NONNULL_PTR this_ptr);

/**
 * The transaction input's outpoint corresponding to the commitment transaction's anchor
 * output.
 */
void AnchorDescriptor_set_outpoint(struct LDKAnchorDescriptor *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * Constructs a new AnchorDescriptor given each field
 */
MUST_USE_RES struct LDKAnchorDescriptor AnchorDescriptor_new(struct LDKChannelDerivationParameters channel_derivation_parameters_arg, struct LDKOutPoint outpoint_arg);

/**
 * Creates a copy of the AnchorDescriptor
 */
struct LDKAnchorDescriptor AnchorDescriptor_clone(const struct LDKAnchorDescriptor *NONNULL_PTR orig);

/**
 * Checks if two AnchorDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool AnchorDescriptor_eq(const struct LDKAnchorDescriptor *NONNULL_PTR a, const struct LDKAnchorDescriptor *NONNULL_PTR b);

/**
 * Returns the UTXO to be spent by the anchor input, which can be obtained via
 * [`Self::unsigned_tx_input`].
 */
MUST_USE_RES struct LDKTxOut AnchorDescriptor_previous_utxo(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the unsigned transaction input spending the anchor output in the commitment
 * transaction.
 */
MUST_USE_RES struct LDKTxIn AnchorDescriptor_unsigned_tx_input(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the witness script of the anchor output in the commitment transaction.
 */
MUST_USE_RES struct LDKCVec_u8Z AnchorDescriptor_witness_script(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the fully signed witness required to spend the anchor output in the commitment
 * transaction.
 */
MUST_USE_RES struct LDKWitness AnchorDescriptor_tx_input_witness(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg, struct LDKECDSASignature signature);

/**
 * Derives the channel signer required to sign the anchor input.
 */
MUST_USE_RES struct LDKWriteableEcdsaChannelSigner AnchorDescriptor_derive_channel_signer(const struct LDKAnchorDescriptor *NONNULL_PTR this_arg, const struct LDKSignerProvider *NONNULL_PTR signer_provider);

/**
 * Frees any resources used by the HTLCDescriptor, if is_owned is set and inner is non-NULL.
 */
void HTLCDescriptor_free(struct LDKHTLCDescriptor this_obj);

/**
 * The parameters required to derive the signer for the HTLC input.
 */
struct LDKChannelDerivationParameters HTLCDescriptor_get_channel_derivation_parameters(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The parameters required to derive the signer for the HTLC input.
 */
void HTLCDescriptor_set_channel_derivation_parameters(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKChannelDerivationParameters val);

/**
 * The number of the commitment transaction in which the HTLC output lives.
 */
uint64_t HTLCDescriptor_get_per_commitment_number(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The number of the commitment transaction in which the HTLC output lives.
 */
void HTLCDescriptor_set_per_commitment_number(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, uint64_t val);

/**
 * The key tweak corresponding to the number of the commitment transaction in which the HTLC
 * output lives. This tweak is applied to all the basepoints for both parties in the channel to
 * arrive at unique keys per commitment.
 *
 * See <https://github.com/lightning/bolts/blob/master/03-transactions.md#keys> for more info.
 */
struct LDKPublicKey HTLCDescriptor_get_per_commitment_point(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The key tweak corresponding to the number of the commitment transaction in which the HTLC
 * output lives. This tweak is applied to all the basepoints for both parties in the channel to
 * arrive at unique keys per commitment.
 *
 * See <https://github.com/lightning/bolts/blob/master/03-transactions.md#keys> for more info.
 */
void HTLCDescriptor_set_per_commitment_point(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * The details of the HTLC as it appears in the commitment transaction.
 */
struct LDKHTLCOutputInCommitment HTLCDescriptor_get_htlc(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The details of the HTLC as it appears in the commitment transaction.
 */
void HTLCDescriptor_set_htlc(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKHTLCOutputInCommitment val);

/**
 * The preimage, if `Some`, to claim the HTLC output with. If `None`, the timeout path must be
 * taken.
 */
struct LDKCOption_ThirtyTwoBytesZ HTLCDescriptor_get_preimage(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The preimage, if `Some`, to claim the HTLC output with. If `None`, the timeout path must be
 * taken.
 */
void HTLCDescriptor_set_preimage(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKCOption_ThirtyTwoBytesZ val);

/**
 * The counterparty's signature required to spend the HTLC output.
 */
struct LDKECDSASignature HTLCDescriptor_get_counterparty_sig(const struct LDKHTLCDescriptor *NONNULL_PTR this_ptr);

/**
 * The counterparty's signature required to spend the HTLC output.
 */
void HTLCDescriptor_set_counterparty_sig(struct LDKHTLCDescriptor *NONNULL_PTR this_ptr, struct LDKECDSASignature val);

/**
 * Creates a copy of the HTLCDescriptor
 */
struct LDKHTLCDescriptor HTLCDescriptor_clone(const struct LDKHTLCDescriptor *NONNULL_PTR orig);

/**
 * Checks if two HTLCDescriptors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool HTLCDescriptor_eq(const struct LDKHTLCDescriptor *NONNULL_PTR a, const struct LDKHTLCDescriptor *NONNULL_PTR b);

/**
 * Serialize the HTLCDescriptor object into a byte array which can be read by HTLCDescriptor_read
 */
struct LDKCVec_u8Z HTLCDescriptor_write(const struct LDKHTLCDescriptor *NONNULL_PTR obj);

/**
 * Read a HTLCDescriptor from a byte array, created by HTLCDescriptor_write
 */
struct LDKCResult_HTLCDescriptorDecodeErrorZ HTLCDescriptor_read(struct LDKu8slice ser);

/**
 * Returns the outpoint of the HTLC output in the commitment transaction. This is the outpoint
 * being spent by the HTLC input in the HTLC transaction.
 */
MUST_USE_RES struct LDKOutPoint HTLCDescriptor_outpoint(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the UTXO to be spent by the HTLC input, which can be obtained via
 * [`Self::unsigned_tx_input`].
 */
MUST_USE_RES struct LDKTxOut HTLCDescriptor_previous_utxo(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the unsigned transaction input spending the HTLC output in the commitment
 * transaction.
 */
MUST_USE_RES struct LDKTxIn HTLCDescriptor_unsigned_tx_input(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the delayed output created as a result of spending the HTLC output in the commitment
 * transaction.
 */
MUST_USE_RES struct LDKTxOut HTLCDescriptor_tx_output(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the witness script of the HTLC output in the commitment transaction.
 */
MUST_USE_RES struct LDKCVec_u8Z HTLCDescriptor_witness_script(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg);

/**
 * Returns the fully signed witness required to spend the HTLC output in the commitment
 * transaction.
 */
MUST_USE_RES struct LDKWitness HTLCDescriptor_tx_input_witness(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg, struct LDKECDSASignature signature, struct LDKu8slice witness_script);

/**
 * Derives the channel signer required to sign the HTLC input.
 */
MUST_USE_RES struct LDKWriteableEcdsaChannelSigner HTLCDescriptor_derive_channel_signer(const struct LDKHTLCDescriptor *NONNULL_PTR this_arg, const struct LDKSignerProvider *NONNULL_PTR signer_provider);

/**
 * Frees any resources used by the BumpTransactionEvent
 */
void BumpTransactionEvent_free(struct LDKBumpTransactionEvent this_ptr);

/**
 * Creates a copy of the BumpTransactionEvent
 */
struct LDKBumpTransactionEvent BumpTransactionEvent_clone(const struct LDKBumpTransactionEvent *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ChannelClose-variant BumpTransactionEvent
 */
struct LDKBumpTransactionEvent BumpTransactionEvent_channel_close(struct LDKThirtyTwoBytes claim_id, uint32_t package_target_feerate_sat_per_1000_weight, struct LDKTransaction commitment_tx, uint64_t commitment_tx_fee_satoshis, struct LDKAnchorDescriptor anchor_descriptor, struct LDKCVec_HTLCOutputInCommitmentZ pending_htlcs);

/**
 * Utility method to constructs a new HTLCResolution-variant BumpTransactionEvent
 */
struct LDKBumpTransactionEvent BumpTransactionEvent_htlcresolution(struct LDKThirtyTwoBytes claim_id, uint32_t target_feerate_sat_per_1000_weight, struct LDKCVec_HTLCDescriptorZ htlc_descriptors, uint32_t tx_lock_time);

/**
 * Checks if two BumpTransactionEvents contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool BumpTransactionEvent_eq(const struct LDKBumpTransactionEvent *NONNULL_PTR a, const struct LDKBumpTransactionEvent *NONNULL_PTR b);

/**
 * Frees any resources used by the Input, if is_owned is set and inner is non-NULL.
 */
void Input_free(struct LDKInput this_obj);

/**
 * The unique identifier of the input.
 */
struct LDKOutPoint Input_get_outpoint(const struct LDKInput *NONNULL_PTR this_ptr);

/**
 * The unique identifier of the input.
 */
void Input_set_outpoint(struct LDKInput *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The UTXO being spent by the input.
 */
struct LDKTxOut Input_get_previous_utxo(const struct LDKInput *NONNULL_PTR this_ptr);

/**
 * The UTXO being spent by the input.
 */
void Input_set_previous_utxo(struct LDKInput *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The upper-bound weight consumed by the input's full [`TxIn::script_sig`] and
 * [`TxIn::witness`], each with their lengths included, required to satisfy the output's
 * script.
 */
uint64_t Input_get_satisfaction_weight(const struct LDKInput *NONNULL_PTR this_ptr);

/**
 * The upper-bound weight consumed by the input's full [`TxIn::script_sig`] and
 * [`TxIn::witness`], each with their lengths included, required to satisfy the output's
 * script.
 */
void Input_set_satisfaction_weight(struct LDKInput *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new Input given each field
 */
MUST_USE_RES struct LDKInput Input_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut previous_utxo_arg, uint64_t satisfaction_weight_arg);

/**
 * Creates a copy of the Input
 */
struct LDKInput Input_clone(const struct LDKInput *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Input.
 */
uint64_t Input_hash(const struct LDKInput *NONNULL_PTR o);

/**
 * Checks if two Inputs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Input_eq(const struct LDKInput *NONNULL_PTR a, const struct LDKInput *NONNULL_PTR b);

/**
 * Frees any resources used by the Utxo, if is_owned is set and inner is non-NULL.
 */
void Utxo_free(struct LDKUtxo this_obj);

/**
 * The unique identifier of the output.
 */
struct LDKOutPoint Utxo_get_outpoint(const struct LDKUtxo *NONNULL_PTR this_ptr);

/**
 * The unique identifier of the output.
 */
void Utxo_set_outpoint(struct LDKUtxo *NONNULL_PTR this_ptr, struct LDKOutPoint val);

/**
 * The output to spend.
 */
struct LDKTxOut Utxo_get_output(const struct LDKUtxo *NONNULL_PTR this_ptr);

/**
 * The output to spend.
 */
void Utxo_set_output(struct LDKUtxo *NONNULL_PTR this_ptr, struct LDKTxOut val);

/**
 * The upper-bound weight consumed by the input's full [`TxIn::script_sig`] and [`TxIn::witness`], each
 * with their lengths included, required to satisfy the output's script. The weight consumed by
 * the input's `script_sig` must account for [`WITNESS_SCALE_FACTOR`].
 */
uint64_t Utxo_get_satisfaction_weight(const struct LDKUtxo *NONNULL_PTR this_ptr);

/**
 * The upper-bound weight consumed by the input's full [`TxIn::script_sig`] and [`TxIn::witness`], each
 * with their lengths included, required to satisfy the output's script. The weight consumed by
 * the input's `script_sig` must account for [`WITNESS_SCALE_FACTOR`].
 */
void Utxo_set_satisfaction_weight(struct LDKUtxo *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new Utxo given each field
 */
MUST_USE_RES struct LDKUtxo Utxo_new(struct LDKOutPoint outpoint_arg, struct LDKTxOut output_arg, uint64_t satisfaction_weight_arg);

/**
 * Creates a copy of the Utxo
 */
struct LDKUtxo Utxo_clone(const struct LDKUtxo *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Utxo.
 */
uint64_t Utxo_hash(const struct LDKUtxo *NONNULL_PTR o);

/**
 * Checks if two Utxos contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Utxo_eq(const struct LDKUtxo *NONNULL_PTR a, const struct LDKUtxo *NONNULL_PTR b);

/**
 * Returns a `Utxo` with the `satisfaction_weight` estimate for a legacy P2PKH output.
 */
MUST_USE_RES struct LDKUtxo Utxo_new_p2pkh(struct LDKOutPoint outpoint, uint64_t value, const uint8_t (*pubkey_hash)[20]);

/**
 * Frees any resources used by the CoinSelection, if is_owned is set and inner is non-NULL.
 */
void CoinSelection_free(struct LDKCoinSelection this_obj);

/**
 * The set of UTXOs (with at least 1 confirmation) to spend and use within a transaction
 * requiring additional fees.
 */
struct LDKCVec_UtxoZ CoinSelection_get_confirmed_utxos(const struct LDKCoinSelection *NONNULL_PTR this_ptr);

/**
 * The set of UTXOs (with at least 1 confirmation) to spend and use within a transaction
 * requiring additional fees.
 */
void CoinSelection_set_confirmed_utxos(struct LDKCoinSelection *NONNULL_PTR this_ptr, struct LDKCVec_UtxoZ val);

/**
 * An additional output tracking whether any change remained after coin selection. This output
 * should always have a value above dust for its given `script_pubkey`. It should not be
 * spent until the transaction it belongs to confirms to ensure mempool descendant limits are
 * not met. This implies no other party should be able to spend it except us.
 */
struct LDKCOption_TxOutZ CoinSelection_get_change_output(const struct LDKCoinSelection *NONNULL_PTR this_ptr);

/**
 * An additional output tracking whether any change remained after coin selection. This output
 * should always have a value above dust for its given `script_pubkey`. It should not be
 * spent until the transaction it belongs to confirms to ensure mempool descendant limits are
 * not met. This implies no other party should be able to spend it except us.
 */
void CoinSelection_set_change_output(struct LDKCoinSelection *NONNULL_PTR this_ptr, struct LDKCOption_TxOutZ val);

/**
 * Constructs a new CoinSelection given each field
 */
MUST_USE_RES struct LDKCoinSelection CoinSelection_new(struct LDKCVec_UtxoZ confirmed_utxos_arg, struct LDKCOption_TxOutZ change_output_arg);

/**
 * Creates a copy of the CoinSelection
 */
struct LDKCoinSelection CoinSelection_clone(const struct LDKCoinSelection *NONNULL_PTR orig);

/**
 * Calls the free function if one is set
 */
void CoinSelectionSource_free(struct LDKCoinSelectionSource this_ptr);

/**
 * Calls the free function if one is set
 */
void WalletSource_free(struct LDKWalletSource this_ptr);

/**
 * Frees any resources used by the Wallet, if is_owned is set and inner is non-NULL.
 */
void Wallet_free(struct LDKWallet this_obj);

/**
 * Returns a new instance backed by the given [`WalletSource`] that serves as an implementation
 * of [`CoinSelectionSource`].
 */
MUST_USE_RES struct LDKWallet Wallet_new(struct LDKWalletSource source, struct LDKLogger logger);

/**
 * Constructs a new CoinSelectionSource which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned CoinSelectionSource must be freed before this_arg is
 */
struct LDKCoinSelectionSource Wallet_as_CoinSelectionSource(const struct LDKWallet *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the BumpTransactionEventHandler, if is_owned is set and inner is non-NULL.
 */
void BumpTransactionEventHandler_free(struct LDKBumpTransactionEventHandler this_obj);

/**
 * Returns a new instance capable of handling [`Event::BumpTransaction`] events.
 *
 * [`Event::BumpTransaction`]: crate::events::Event::BumpTransaction
 */
MUST_USE_RES struct LDKBumpTransactionEventHandler BumpTransactionEventHandler_new(struct LDKBroadcasterInterface broadcaster, struct LDKCoinSelectionSource utxo_source, struct LDKSignerProvider signer_provider, struct LDKLogger logger);

/**
 * Handles all variants of [`BumpTransactionEvent`].
 */
void BumpTransactionEventHandler_handle_event(const struct LDKBumpTransactionEventHandler *NONNULL_PTR this_arg, const struct LDKBumpTransactionEvent *NONNULL_PTR event);

/**
 * Frees any resources used by the FilesystemStore, if is_owned is set and inner is non-NULL.
 */
void FilesystemStore_free(struct LDKFilesystemStore this_obj);

/**
 * Constructs a new [`FilesystemStore`].
 */
MUST_USE_RES struct LDKFilesystemStore FilesystemStore_new(struct LDKStr data_dir);

/**
 * Returns the data directory.
 */
MUST_USE_RES struct LDKStr FilesystemStore_get_data_dir(const struct LDKFilesystemStore *NONNULL_PTR this_arg);

/**
 * Constructs a new KVStore which calls the relevant methods on this_arg.
 * This copies the `inner` pointer in this_arg and thus the returned KVStore must be freed before this_arg is
 */
struct LDKKVStore FilesystemStore_as_KVStore(const struct LDKFilesystemStore *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the BackgroundProcessor, if is_owned is set and inner is non-NULL.
 */
void BackgroundProcessor_free(struct LDKBackgroundProcessor this_obj);

/**
 * Frees any resources used by the GossipSync
 */
void GossipSync_free(struct LDKGossipSync this_ptr);

/**
 * Utility method to constructs a new P2P-variant GossipSync
 */
struct LDKGossipSync GossipSync_p2_p(const struct LDKP2PGossipSync *NONNULL_PTR a);

/**
 * Utility method to constructs a new Rapid-variant GossipSync
 */
struct LDKGossipSync GossipSync_rapid(const struct LDKRapidGossipSync *NONNULL_PTR a);

/**
 * Utility method to constructs a new None-variant GossipSync
 */
struct LDKGossipSync GossipSync_none(void);

/**
 * Start a background thread that takes care of responsibilities enumerated in the [top-level
 * documentation].
 *
 * The thread runs indefinitely unless the object is dropped, [`stop`] is called, or
 * [`Persister::persist_manager`] returns an error. In case of an error, the error is retrieved by calling
 * either [`join`] or [`stop`].
 *
 * # Data Persistence
 *
 * [`Persister::persist_manager`] is responsible for writing out the [`ChannelManager`] to disk, and/or
 * uploading to one or more backup services. See [`ChannelManager::write`] for writing out a
 * [`ChannelManager`]. See the `lightning-persister` crate for LDK's
 * provided implementation.
 *
 * [`Persister::persist_graph`] is responsible for writing out the [`NetworkGraph`] to disk, if
 * [`GossipSync`] is supplied. See [`NetworkGraph::write`] for writing out a [`NetworkGraph`].
 * See the `lightning-persister` crate for LDK's provided implementation.
 *
 * Typically, users should either implement [`Persister::persist_manager`] to never return an
 * error or call [`join`] and handle any error that may arise. For the latter case,
 * `BackgroundProcessor` must be restarted by calling `start` again after handling the error.
 *
 * # Event Handling
 *
 * `event_handler` is responsible for handling events that users should be notified of (e.g.,
 * payment failed). [`BackgroundProcessor`] may decorate the given [`EventHandler`] with common
 * functionality implemented by other handlers.
 * * [`P2PGossipSync`] if given will update the [`NetworkGraph`] based on payment failures.
 *
 * # Rapid Gossip Sync
 *
 * If rapid gossip sync is meant to run at startup, pass [`RapidGossipSync`] via `gossip_sync`
 * to indicate that the [`BackgroundProcessor`] should not prune the [`NetworkGraph`] instance
 * until the [`RapidGossipSync`] instance completes its first sync.
 *
 * [top-level documentation]: BackgroundProcessor
 * [`join`]: Self::join
 * [`stop`]: Self::stop
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 * [`ChannelManager::write`]: lightning::ln::channelmanager::ChannelManager#impl-Writeable
 * [`Persister::persist_manager`]: lightning::util::persist::Persister::persist_manager
 * [`Persister::persist_graph`]: lightning::util::persist::Persister::persist_graph
 * [`NetworkGraph`]: lightning::routing::gossip::NetworkGraph
 * [`NetworkGraph::write`]: lightning::routing::gossip::NetworkGraph#impl-Writeable
 */
MUST_USE_RES struct LDKBackgroundProcessor BackgroundProcessor_start(struct LDKPersister persister, struct LDKEventHandler event_handler, const struct LDKChainMonitor *NONNULL_PTR chain_monitor, const struct LDKChannelManager *NONNULL_PTR channel_manager, struct LDKGossipSync gossip_sync, const struct LDKPeerManager *NONNULL_PTR peer_manager, struct LDKLogger logger, struct LDKCOption_WriteableScoreZ scorer);

/**
 * Join `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneIOErrorZ BackgroundProcessor_join(struct LDKBackgroundProcessor this_arg);

/**
 * Stop `BackgroundProcessor`'s thread, returning any error that occurred while persisting
 * [`ChannelManager`].
 *
 * # Panics
 *
 * This function panics if the background thread has panicked such as while persisting or
 * handling events.
 *
 * [`ChannelManager`]: lightning::ln::channelmanager::ChannelManager
 */
MUST_USE_RES struct LDKCResult_NoneIOErrorZ BackgroundProcessor_stop(struct LDKBackgroundProcessor this_arg);

/**
 * Frees any resources used by the Bolt11ParseError
 */
void Bolt11ParseError_free(struct LDKBolt11ParseError this_ptr);

/**
 * Creates a copy of the Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_clone(const struct LDKBolt11ParseError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bech32Error-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_bech32_error(struct LDKBech32Error a);

/**
 * Utility method to constructs a new ParseAmountError-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_parse_amount_error(struct LDKError a);

/**
 * Utility method to constructs a new MalformedSignature-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_malformed_signature(enum LDKSecp256k1Error a);

/**
 * Utility method to constructs a new BadPrefix-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_bad_prefix(void);

/**
 * Utility method to constructs a new UnknownCurrency-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_unknown_currency(void);

/**
 * Utility method to constructs a new UnknownSiPrefix-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_unknown_si_prefix(void);

/**
 * Utility method to constructs a new MalformedHRP-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_malformed_hrp(void);

/**
 * Utility method to constructs a new TooShortDataPart-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_too_short_data_part(void);

/**
 * Utility method to constructs a new UnexpectedEndOfTaggedFields-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_unexpected_end_of_tagged_fields(void);

/**
 * Utility method to constructs a new DescriptionDecodeError-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_description_decode_error(struct LDKError a);

/**
 * Utility method to constructs a new PaddingError-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_padding_error(void);

/**
 * Utility method to constructs a new IntegerOverflowError-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_integer_overflow_error(void);

/**
 * Utility method to constructs a new InvalidSegWitProgramLength-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_invalid_seg_wit_program_length(void);

/**
 * Utility method to constructs a new InvalidPubKeyHashLength-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_invalid_pub_key_hash_length(void);

/**
 * Utility method to constructs a new InvalidScriptHashLength-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_invalid_script_hash_length(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSliceLength-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_invalid_slice_length(struct LDKStr a);

/**
 * Utility method to constructs a new Skip-variant Bolt11ParseError
 */
struct LDKBolt11ParseError Bolt11ParseError_skip(void);

/**
 * Checks if two Bolt11ParseErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Bolt11ParseError_eq(const struct LDKBolt11ParseError *NONNULL_PTR a, const struct LDKBolt11ParseError *NONNULL_PTR b);

/**
 * Frees any resources used by the ParseOrSemanticError
 */
void ParseOrSemanticError_free(struct LDKParseOrSemanticError this_ptr);

/**
 * Creates a copy of the ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_clone(const struct LDKParseOrSemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new ParseError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_parse_error(struct LDKBolt11ParseError a);

/**
 * Utility method to constructs a new SemanticError-variant ParseOrSemanticError
 */
struct LDKParseOrSemanticError ParseOrSemanticError_semantic_error(enum LDKBolt11SemanticError a);

/**
 * Checks if two ParseOrSemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ParseOrSemanticError_eq(const struct LDKParseOrSemanticError *NONNULL_PTR a, const struct LDKParseOrSemanticError *NONNULL_PTR b);

/**
 * Frees any resources used by the Bolt11Invoice, if is_owned is set and inner is non-NULL.
 */
void Bolt11Invoice_free(struct LDKBolt11Invoice this_obj);

/**
 * Checks if two Bolt11Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Bolt11Invoice_eq(const struct LDKBolt11Invoice *NONNULL_PTR a, const struct LDKBolt11Invoice *NONNULL_PTR b);

/**
 * Creates a copy of the Bolt11Invoice
 */
struct LDKBolt11Invoice Bolt11Invoice_clone(const struct LDKBolt11Invoice *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Bolt11Invoice.
 */
uint64_t Bolt11Invoice_hash(const struct LDKBolt11Invoice *NONNULL_PTR o);

/**
 * Frees any resources used by the SignedRawBolt11Invoice, if is_owned is set and inner is non-NULL.
 */
void SignedRawBolt11Invoice_free(struct LDKSignedRawBolt11Invoice this_obj);

/**
 * Checks if two SignedRawBolt11Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool SignedRawBolt11Invoice_eq(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR a, const struct LDKSignedRawBolt11Invoice *NONNULL_PTR b);

/**
 * Creates a copy of the SignedRawBolt11Invoice
 */
struct LDKSignedRawBolt11Invoice SignedRawBolt11Invoice_clone(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the SignedRawBolt11Invoice.
 */
uint64_t SignedRawBolt11Invoice_hash(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR o);

/**
 * Frees any resources used by the RawBolt11Invoice, if is_owned is set and inner is non-NULL.
 */
void RawBolt11Invoice_free(struct LDKRawBolt11Invoice this_obj);

/**
 * data part
 */
struct LDKRawDataPart RawBolt11Invoice_get_data(const struct LDKRawBolt11Invoice *NONNULL_PTR this_ptr);

/**
 * data part
 */
void RawBolt11Invoice_set_data(struct LDKRawBolt11Invoice *NONNULL_PTR this_ptr, struct LDKRawDataPart val);

/**
 * Checks if two RawBolt11Invoices contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawBolt11Invoice_eq(const struct LDKRawBolt11Invoice *NONNULL_PTR a, const struct LDKRawBolt11Invoice *NONNULL_PTR b);

/**
 * Creates a copy of the RawBolt11Invoice
 */
struct LDKRawBolt11Invoice RawBolt11Invoice_clone(const struct LDKRawBolt11Invoice *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RawBolt11Invoice.
 */
uint64_t RawBolt11Invoice_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR o);

/**
 * Frees any resources used by the RawDataPart, if is_owned is set and inner is non-NULL.
 */
void RawDataPart_free(struct LDKRawDataPart this_obj);

/**
 * generation time of the invoice
 */
struct LDKPositiveTimestamp RawDataPart_get_timestamp(const struct LDKRawDataPart *NONNULL_PTR this_ptr);

/**
 * generation time of the invoice
 */
void RawDataPart_set_timestamp(struct LDKRawDataPart *NONNULL_PTR this_ptr, struct LDKPositiveTimestamp val);

/**
 * Checks if two RawDataParts contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool RawDataPart_eq(const struct LDKRawDataPart *NONNULL_PTR a, const struct LDKRawDataPart *NONNULL_PTR b);

/**
 * Creates a copy of the RawDataPart
 */
struct LDKRawDataPart RawDataPart_clone(const struct LDKRawDataPart *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the RawDataPart.
 */
uint64_t RawDataPart_hash(const struct LDKRawDataPart *NONNULL_PTR o);

/**
 * Frees any resources used by the PositiveTimestamp, if is_owned is set and inner is non-NULL.
 */
void PositiveTimestamp_free(struct LDKPositiveTimestamp this_obj);

/**
 * Checks if two PositiveTimestamps contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PositiveTimestamp_eq(const struct LDKPositiveTimestamp *NONNULL_PTR a, const struct LDKPositiveTimestamp *NONNULL_PTR b);

/**
 * Creates a copy of the PositiveTimestamp
 */
struct LDKPositiveTimestamp PositiveTimestamp_clone(const struct LDKPositiveTimestamp *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the PositiveTimestamp.
 */
uint64_t PositiveTimestamp_hash(const struct LDKPositiveTimestamp *NONNULL_PTR o);

/**
 * Creates a copy of the SiPrefix
 */
enum LDKSiPrefix SiPrefix_clone(const enum LDKSiPrefix *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Milli-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_milli(void);

/**
 * Utility method to constructs a new Micro-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_micro(void);

/**
 * Utility method to constructs a new Nano-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_nano(void);

/**
 * Utility method to constructs a new Pico-variant SiPrefix
 */
enum LDKSiPrefix SiPrefix_pico(void);

/**
 * Checks if two SiPrefixs contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SiPrefix_eq(const enum LDKSiPrefix *NONNULL_PTR a, const enum LDKSiPrefix *NONNULL_PTR b);

/**
 * Generates a non-cryptographic 64-bit hash of the SiPrefix.
 */
uint64_t SiPrefix_hash(const enum LDKSiPrefix *NONNULL_PTR o);

/**
 * Returns the multiplier to go from a BTC value to picoBTC implied by this SiPrefix.
 * This is effectively 10^12 * the prefix multiplier
 */
MUST_USE_RES uint64_t SiPrefix_multiplier(const enum LDKSiPrefix *NONNULL_PTR this_arg);

/**
 * Creates a copy of the Currency
 */
enum LDKCurrency Currency_clone(const enum LDKCurrency *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Bitcoin-variant Currency
 */
enum LDKCurrency Currency_bitcoin(void);

/**
 * Utility method to constructs a new BitcoinTestnet-variant Currency
 */
enum LDKCurrency Currency_bitcoin_testnet(void);

/**
 * Utility method to constructs a new Regtest-variant Currency
 */
enum LDKCurrency Currency_regtest(void);

/**
 * Utility method to constructs a new Simnet-variant Currency
 */
enum LDKCurrency Currency_simnet(void);

/**
 * Utility method to constructs a new Signet-variant Currency
 */
enum LDKCurrency Currency_signet(void);

/**
 * Generates a non-cryptographic 64-bit hash of the Currency.
 */
uint64_t Currency_hash(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Checks if two Currencys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Currency_eq(const enum LDKCurrency *NONNULL_PTR a, const enum LDKCurrency *NONNULL_PTR b);

/**
 * Frees any resources used by the Sha256, if is_owned is set and inner is non-NULL.
 */
void Sha256_free(struct LDKSha256 this_obj);

/**
 * Creates a copy of the Sha256
 */
struct LDKSha256 Sha256_clone(const struct LDKSha256 *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Sha256.
 */
uint64_t Sha256_hash(const struct LDKSha256 *NONNULL_PTR o);

/**
 * Checks if two Sha256s contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Sha256_eq(const struct LDKSha256 *NONNULL_PTR a, const struct LDKSha256 *NONNULL_PTR b);

/**
 * Constructs a new [`Sha256`] from the given bytes, which are assumed to be the output of a
 * single sha256 hash.
 */
MUST_USE_RES struct LDKSha256 Sha256_from_bytes(const uint8_t (*bytes)[32]);

/**
 * Frees any resources used by the Description, if is_owned is set and inner is non-NULL.
 */
void Description_free(struct LDKDescription this_obj);

/**
 * Creates a copy of the Description
 */
struct LDKDescription Description_clone(const struct LDKDescription *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Description.
 */
uint64_t Description_hash(const struct LDKDescription *NONNULL_PTR o);

/**
 * Checks if two Descriptions contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Description_eq(const struct LDKDescription *NONNULL_PTR a, const struct LDKDescription *NONNULL_PTR b);

/**
 * Frees any resources used by the PayeePubKey, if is_owned is set and inner is non-NULL.
 */
void PayeePubKey_free(struct LDKPayeePubKey this_obj);

struct LDKPublicKey PayeePubKey_get_a(const struct LDKPayeePubKey *NONNULL_PTR this_ptr);

void PayeePubKey_set_a(struct LDKPayeePubKey *NONNULL_PTR this_ptr, struct LDKPublicKey val);

/**
 * Constructs a new PayeePubKey given each field
 */
MUST_USE_RES struct LDKPayeePubKey PayeePubKey_new(struct LDKPublicKey a_arg);

/**
 * Creates a copy of the PayeePubKey
 */
struct LDKPayeePubKey PayeePubKey_clone(const struct LDKPayeePubKey *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the PayeePubKey.
 */
uint64_t PayeePubKey_hash(const struct LDKPayeePubKey *NONNULL_PTR o);

/**
 * Checks if two PayeePubKeys contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PayeePubKey_eq(const struct LDKPayeePubKey *NONNULL_PTR a, const struct LDKPayeePubKey *NONNULL_PTR b);

/**
 * Frees any resources used by the ExpiryTime, if is_owned is set and inner is non-NULL.
 */
void ExpiryTime_free(struct LDKExpiryTime this_obj);

/**
 * Creates a copy of the ExpiryTime
 */
struct LDKExpiryTime ExpiryTime_clone(const struct LDKExpiryTime *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the ExpiryTime.
 */
uint64_t ExpiryTime_hash(const struct LDKExpiryTime *NONNULL_PTR o);

/**
 * Checks if two ExpiryTimes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool ExpiryTime_eq(const struct LDKExpiryTime *NONNULL_PTR a, const struct LDKExpiryTime *NONNULL_PTR b);

/**
 * Frees any resources used by the MinFinalCltvExpiryDelta, if is_owned is set and inner is non-NULL.
 */
void MinFinalCltvExpiryDelta_free(struct LDKMinFinalCltvExpiryDelta this_obj);

uint64_t MinFinalCltvExpiryDelta_get_a(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR this_ptr);

void MinFinalCltvExpiryDelta_set_a(struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR this_ptr, uint64_t val);

/**
 * Constructs a new MinFinalCltvExpiryDelta given each field
 */
MUST_USE_RES struct LDKMinFinalCltvExpiryDelta MinFinalCltvExpiryDelta_new(uint64_t a_arg);

/**
 * Creates a copy of the MinFinalCltvExpiryDelta
 */
struct LDKMinFinalCltvExpiryDelta MinFinalCltvExpiryDelta_clone(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the MinFinalCltvExpiryDelta.
 */
uint64_t MinFinalCltvExpiryDelta_hash(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR o);

/**
 * Checks if two MinFinalCltvExpiryDeltas contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool MinFinalCltvExpiryDelta_eq(const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR a, const struct LDKMinFinalCltvExpiryDelta *NONNULL_PTR b);

/**
 * Frees any resources used by the Fallback
 */
void Fallback_free(struct LDKFallback this_ptr);

/**
 * Creates a copy of the Fallback
 */
struct LDKFallback Fallback_clone(const struct LDKFallback *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SegWitProgram-variant Fallback
 */
struct LDKFallback Fallback_seg_wit_program(struct LDKWitnessVersion version, struct LDKCVec_u8Z program);

/**
 * Utility method to constructs a new PubKeyHash-variant Fallback
 */
struct LDKFallback Fallback_pub_key_hash(struct LDKTwentyBytes a);

/**
 * Utility method to constructs a new ScriptHash-variant Fallback
 */
struct LDKFallback Fallback_script_hash(struct LDKTwentyBytes a);

/**
 * Generates a non-cryptographic 64-bit hash of the Fallback.
 */
uint64_t Fallback_hash(const struct LDKFallback *NONNULL_PTR o);

/**
 * Checks if two Fallbacks contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Fallback_eq(const struct LDKFallback *NONNULL_PTR a, const struct LDKFallback *NONNULL_PTR b);

/**
 * Frees any resources used by the Bolt11InvoiceSignature, if is_owned is set and inner is non-NULL.
 */
void Bolt11InvoiceSignature_free(struct LDKBolt11InvoiceSignature this_obj);

/**
 * Creates a copy of the Bolt11InvoiceSignature
 */
struct LDKBolt11InvoiceSignature Bolt11InvoiceSignature_clone(const struct LDKBolt11InvoiceSignature *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the Bolt11InvoiceSignature.
 */
uint64_t Bolt11InvoiceSignature_hash(const struct LDKBolt11InvoiceSignature *NONNULL_PTR o);

/**
 * Checks if two Bolt11InvoiceSignatures contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool Bolt11InvoiceSignature_eq(const struct LDKBolt11InvoiceSignature *NONNULL_PTR a, const struct LDKBolt11InvoiceSignature *NONNULL_PTR b);

/**
 * Frees any resources used by the PrivateRoute, if is_owned is set and inner is non-NULL.
 */
void PrivateRoute_free(struct LDKPrivateRoute this_obj);

/**
 * Creates a copy of the PrivateRoute
 */
struct LDKPrivateRoute PrivateRoute_clone(const struct LDKPrivateRoute *NONNULL_PTR orig);

/**
 * Generates a non-cryptographic 64-bit hash of the PrivateRoute.
 */
uint64_t PrivateRoute_hash(const struct LDKPrivateRoute *NONNULL_PTR o);

/**
 * Checks if two PrivateRoutes contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 * Two objects with NULL inner values will be considered "equal" here.
 */
bool PrivateRoute_eq(const struct LDKPrivateRoute *NONNULL_PTR a, const struct LDKPrivateRoute *NONNULL_PTR b);

/**
 * Disassembles the `SignedRawBolt11Invoice` into its three parts:
 *  1. raw invoice
 *  2. hash of the raw invoice
 *  3. signature
 */
MUST_USE_RES struct LDKC3Tuple_RawBolt11Invoice_u832Bolt11InvoiceSignatureZ SignedRawBolt11Invoice_into_parts(struct LDKSignedRawBolt11Invoice this_arg);

/**
 * The [`RawBolt11Invoice`] which was signed.
 */
MUST_USE_RES struct LDKRawBolt11Invoice SignedRawBolt11Invoice_raw_invoice(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 * The hash of the [`RawBolt11Invoice`] that was signed.
 */
MUST_USE_RES const uint8_t (*SignedRawBolt11Invoice_signable_hash(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg))[32];

/**
 * Signature for the invoice.
 */
MUST_USE_RES struct LDKBolt11InvoiceSignature SignedRawBolt11Invoice_signature(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Recovers the public key used for signing the invoice from the recoverable signature.
 */
MUST_USE_RES struct LDKCResult_PayeePubKeySecp256k1ErrorZ SignedRawBolt11Invoice_recover_payee_pub_key(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Checks if the signature is valid for the included payee public key or if none exists if it's
 * valid for the recovered signature (which should always be true?).
 */
MUST_USE_RES bool SignedRawBolt11Invoice_check_signature(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Calculate the hash of the encoded `RawBolt11Invoice` which should be signed.
 */
MUST_USE_RES struct LDKThirtyTwoBytes RawBolt11Invoice_signable_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawBolt11Invoice_payment_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKDescription RawBolt11Invoice_description(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPayeePubKey RawBolt11Invoice_payee_pub_key(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKSha256 RawBolt11Invoice_description_hash(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKExpiryTime RawBolt11Invoice_expiry_time(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKMinFinalCltvExpiryDelta RawBolt11Invoice_min_final_cltv_expiry_delta(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_ThirtyTwoBytesZ RawBolt11Invoice_payment_secret(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_CVec_u8ZZ RawBolt11Invoice_payment_metadata(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKBolt11InvoiceFeatures RawBolt11Invoice_features(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCVec_PrivateRouteZ RawBolt11Invoice_private_routes(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

MUST_USE_RES struct LDKCOption_u64Z RawBolt11Invoice_amount_pico_btc(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

MUST_USE_RES enum LDKCurrency RawBolt11Invoice_currency(const struct LDKRawBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Creates a `PositiveTimestamp` from a Unix timestamp in the range `0..=MAX_TIMESTAMP`.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_unix_timestamp(uint64_t unix_seconds);

/**
 * Creates a `PositiveTimestamp` from a [`SystemTime`] with a corresponding Unix timestamp in
 * the range `0..=MAX_TIMESTAMP`.
 *
 * Note that the subsecond part is dropped as it is not representable in BOLT 11 invoices.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_system_time(uint64_t time);

/**
 * Creates a `PositiveTimestamp` from a [`Duration`] since the Unix epoch in the range
 * `0..=MAX_TIMESTAMP`.
 *
 * Note that the subsecond part is dropped as it is not representable in BOLT 11 invoices.
 *
 * Otherwise, returns a [`CreationError::TimestampOutOfBounds`].
 */
MUST_USE_RES struct LDKCResult_PositiveTimestampCreationErrorZ PositiveTimestamp_from_duration_since_epoch(uint64_t duration);

/**
 * Returns the Unix timestamp representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_unix_timestamp(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the duration of the stored time since the Unix epoch
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_duration_since_epoch(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * Returns the [`SystemTime`] representing the stored time
 */
MUST_USE_RES uint64_t PositiveTimestamp_as_time(const struct LDKPositiveTimestamp *NONNULL_PTR this_arg);

/**
 * The hash of the [`RawBolt11Invoice`] that was signed.
 */
MUST_USE_RES struct LDKThirtyTwoBytes Bolt11Invoice_signable_hash(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Transform the `Bolt11Invoice` into its unchecked version.
 */
MUST_USE_RES struct LDKSignedRawBolt11Invoice Bolt11Invoice_into_signed_raw(struct LDKBolt11Invoice this_arg);

/**
 * Check that the invoice is signed correctly and that key recovery works
 */
MUST_USE_RES struct LDKCResult_NoneBolt11SemanticErrorZ Bolt11Invoice_check_signature(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Constructs a `Bolt11Invoice` from a [`SignedRawBolt11Invoice`] by checking all its invariants.
 * ```
 * use lightning_invoice::*;
 *
 * let invoice = \"lnbc100p1psj9jhxdqud3jxktt5w46x7unfv9kz6mn0v3jsnp4q0d3p2sfluzdx45tqcs\\
 * h2pu5qc7lgq0xs578ngs6s0s68ua4h7cvspp5q6rmq35js88zp5dvwrv9m459tnk2zunwj5jalqtyxqulh0l\\
 * 5gflssp5nf55ny5gcrfl30xuhzj3nphgj27rstekmr9fw3ny5989s300gyus9qyysgqcqpcrzjqw2sxwe993\\
 * h5pcm4dxzpvttgza8zhkqxpgffcrf5v25nwpr3cmfg7z54kuqq8rgqqqqqqqq2qqqqq9qq9qrzjqd0ylaqcl\\
 * j9424x9m8h2vcukcgnm6s56xfgu3j78zyqzhgs4hlpzvznlugqq9vsqqqqqqqlgqqqqqeqq9qrzjqwldmj9d\\
 * ha74df76zhx6l9we0vjdquygcdt3kssupehe64g6yyp5yz5rhuqqwccqqyqqqqlgqqqqjcqq9qrzjqf9e58a\\
 * guqr0rcun0ajlvmzq3ek63cw2w282gv3z5uupmuwvgjtq2z55qsqqg6qqqyqqqrtnqqqzq3cqygrzjqvphms\\
 * ywntrrhqjcraumvc4y6r8v4z5v593trte429v4hredj7ms5z52usqq9ngqqqqqqqlgqqqqqqgq9qrzjq2v0v\\
 * p62g49p7569ev48cmulecsxe59lvaw3wlxm7r982zxa9zzj7z5l0cqqxusqqyqqqqlgqqqqqzsqygarl9fh3\\
 * 8s0gyuxjjgux34w75dnc6xp2l35j7es3jd4ugt3lu0xzre26yg5m7ke54n2d5sym4xcmxtl8238xxvw5h5h5\\
 * j5r6drg6k6zcqj0fcwg\";
 *
 * let signed = invoice.parse::<SignedRawBolt11Invoice>().unwrap();
 *
 * assert!(Bolt11Invoice::from_signed(signed).is_ok());
 * ```
 */
MUST_USE_RES struct LDKCResult_Bolt11InvoiceBolt11SemanticErrorZ Bolt11Invoice_from_signed(struct LDKSignedRawBolt11Invoice signed_invoice);

/**
 * Returns the `Bolt11Invoice`'s timestamp (should equal its creation time)
 */
MUST_USE_RES uint64_t Bolt11Invoice_timestamp(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the `Bolt11Invoice`'s timestamp as a duration since the Unix epoch
 */
MUST_USE_RES uint64_t Bolt11Invoice_duration_since_epoch(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the hash to which we will receive the preimage on completion of the payment
 */
MUST_USE_RES const uint8_t (*Bolt11Invoice_payment_hash(const struct LDKBolt11Invoice *NONNULL_PTR this_arg))[32];

/**
 * Get the payee's public key if one was included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKPublicKey Bolt11Invoice_payee_pub_key(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Get the payment secret if one was included in the invoice
 */
MUST_USE_RES const uint8_t (*Bolt11Invoice_payment_secret(const struct LDKBolt11Invoice *NONNULL_PTR this_arg))[32];

/**
 * Get the payment metadata blob if one was included in the invoice
 */
MUST_USE_RES struct LDKCOption_CVec_u8ZZ Bolt11Invoice_payment_metadata(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Get the invoice features if they were included in the invoice
 *
 * Note that the return value (or a relevant inner pointer) may be NULL or all-0s to represent None
 */
MUST_USE_RES struct LDKBolt11InvoiceFeatures Bolt11Invoice_features(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Recover the payee's public key (only to be used if none was included in the invoice)
 */
MUST_USE_RES struct LDKPublicKey Bolt11Invoice_recover_payee_pub_key(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the Duration since the Unix epoch at which the invoice expires.
 * Returning None if overflow occurred.
 */
MUST_USE_RES struct LDKCOption_u64Z Bolt11Invoice_expires_at(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the invoice's expiry time, if present, otherwise [`DEFAULT_EXPIRY_TIME`].
 */
MUST_USE_RES uint64_t Bolt11Invoice_expiry_time(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns whether the invoice has expired.
 */
MUST_USE_RES bool Bolt11Invoice_is_expired(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the Duration remaining until the invoice expires.
 */
MUST_USE_RES uint64_t Bolt11Invoice_duration_until_expiry(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the Duration remaining until the invoice expires given the current time.
 * `time` is the timestamp as a duration since the Unix epoch.
 */
MUST_USE_RES uint64_t Bolt11Invoice_expiration_remaining_from_epoch(const struct LDKBolt11Invoice *NONNULL_PTR this_arg, uint64_t time);

/**
 * Returns whether the expiry time would pass at the given point in time.
 * `at_time` is the timestamp as a duration since the Unix epoch.
 */
MUST_USE_RES bool Bolt11Invoice_would_expire(const struct LDKBolt11Invoice *NONNULL_PTR this_arg, uint64_t at_time);

/**
 * Returns the invoice's `min_final_cltv_expiry_delta` time, if present, otherwise
 * [`DEFAULT_MIN_FINAL_CLTV_EXPIRY_DELTA`].
 */
MUST_USE_RES uint64_t Bolt11Invoice_min_final_cltv_expiry_delta(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all fallback addresses as [`Address`]es
 */
MUST_USE_RES struct LDKCVec_StrZ Bolt11Invoice_fallback_addresses(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice
 */
MUST_USE_RES struct LDKCVec_PrivateRouteZ Bolt11Invoice_private_routes(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns a list of all routes included in the invoice as the underlying hints
 */
MUST_USE_RES struct LDKCVec_RouteHintZ Bolt11Invoice_route_hints(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the currency for which the invoice was issued
 */
MUST_USE_RES enum LDKCurrency Bolt11Invoice_currency(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Returns the amount if specified in the invoice as millisatoshis.
 */
MUST_USE_RES struct LDKCOption_u64Z Bolt11Invoice_amount_milli_satoshis(const struct LDKBolt11Invoice *NONNULL_PTR this_arg);

/**
 * Creates a new `Description` if `description` is at most 1023 __bytes__ long,
 * returns [`CreationError::DescriptionTooLong`] otherwise
 *
 * Please note that single characters may use more than one byte due to UTF8 encoding.
 */
MUST_USE_RES struct LDKCResult_DescriptionCreationErrorZ Description_new(struct LDKStr description);

/**
 * Returns the underlying description [`String`]
 */
MUST_USE_RES struct LDKStr Description_into_inner(struct LDKDescription this_arg);

/**
 * Construct an `ExpiryTime` from seconds.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_seconds(uint64_t seconds);

/**
 * Construct an `ExpiryTime` from a [`Duration`], dropping the sub-second part.
 */
MUST_USE_RES struct LDKExpiryTime ExpiryTime_from_duration(uint64_t duration);

/**
 * Returns the expiry time in seconds
 */
MUST_USE_RES uint64_t ExpiryTime_as_seconds(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Returns a reference to the underlying [`Duration`] (=expiry time)
 */
MUST_USE_RES uint64_t ExpiryTime_as_duration(const struct LDKExpiryTime *NONNULL_PTR this_arg);

/**
 * Creates a new (partial) route from a list of hops
 */
MUST_USE_RES struct LDKCResult_PrivateRouteCreationErrorZ PrivateRoute_new(struct LDKRouteHint hops);

/**
 * Returns the underlying list of hops
 */
MUST_USE_RES struct LDKRouteHint PrivateRoute_into_inner(struct LDKPrivateRoute this_arg);

/**
 * Creates a copy of the CreationError
 */
enum LDKCreationError CreationError_clone(const enum LDKCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DescriptionTooLong-variant CreationError
 */
enum LDKCreationError CreationError_description_too_long(void);

/**
 * Utility method to constructs a new RouteTooLong-variant CreationError
 */
enum LDKCreationError CreationError_route_too_long(void);

/**
 * Utility method to constructs a new TimestampOutOfBounds-variant CreationError
 */
enum LDKCreationError CreationError_timestamp_out_of_bounds(void);

/**
 * Utility method to constructs a new InvalidAmount-variant CreationError
 */
enum LDKCreationError CreationError_invalid_amount(void);

/**
 * Utility method to constructs a new MissingRouteHints-variant CreationError
 */
enum LDKCreationError CreationError_missing_route_hints(void);

/**
 * Utility method to constructs a new MinFinalCltvExpiryDeltaTooShort-variant CreationError
 */
enum LDKCreationError CreationError_min_final_cltv_expiry_delta_too_short(void);

/**
 * Checks if two CreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool CreationError_eq(const enum LDKCreationError *NONNULL_PTR a, const enum LDKCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a CreationError object
 */
struct LDKStr CreationError_to_str(const enum LDKCreationError *NONNULL_PTR o);

/**
 * Creates a copy of the Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_clone(const enum LDKBolt11SemanticError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new NoPaymentHash-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_no_payment_hash(void);

/**
 * Utility method to constructs a new MultiplePaymentHashes-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_multiple_payment_hashes(void);

/**
 * Utility method to constructs a new NoDescription-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_no_description(void);

/**
 * Utility method to constructs a new MultipleDescriptions-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_multiple_descriptions(void);

/**
 * Utility method to constructs a new NoPaymentSecret-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_no_payment_secret(void);

/**
 * Utility method to constructs a new MultiplePaymentSecrets-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_multiple_payment_secrets(void);

/**
 * Utility method to constructs a new InvalidFeatures-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_invalid_features(void);

/**
 * Utility method to constructs a new InvalidRecoveryId-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_invalid_recovery_id(void);

/**
 * Utility method to constructs a new InvalidSignature-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_invalid_signature(void);

/**
 * Utility method to constructs a new ImpreciseAmount-variant Bolt11SemanticError
 */
enum LDKBolt11SemanticError Bolt11SemanticError_imprecise_amount(void);

/**
 * Checks if two Bolt11SemanticErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool Bolt11SemanticError_eq(const enum LDKBolt11SemanticError *NONNULL_PTR a, const enum LDKBolt11SemanticError *NONNULL_PTR b);

/**
 * Get the string representation of a Bolt11SemanticError object
 */
struct LDKStr Bolt11SemanticError_to_str(const enum LDKBolt11SemanticError *NONNULL_PTR o);

/**
 * Frees any resources used by the SignOrCreationError
 */
void SignOrCreationError_free(struct LDKSignOrCreationError this_ptr);

/**
 * Creates a copy of the SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_clone(const struct LDKSignOrCreationError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new SignError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_sign_error(void);

/**
 * Utility method to constructs a new CreationError-variant SignOrCreationError
 */
struct LDKSignOrCreationError SignOrCreationError_creation_error(enum LDKCreationError a);

/**
 * Checks if two SignOrCreationErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool SignOrCreationError_eq(const struct LDKSignOrCreationError *NONNULL_PTR a, const struct LDKSignOrCreationError *NONNULL_PTR b);

/**
 * Get the string representation of a SignOrCreationError object
 */
struct LDKStr SignOrCreationError_to_str(const struct LDKSignOrCreationError *NONNULL_PTR o);

/**
 * Pays the given [`Bolt11Invoice`], retrying if needed based on [`Retry`].
 *
 * [`Bolt11Invoice::payment_hash`] is used as the [`PaymentId`], which ensures idempotency as long
 * as the payment is still pending. If the payment succeeds, you must ensure that a second payment
 * with the same [`PaymentHash`] is never sent.
 *
 * If you wish to use a different payment idempotency token, see [`pay_invoice_with_id`].
 */
struct LDKCResult_ThirtyTwoBytesPaymentErrorZ pay_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);

/**
 * Pays the given [`Bolt11Invoice`] with a custom idempotency key, retrying if needed based on
 * [`Retry`].
 *
 * Note that idempotency is only guaranteed as long as the payment is still pending. Once the
 * payment completes or fails, no idempotency guarantees are made.
 *
 * You should ensure that the [`Bolt11Invoice::payment_hash`] is unique and the same
 * [`PaymentHash`] has never been paid before.
 *
 * See [`pay_invoice`] for a variant which uses the [`PaymentHash`] for the idempotency token.
 */
struct LDKCResult_NonePaymentErrorZ pay_invoice_with_id(const struct LDKBolt11Invoice *NONNULL_PTR invoice, struct LDKThirtyTwoBytes payment_id, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);

/**
 * Pays the given zero-value [`Bolt11Invoice`] using the given amount, retrying if needed based on
 * [`Retry`].
 *
 * [`Bolt11Invoice::payment_hash`] is used as the [`PaymentId`], which ensures idempotency as long
 * as the payment is still pending. If the payment succeeds, you must ensure that a second payment
 * with the same [`PaymentHash`] is never sent.
 *
 * If you wish to use a different payment idempotency token, see
 * [`pay_zero_value_invoice_with_id`].
 */
struct LDKCResult_ThirtyTwoBytesPaymentErrorZ pay_zero_value_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, uint64_t amount_msats, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);

/**
 * Pays the given zero-value [`Bolt11Invoice`] using the given amount and custom idempotency key,
 * retrying if needed based on [`Retry`].
 *
 * Note that idempotency is only guaranteed as long as the payment is still pending. Once the
 * payment completes or fails, no idempotency guarantees are made.
 *
 * You should ensure that the [`Bolt11Invoice::payment_hash`] is unique and the same
 * [`PaymentHash`] has never been paid before.
 *
 * See [`pay_zero_value_invoice`] for a variant which uses the [`PaymentHash`] for the
 * idempotency token.
 */
struct LDKCResult_NonePaymentErrorZ pay_zero_value_invoice_with_id(const struct LDKBolt11Invoice *NONNULL_PTR invoice, uint64_t amount_msats, struct LDKThirtyTwoBytes payment_id, struct LDKRetry retry_strategy, const struct LDKChannelManager *NONNULL_PTR channelmanager);

/**
 * Sends payment probes over all paths of a route that would be used to pay the given invoice.
 *
 * See [`ChannelManager::send_preflight_probes`] for more information.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ preflight_probe_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKCOption_u64Z liquidity_limit_multiplier);

/**
 * Sends payment probes over all paths of a route that would be used to pay the given zero-value
 * invoice using the given amount.
 *
 * See [`ChannelManager::send_preflight_probes`] for more information.
 */
struct LDKCResult_CVec_C2Tuple_ThirtyTwoBytesThirtyTwoBytesZZProbingErrorZ preflight_probe_zero_value_invoice(const struct LDKBolt11Invoice *NONNULL_PTR invoice, uint64_t amount_msat, const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKCOption_u64Z liquidity_limit_multiplier);

/**
 * Frees any resources used by the PaymentError
 */
void PaymentError_free(struct LDKPaymentError this_ptr);

/**
 * Creates a copy of the PaymentError
 */
struct LDKPaymentError PaymentError_clone(const struct LDKPaymentError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Invoice-variant PaymentError
 */
struct LDKPaymentError PaymentError_invoice(struct LDKStr a);

/**
 * Utility method to constructs a new Sending-variant PaymentError
 */
struct LDKPaymentError PaymentError_sending(enum LDKRetryableSendFailure a);

/**
 * Checks if two PaymentErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool PaymentError_eq(const struct LDKPaymentError *NONNULL_PTR a, const struct LDKPaymentError *NONNULL_PTR b);

/**
 * Frees any resources used by the ProbingError
 */
void ProbingError_free(struct LDKProbingError this_ptr);

/**
 * Creates a copy of the ProbingError
 */
struct LDKProbingError ProbingError_clone(const struct LDKProbingError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new Invoice-variant ProbingError
 */
struct LDKProbingError ProbingError_invoice(struct LDKStr a);

/**
 * Utility method to constructs a new Sending-variant ProbingError
 */
struct LDKProbingError ProbingError_sending(struct LDKProbeSendFailure a);

/**
 * Checks if two ProbingErrors contain equal inner contents.
 * This ignores pointers and is_owned flags and looks at the values in fields.
 */
bool ProbingError_eq(const struct LDKProbingError *NONNULL_PTR a, const struct LDKProbingError *NONNULL_PTR b);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that if too many channels are included in [`PhantomRouteHints::channels`], the invoice
 *   may be too long for QR code scanning. To fix this, `PhantomRouteHints::channels` may be pared
 *   down
 *
 * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
 * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
 * If `None` is provided for `payment_hash`, then one will be created.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * `duration_since_epoch` is the current time since epoch in seconds.
 *
 * You can specify a custom `min_final_cltv_expiry_delta`, or let LDK default it to
 * [`MIN_FINAL_CLTV_EXPIRY_DELTA`]. The provided expiry must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`] - 3.
 * Note that LDK will add a buffer of 3 blocks to the delta to allow for up to a few new block
 * confirmations during routing.
 *
 * Note that the provided `keys_manager`'s `NodeSigner` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::sign::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
 * [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 * [`MIN_FINAL_CLTV_EXPIRY_DETLA`]: lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
 *
 * This can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_phantom_invoice(struct LDKCOption_u64Z amt_msat, struct LDKCOption_ThirtyTwoBytesZ payment_hash, struct LDKStr description, uint32_t invoice_expiry_delta_secs, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u16Z min_final_cltv_expiry_delta, uint64_t duration_since_epoch);

/**
 * Utility to create an invoice that can be paid to one of multiple nodes, or a \"phantom invoice.\"
 * See [`PhantomKeysManager`] for more information on phantom node payments.
 *
 * `phantom_route_hints` parameter:
 * * Contains channel info for all nodes participating in the phantom invoice
 * * Entries are retrieved from a call to [`ChannelManager::get_phantom_route_hints`] on each
 *   participating node
 * * It is fine to cache `phantom_route_hints` and reuse it across invoices, as long as the data is
 *   updated when a channel becomes disabled or closes
 * * Note that the route hints generated from `phantom_route_hints` will be limited to a maximum
 *   of 3 hints to ensure that the invoice can be scanned in a QR code. These hints are selected
 *   in the order that the nodes in `PhantomRouteHints` are specified, selecting one hint per node
 *   until the maximum is hit. Callers may provide as many `PhantomRouteHints::channels` as
 *   desired, but note that some nodes will be trimmed if more than 3 nodes are provided.
 *
 * `description_hash` is a SHA-256 hash of the description text
 *
 * `payment_hash` can be specified if you have a specific need for a custom payment hash (see the difference
 * between [`ChannelManager::create_inbound_payment`] and [`ChannelManager::create_inbound_payment_for_hash`]).
 * If `None` is provided for `payment_hash`, then one will be created.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * `duration_since_epoch` is the current time since epoch in seconds.
 *
 * Note that the provided `keys_manager`'s `NodeSigner` implementation must support phantom
 * invoices in its `sign_invoice` implementation ([`PhantomKeysManager`] satisfies this
 * requirement).
 *
 * [`PhantomKeysManager`]: lightning::sign::PhantomKeysManager
 * [`ChannelManager::get_phantom_route_hints`]: lightning::ln::channelmanager::ChannelManager::get_phantom_route_hints
 * [`ChannelManager::create_inbound_payment`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment
 * [`ChannelManager::create_inbound_payment_for_hash`]: lightning::ln::channelmanager::ChannelManager::create_inbound_payment_for_hash
 * [`PhantomRouteHints::channels`]: lightning::ln::channelmanager::PhantomRouteHints::channels
 *
 * This can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_phantom_invoice_with_description_hash(struct LDKCOption_u64Z amt_msat, struct LDKCOption_ThirtyTwoBytesZ payment_hash, uint32_t invoice_expiry_delta_secs, struct LDKSha256 description_hash, struct LDKCVec_PhantomRouteHintsZ phantom_route_hints, struct LDKEntropySource entropy_source, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u16Z min_final_cltv_expiry_delta, uint64_t duration_since_epoch);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * You can specify a custom `min_final_cltv_expiry_delta`, or let LDK default it to
 * [`MIN_FINAL_CLTV_EXPIRY_DELTA`]. The provided expiry must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
 * Note that LDK will add a buffer of 3 blocks to the delta to allow for up to a few new block
 * confirmations during routing.
 *
 * [`MIN_FINAL_CLTV_EXPIRY_DETLA`]: lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * Utility to construct an invoice. Generally, unless you want to do something like a custom
 * cltv_expiry, this is what you should be using to create an invoice. The reason being, this
 * method stores the invoice's payment secret and preimage in `ChannelManager`, so (a) the user
 * doesn't have to store preimage/payment secret information and (b) `ChannelManager` can verify
 * that the payment secret is valid when the invoice is paid.
 * Use this variant if you want to pass the `description_hash` to the invoice.
 *
 * `invoice_expiry_delta_secs` describes the number of seconds that the invoice is valid for
 * in excess of the current time.
 *
 * You can specify a custom `min_final_cltv_expiry_delta`, or let LDK default it to
 * [`MIN_FINAL_CLTV_EXPIRY_DELTA`]. The provided expiry must be at least [`MIN_FINAL_CLTV_EXPIRY_DELTA`].
 * Note that LDK will add a buffer of 3 blocks to the delta to allow for up to a few new block
 * confirmations during routing.
 *
 * [`MIN_FINAL_CLTV_EXPIRY_DETLA`]: lightning::ln::channelmanager::MIN_FINAL_CLTV_EXPIRY_DELTA
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * See [`create_invoice_from_channelmanager_with_description_hash`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_with_description_hash_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKSha256 description_hash, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * See [`create_invoice_from_channelmanager`]
 * This version can be used in a `no_std` environment, where [`std::time::SystemTime`] is not
 * available and the current time is supplied by the caller.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * See [`create_invoice_from_channelmanager_and_duration_since_epoch`]
 * This version allows for providing a custom [`PaymentHash`] for the invoice.
 * This may be useful if you're building an on-chain swap or involving another protocol where
 * the payment hash is also involved outside the scope of lightning.
 */
struct LDKCResult_Bolt11InvoiceSignOrCreationErrorZ create_invoice_from_channelmanager_and_duration_since_epoch_with_payment_hash(const struct LDKChannelManager *NONNULL_PTR channelmanager, struct LDKNodeSigner node_signer, struct LDKLogger logger, enum LDKCurrency network, struct LDKCOption_u64Z amt_msat, struct LDKStr description, uint64_t duration_since_epoch, uint32_t invoice_expiry_delta_secs, struct LDKThirtyTwoBytes payment_hash, struct LDKCOption_u16Z min_final_cltv_expiry_delta);

/**
 * Read a SiPrefix object from a string
 */
struct LDKCResult_SiPrefixBolt11ParseErrorZ SiPrefix_from_str(struct LDKStr s);

/**
 * Read a Bolt11Invoice object from a string
 */
struct LDKCResult_Bolt11InvoiceParseOrSemanticErrorZ Bolt11Invoice_from_str(struct LDKStr s);

/**
 * Read a SignedRawBolt11Invoice object from a string
 */
struct LDKCResult_SignedRawBolt11InvoiceBolt11ParseErrorZ SignedRawBolt11Invoice_from_str(struct LDKStr s);

/**
 * Get the string representation of a Bolt11ParseError object
 */
struct LDKStr Bolt11ParseError_to_str(const struct LDKBolt11ParseError *NONNULL_PTR o);

/**
 * Get the string representation of a ParseOrSemanticError object
 */
struct LDKStr ParseOrSemanticError_to_str(const struct LDKParseOrSemanticError *NONNULL_PTR o);

/**
 * Get the string representation of a Bolt11Invoice object
 */
struct LDKStr Bolt11Invoice_to_str(const struct LDKBolt11Invoice *NONNULL_PTR o);

/**
 * Get the string representation of a SignedRawBolt11Invoice object
 */
struct LDKStr SignedRawBolt11Invoice_to_str(const struct LDKSignedRawBolt11Invoice *NONNULL_PTR o);

/**
 * Get the string representation of a Currency object
 */
struct LDKStr Currency_to_str(const enum LDKCurrency *NONNULL_PTR o);

/**
 * Get the string representation of a SiPrefix object
 */
struct LDKStr SiPrefix_to_str(const enum LDKSiPrefix *NONNULL_PTR o);

/**
 * Frees any resources used by the RapidGossipSync, if is_owned is set and inner is non-NULL.
 */
void RapidGossipSync_free(struct LDKRapidGossipSync this_obj);

/**
 * Instantiate a new [`RapidGossipSync`] instance.
 */
MUST_USE_RES struct LDKRapidGossipSync RapidGossipSync_new(const struct LDKNetworkGraph *NONNULL_PTR network_graph, struct LDKLogger logger);

/**
 * Sync gossip data from a file.
 * Returns the last sync timestamp to be used the next time rapid sync data is queried.
 *
 * `network_graph`: The network graph to apply the updates to
 *
 * `sync_path`: Path to the file where the gossip update data is located
 *
 */
MUST_USE_RES struct LDKCResult_u32GraphSyncErrorZ RapidGossipSync_sync_network_graph_with_file_path(const struct LDKRapidGossipSync *NONNULL_PTR this_arg, struct LDKStr sync_path);

/**
 * Update network graph from binary data.
 * Returns the last sync timestamp to be used the next time rapid sync data is queried.
 *
 * `update_data`: `&[u8]` binary stream that comprises the update data
 */
MUST_USE_RES struct LDKCResult_u32GraphSyncErrorZ RapidGossipSync_update_network_graph(const struct LDKRapidGossipSync *NONNULL_PTR this_arg, struct LDKu8slice update_data);

/**
 * Update network graph from binary data.
 * Returns the last sync timestamp to be used the next time rapid sync data is queried.
 *
 * `update_data`: `&[u8]` binary stream that comprises the update data
 * `current_time_unix`: `Option<u64>` optional current timestamp to verify data age
 */
MUST_USE_RES struct LDKCResult_u32GraphSyncErrorZ RapidGossipSync_update_network_graph_no_std(const struct LDKRapidGossipSync *NONNULL_PTR this_arg, struct LDKu8slice update_data, struct LDKCOption_u64Z current_time_unix);

/**
 * Returns whether a rapid gossip sync has completed at least once.
 */
MUST_USE_RES bool RapidGossipSync_is_initial_sync_complete(const struct LDKRapidGossipSync *NONNULL_PTR this_arg);

/**
 * Frees any resources used by the GraphSyncError
 */
void GraphSyncError_free(struct LDKGraphSyncError this_ptr);

/**
 * Creates a copy of the GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_clone(const struct LDKGraphSyncError *NONNULL_PTR orig);

/**
 * Utility method to constructs a new DecodeError-variant GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_decode_error(struct LDKDecodeError a);

/**
 * Utility method to constructs a new LightningError-variant GraphSyncError
 */
struct LDKGraphSyncError GraphSyncError_lightning_error(struct LDKLightningError a);

#endif /* LDK_C_BINDINGS_H */

#include "ldk_ver.h"
